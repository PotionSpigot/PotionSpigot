From bfab226dd11df882f9d662181eaa220a311bb891 Mon Sep 17 00:00:00 2001
From: Eric <ehock7229@outlook.com>
Date: Sun, 12 Jul 2020 14:33:01 -0400
Subject: [PATCH] added changed from SpigotX for PotionSpigot


diff --git a/pom.xml b/pom.xml
index 6aaba502..ace0cb12 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,11 +1,10 @@
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
-    <groupId>org.github.paperspigot</groupId>
-    <artifactId>paperspigot</artifactId>
+    <artifactId>potionspigot</artifactId>
     <packaging>jar</packaging>
     <version>1.8.8-R0.1-SNAPSHOT</version>
-    <name>PaperSpigot</name>
+    <name>PotionSpigot</name>
     <url>https://hub.spigotmc.org/stash/projects/PAPER/</url>
 
     <properties>
@@ -22,8 +21,8 @@
     </properties>
 
     <parent>
-        <groupId>org.github.paperspigot</groupId>
-        <artifactId>paperspigot-parent</artifactId>
+        <groupId>org.potionspigot</groupId>
+        <artifactId>potionspigot-parent</artifactId>
         <version>dev-SNAPSHOT</version>
         <relativePath>../pom.xml</relativePath>
     </parent>
@@ -35,8 +34,8 @@
             <version>3.0.3</version>
         </dependency>
         <dependency>
-            <groupId>org.github.paperspigot</groupId>
-            <artifactId>paperspigot-api</artifactId>
+            <groupId>org.potionspigot</groupId>
+            <artifactId>potionspigot-api</artifactId>
             <version>${project.version}</version>
             <type>jar</type>
             <scope>compile</scope>
@@ -89,6 +88,12 @@
             <version>1.3</version>
             <scope>test</scope>
         </dependency>
+        <dependency>
+            <groupId>org.projectlombok</groupId>
+            <artifactId>lombok</artifactId>
+            <version>1.16.16</version>
+            <scope>provided</scope>
+        </dependency>
     </dependencies>
 
     <!-- required until fixed plexus-compiler-eclipse is deployed -->
@@ -113,7 +118,7 @@
             <artifactId>gitdescribe-maven-plugin</artifactId>
             <version>1.3</version>
             <configuration>
-                <outputPrefix>git-PaperSpigot-</outputPrefix>
+                <outputPrefix>git-PotionSpigot-</outputPrefix>
                 <scmDirectory>..</scmDirectory>
             </configuration>
             <executions>
diff --git a/src/main/java/co/aikar/timings/SpigotTimings.java b/src/main/java/co/aikar/timings/SpigotTimings.java
index b3cafafc..9d748102 100644
--- a/src/main/java/co/aikar/timings/SpigotTimings.java
+++ b/src/main/java/co/aikar/timings/SpigotTimings.java
@@ -1,9 +1,9 @@
 package co.aikar.timings;
 
 import net.minecraft.server.*;
+
 import org.bukkit.plugin.Plugin;
 import org.bukkit.scheduler.BukkitTask;
-
 import org.bukkit.craftbukkit.scheduler.CraftTask;
 
 public final class SpigotTimings {
@@ -17,20 +17,13 @@ public final class SpigotTimings {
     public static final Timing timeUpdateTimer = Timings.ofSafe("Time Update");
     public static final Timing serverCommandTimer = Timings.ofSafe("Server Command");
     public static final Timing worldSaveTimer = Timings.ofSafe("World Save");
-
     public static final Timing tickEntityTimer = Timings.ofSafe("## tickEntity");
     public static final Timing tickTileEntityTimer = Timings.ofSafe("## tickTileEntity");
-
     public static final Timing processQueueTimer = Timings.ofSafe("processQueue");
-
     public static final Timing playerCommandTimer = Timings.ofSafe("playerCommand");
-
     public static final Timing entityActivationCheckTimer = Timings.ofSafe("entityActivationCheck");
     public static final Timing checkIfActiveTimer = Timings.ofSafe("checkIfActive");
 
-    public static final Timing antiXrayUpdateTimer = Timings.ofSafe("anti-xray - update");
-    public static final Timing antiXrayObfuscateTimer = Timings.ofSafe("anti-xray - obfuscate");
-
     private SpigotTimings() {}
 
     /**
diff --git a/src/main/java/net/minecraft/server/Block.java b/src/main/java/net/minecraft/server/Block.java
index a784e04a..7ed3f6bb 100644
--- a/src/main/java/net/minecraft/server/Block.java
+++ b/src/main/java/net/minecraft/server/Block.java
@@ -691,7 +691,7 @@ public class Block {
         return 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[0]);
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockAnvil.java b/src/main/java/net/minecraft/server/BlockAnvil.java
index 43b1d00d..e2fd7325 100644
--- a/src/main/java/net/minecraft/server/BlockAnvil.java
+++ b/src/main/java/net/minecraft/server/BlockAnvil.java
@@ -71,7 +71,7 @@ public class BlockAnvil extends BlockFalling {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockAnvil.FACING, BlockAnvil.DAMAGE});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockBrewingStand.java b/src/main/java/net/minecraft/server/BlockBrewingStand.java
index 0bb2b502..8ca025c9 100644
--- a/src/main/java/net/minecraft/server/BlockBrewingStand.java
+++ b/src/main/java/net/minecraft/server/BlockBrewingStand.java
@@ -113,7 +113,7 @@ public class BlockBrewingStand extends BlockContainer {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockBrewingStand.HAS_BOTTLE[0], BlockBrewingStand.HAS_BOTTLE[1], BlockBrewingStand.HAS_BOTTLE[2]});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockButtonAbstract.java b/src/main/java/net/minecraft/server/BlockButtonAbstract.java
index 0cccb53c..3e95cc86 100644
--- a/src/main/java/net/minecraft/server/BlockButtonAbstract.java
+++ b/src/main/java/net/minecraft/server/BlockButtonAbstract.java
@@ -360,7 +360,7 @@ public abstract class BlockButtonAbstract extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockButtonAbstract.FACING, BlockButtonAbstract.POWERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockCactus.java b/src/main/java/net/minecraft/server/BlockCactus.java
index ddc21351..d133e51c 100644
--- a/src/main/java/net/minecraft/server/BlockCactus.java
+++ b/src/main/java/net/minecraft/server/BlockCactus.java
@@ -99,7 +99,7 @@ public class BlockCactus extends Block {
         return ((Integer) iblockdata.get(BlockCactus.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockCactus.AGE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockCake.java b/src/main/java/net/minecraft/server/BlockCake.java
index 11a7eaf1..cfb61670 100644
--- a/src/main/java/net/minecraft/server/BlockCake.java
+++ b/src/main/java/net/minecraft/server/BlockCake.java
@@ -109,7 +109,7 @@ public class BlockCake extends Block {
         return ((Integer) iblockdata.get(BlockCake.BITES)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockCake.BITES});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockChest.java b/src/main/java/net/minecraft/server/BlockChest.java
index eed516e2..fab53509 100644
--- a/src/main/java/net/minecraft/server/BlockChest.java
+++ b/src/main/java/net/minecraft/server/BlockChest.java
@@ -454,7 +454,7 @@ public class BlockChest extends BlockContainer {
         return ((EnumDirection) iblockdata.get(BlockChest.FACING)).a();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockChest.FACING});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockCocoa.java b/src/main/java/net/minecraft/server/BlockCocoa.java
index 8eb1beba..ade86228 100644
--- a/src/main/java/net/minecraft/server/BlockCocoa.java
+++ b/src/main/java/net/minecraft/server/BlockCocoa.java
@@ -148,7 +148,7 @@ public class BlockCocoa extends BlockDirectional implements IBlockFragilePlantEl
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockCocoa.FACING, BlockCocoa.AGE});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockCommand.java b/src/main/java/net/minecraft/server/BlockCommand.java
index 2630616f..9c614700 100644
--- a/src/main/java/net/minecraft/server/BlockCommand.java
+++ b/src/main/java/net/minecraft/server/BlockCommand.java
@@ -110,7 +110,7 @@ public class BlockCommand extends BlockContainer {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockCommand.TRIGGERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockCrops.java b/src/main/java/net/minecraft/server/BlockCrops.java
index b91b2200..1df4a286 100644
--- a/src/main/java/net/minecraft/server/BlockCrops.java
+++ b/src/main/java/net/minecraft/server/BlockCrops.java
@@ -153,7 +153,7 @@ public class BlockCrops extends BlockPlant implements IBlockFragilePlantElement
         return ((Integer) iblockdata.get(BlockCrops.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockCrops.AGE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockDaylightDetector.java b/src/main/java/net/minecraft/server/BlockDaylightDetector.java
index 45df7c9a..8bf86404 100644
--- a/src/main/java/net/minecraft/server/BlockDaylightDetector.java
+++ b/src/main/java/net/minecraft/server/BlockDaylightDetector.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 import java.util.Random;
 
 public class BlockDaylightDetector extends BlockContainer {
@@ -34,7 +36,7 @@ public class BlockDaylightDetector extends BlockContainer {
             float f1 = f < 3.1415927F ? 0.0F : 6.2831855F;
 
             f += (f1 - f) * 0.2F;
-            i = Math.round((float) i * MathHelper.cos(f));
+            i = (int) Math.round((float) i * MathHelper.cos(f));
             i = MathHelper.clamp(i, 0, 15);
             if (this.b) {
                 i = 15 - i;
@@ -100,7 +102,7 @@ public class BlockDaylightDetector extends BlockContainer {
         return ((Integer) iblockdata.get(BlockDaylightDetector.POWER)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockDaylightDetector.POWER});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockDispenser.java b/src/main/java/net/minecraft/server/BlockDispenser.java
index 010d7c6d..25ba4cd3 100644
--- a/src/main/java/net/minecraft/server/BlockDispenser.java
+++ b/src/main/java/net/minecraft/server/BlockDispenser.java
@@ -188,7 +188,7 @@ public class BlockDispenser extends BlockContainer {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockDispenser.FACING, BlockDispenser.TRIGGERED});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockDoor.java b/src/main/java/net/minecraft/server/BlockDoor.java
index bbaa2b5a..4f388df3 100644
--- a/src/main/java/net/minecraft/server/BlockDoor.java
+++ b/src/main/java/net/minecraft/server/BlockDoor.java
@@ -305,7 +305,7 @@ public class BlockDoor extends Block {
         return (i & 16) != 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockDoor.HALF, BlockDoor.FACING, BlockDoor.OPEN, BlockDoor.HINGE, BlockDoor.POWERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockFire.java b/src/main/java/net/minecraft/server/BlockFire.java
index 76cd5129..8d01e4ae 100644
--- a/src/main/java/net/minecraft/server/BlockFire.java
+++ b/src/main/java/net/minecraft/server/BlockFire.java
@@ -353,7 +353,7 @@ public class BlockFire extends Block {
         return ((Integer) iblockdata.get(BlockFire.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockFire.AGE, BlockFire.NORTH, BlockFire.EAST, BlockFire.SOUTH, BlockFire.WEST, BlockFire.UPPER, BlockFire.FLIP, BlockFire.ALT});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockFlowerPot.java b/src/main/java/net/minecraft/server/BlockFlowerPot.java
index ce461387..bfc285eb 100644
--- a/src/main/java/net/minecraft/server/BlockFlowerPot.java
+++ b/src/main/java/net/minecraft/server/BlockFlowerPot.java
@@ -191,7 +191,7 @@ public class BlockFlowerPot extends BlockContainer {
         return new TileEntityFlowerPot(Item.getItemOf((Block) object), j);
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockFlowerPot.CONTENTS, BlockFlowerPot.LEGACY_DATA});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockFlowing.java b/src/main/java/net/minecraft/server/BlockFlowing.java
index 23130ba9..0dc7e814 100644
--- a/src/main/java/net/minecraft/server/BlockFlowing.java
+++ b/src/main/java/net/minecraft/server/BlockFlowing.java
@@ -5,10 +5,9 @@ import java.util.Iterator;
 import java.util.Random;
 import java.util.Set;
 
-// CraftBukkit start
+import org.bukkit.Bukkit;
 import org.bukkit.block.BlockFace;
 import org.bukkit.event.block.BlockFromToEvent;
-// CraftBukkit end
 
 public class BlockFlowing extends BlockFluids {
 
@@ -23,19 +22,18 @@ public class BlockFlowing extends BlockFluids {
     }
 
     public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
-        // CraftBukkit start
         org.bukkit.World bworld = world.getWorld();
         org.bukkit.Server server = world.getServer();
         org.bukkit.block.Block source = bworld == null ? null : bworld.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
-        // CraftBukkit end
-        int i = ((Integer) iblockdata.get(BlockFlowing.LEVEL)).intValue();
+
+        int i = iblockdata.get(BlockFlowing.LEVEL);
         byte b0 = 1;
 
         if (this.material == Material.LAVA && !world.worldProvider.n()) {
             b0 = 2;
         }
 
-        int j = this.getFlowSpeed(world, blockposition); // PaperSpigot
+        int j = this.getFlowSpeed(world, blockposition);
         int k;
 
         if (i > 0) {
@@ -69,12 +67,12 @@ public class BlockFlowing extends BlockFluids {
 
                 if (iblockdata1.getBlock().getMaterial().isBuildable()) {
                     i1 = 0;
-                } else if (iblockdata1.getBlock().getMaterial() == this.material && ((Integer) iblockdata1.get(BlockFlowing.LEVEL)).intValue() == 0) {
+                } else if (iblockdata1.getBlock().getMaterial() == this.material && iblockdata1.get(BlockFlowing.LEVEL) == 0) {
                     i1 = 0;
                 }
             }
 
-            if (!world.paperSpigotConfig.fastDrainLava && this.material == Material.LAVA && i < 8 && i1 < 8 && i1 > i && random.nextInt(4) != 0) { // PaperSpigot
+            if (!world.paperSpigotConfig.fastDrainLava && this.material == Material.LAVA && i < 8 && i1 < 8 && i1 > i && random.nextInt(4) != 0) {
                 j *= 4;
             }
 
@@ -82,53 +80,53 @@ public class BlockFlowing extends BlockFluids {
                 this.f(world, blockposition, iblockdata);
             } else {
                 i = i1;
-                if (i1 < 0 || canFastDrain(world, blockposition)) { // PaperSpigot - Fast draining
+                if (i1 < 0 || canFastDrain(world, blockposition)) {
                     world.setAir(blockposition);
                 } else {
-                    iblockdata = iblockdata.set(BlockFlowing.LEVEL, Integer.valueOf(i1));
+                    iblockdata = iblockdata.set(BlockFlowing.LEVEL, i1);
                     world.setTypeAndData(blockposition, iblockdata, 2);
-                    world.a(blockposition, (Block) this, j);
-                    // PaperSpigot start - Optimize draining
+                    world.a(blockposition, this, j);
                     world.d(blockposition.west(), this);
                     world.d(blockposition.east(), this);
                     world.d(blockposition.up(), this);
                     world.d(blockposition.north(), this);
                     world.d(blockposition.south(), this);
-                    world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
-                    // PaperSpigot end
                 }
             }
         } else {
             this.f(world, blockposition, iblockdata);
         }
 
-        if (world.getType(blockposition).getBlock().getMaterial() != material) return; // PaperSpigot - Stop updating flowing block if material has changed
+        if (world.getType(blockposition).getBlock().getMaterial() != material) return;
         IBlockData iblockdata2 = world.getType(blockposition.down());
 
         if (this.h(world, blockposition.down(), iblockdata2)) {
-            // CraftBukkit start - Send "down" to the server
             BlockFromToEvent event = new BlockFromToEvent(source, BlockFace.DOWN);
+
             if (server != null) {
                 server.getPluginManager().callEvent(event);
             }
+
             if (!event.isCancelled()) {
-            if (this.material == Material.LAVA && world.getType(blockposition.down()).getBlock().getMaterial() == Material.WATER) {
-                world.setTypeUpdate(blockposition.down(), Blocks.STONE.getBlockData());
-                this.fizz(world, blockposition.down());
-                return;
-            }
+                if (this.material == Material.LAVA && world.getType(blockposition.down()).getBlock().getMaterial() == Material.WATER) {
+                    final org.bukkit.World bWorld = world.getWorld();
+                    final BlockPosition down = blockposition.down();
+                    Bukkit.getServer().getPluginManager().callEvent(new BlockFromToEvent(bWorld.getBlockAt(down.getX(), down.getY(), down.getZ()), bWorld.getBlockAt(down.getX(), down.getY(), down.getZ())));
+                    world.setTypeUpdate(blockposition.down(), Blocks.STONE.getBlockData());
+                    this.fizz(world, blockposition.down());
+                    return;
+                }
 
-            if (i >= 8) {
-                this.flow(world, blockposition.down(), iblockdata2, i);
-            } else {
-                this.flow(world, blockposition.down(), iblockdata2, i + 8);
-            }
+                if (i >= 8) {
+                    this.flow(world, blockposition.down(), iblockdata2, i);
+                } else {
+                    this.flow(world, blockposition.down(), iblockdata2, i + 8);
+                }
             }
-            // CraftBukkit end
         } else if (i >= 0 && (i == 0 || this.g(world, blockposition.down(), iblockdata2))) {
             Set set = this.f(world, blockposition);
-
             k = i + b0;
+
             if (i >= 8) {
                 k = 1;
             }
@@ -140,25 +138,23 @@ public class BlockFlowing extends BlockFluids {
             Iterator iterator1 = set.iterator();
 
             while (iterator1.hasNext()) {
-                EnumDirection enumdirection1 = (EnumDirection) iterator1.next();
+                EnumDirection direction = (EnumDirection) iterator1.next();
+                BlockFromToEvent event = new BlockFromToEvent(source, org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(direction));
 
-                // CraftBukkit start
-                BlockFromToEvent event = new BlockFromToEvent(source, org.bukkit.craftbukkit.block.CraftBlock.notchToBlockFace(enumdirection1));
                 if (server != null) {
                     server.getPluginManager().callEvent(event);
                 }
 
                 if (!event.isCancelled()) {
-                    this.flow(world, blockposition.shift(enumdirection1), world.getType(blockposition.shift(enumdirection1)), k);
+                    this.flow(world, blockposition.shift(direction), world.getType(blockposition.shift(direction)), k);
                 }
-                // CraftBukkit end
             }
         }
 
     }
 
     private void flow(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
-        if (world.isLoaded(blockposition) && this.h(world, blockposition, iblockdata)) { // CraftBukkit - add isLoaded check
+        if (world.isLoaded(blockposition) && this.h(world, blockposition, iblockdata)) {
             if (iblockdata.getBlock() != Blocks.AIR) {
                 if (this.material == Material.LAVA) {
                     this.fizz(world, blockposition);
@@ -167,7 +163,7 @@ public class BlockFlowing extends BlockFluids {
                 }
             }
 
-            world.setTypeAndData(blockposition, this.getBlockData().set(BlockFlowing.LEVEL, Integer.valueOf(i)), 3);
+            world.setTypeAndData(blockposition, this.getBlockData().set(BlockFlowing.LEVEL, i), 3);
         }
 
     }
@@ -177,19 +173,19 @@ public class BlockFlowing extends BlockFluids {
         Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
 
         while (iterator.hasNext()) {
-            EnumDirection enumdirection1 = (EnumDirection) iterator.next();
+            EnumDirection direction = (EnumDirection) iterator.next();
 
-            if (enumdirection1 != enumdirection) {
-                BlockPosition blockposition1 = blockposition.shift(enumdirection1);
-                IBlockData iblockdata = world.getType(blockposition1);
+            if (direction != enumdirection) {
+                BlockPosition position = blockposition.shift(direction);
+                IBlockData iblockdata = world.getType(position);
 
-                if (!this.g(world, blockposition1, iblockdata) && (iblockdata.getBlock().getMaterial() != this.material || ((Integer) iblockdata.get(BlockFlowing.LEVEL)).intValue() > 0)) {
-                    if (!this.g(world, blockposition1.down(), iblockdata)) {
+                if (!this.g(world, position, iblockdata) && (iblockdata.getBlock().getMaterial() != this.material || iblockdata.get(BlockFlowing.LEVEL) > 0)) {
+                    if (!this.g(world, position.down(), iblockdata)) {
                         return i;
                     }
 
                     if (i < 4) {
-                        int k = this.a(world, blockposition1, i + 1, enumdirection1.opposite());
+                        int k = this.a(world, position, i + 1, direction.opposite());
 
                         if (k < j) {
                             j = k;
@@ -204,35 +200,35 @@ public class BlockFlowing extends BlockFluids {
 
     private Set<EnumDirection> f(World world, BlockPosition blockposition) {
         int i = 1000;
-        EnumSet enumset = EnumSet.noneOf(EnumDirection.class);
+        EnumSet<EnumDirection> directions = EnumSet.noneOf(EnumDirection.class);
         Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
 
         while (iterator.hasNext()) {
-            EnumDirection enumdirection = (EnumDirection) iterator.next();
-            BlockPosition blockposition1 = blockposition.shift(enumdirection);
-            IBlockData iblockdata = world.getType(blockposition1);
+            EnumDirection enumDirection = (EnumDirection) iterator.next();
+            BlockPosition position = blockposition.shift(enumDirection);
+            IBlockData blockData = world.getType(position);
 
-            if (!this.g(world, blockposition1, iblockdata) && (iblockdata.getBlock().getMaterial() != this.material || ((Integer) iblockdata.get(BlockFlowing.LEVEL)).intValue() > 0)) {
+            if (!this.g(world, position, blockData) && (blockData.getBlock().getMaterial() != this.material || blockData.get(BlockFlowing.LEVEL) > 0)) {
                 int j;
 
-                if (this.g(world, blockposition1.down(), world.getType(blockposition1.down()))) {
-                    j = this.a(world, blockposition1, 1, enumdirection.opposite());
+                if (this.g(world, position.down(), world.getType(position.down()))) {
+                    j = this.a(world, position, 1, enumDirection.opposite());
                 } else {
                     j = 0;
                 }
 
                 if (j < i) {
-                    enumset.clear();
+                    directions.clear();
                 }
 
                 if (j <= i) {
-                    enumset.add(enumdirection);
+                    directions.add(enumDirection);
                     i = j;
                 }
             }
         }
 
-        return enumset;
+        return directions;
     }
 
     private boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
@@ -267,7 +263,7 @@ public class BlockFlowing extends BlockFluids {
 
     public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
         if (!this.e(world, blockposition, iblockdata)) {
-            world.a(blockposition, (Block) this, this.getFlowSpeed(world, blockposition)); // PaperSpigot
+            world.a(blockposition, this, this.getFlowSpeed(world, blockposition));
         }
 
     }
@@ -303,9 +299,11 @@ public class BlockFlowing extends BlockFluids {
     public boolean canFastDrain(World world, BlockPosition position) {
         boolean result = false;
         int data = getData(world, position);
+
         if (this.material == Material.WATER) {
             if (world.paperSpigotConfig.fastDrainWater) {
                 result = true;
+
                 if (getData(world, position.down()) < 0) {
                     result = false;
                 } else if (world.getType(position.north()).getBlock().getMaterial() == Material.WATER && getData(world, position.north()) < data) {
@@ -321,6 +319,7 @@ public class BlockFlowing extends BlockFluids {
         } else if (this.material == Material.LAVA) {
             if (world.paperSpigotConfig.fastDrainLava) {
                 result = true;
+
                 if (getData(world, position.down()) < 0 || world.getType(position.up()).getBlock().getMaterial() != Material.AIR) {
                     result = false;
                 } else if (world.getType(position.north()).getBlock().getMaterial() == Material.LAVA && getData(world, position.north()) < data) {
@@ -334,6 +333,8 @@ public class BlockFlowing extends BlockFluids {
                 }
             }
         }
+
         return result;
     }
+
 }
diff --git a/src/main/java/net/minecraft/server/BlockFluids.java b/src/main/java/net/minecraft/server/BlockFluids.java
index db73f5d9..1cb02686 100644
--- a/src/main/java/net/minecraft/server/BlockFluids.java
+++ b/src/main/java/net/minecraft/server/BlockFluids.java
@@ -1,5 +1,8 @@
 package net.minecraft.server;
 
+import org.bukkit.Bukkit;
+import org.bukkit.event.block.BlockFromToEvent;
+
 import java.util.Iterator;
 import java.util.Random;
 
@@ -148,13 +151,18 @@ public abstract class BlockFluids extends Block {
             if (flag) {
                 Integer integer = (Integer) iblockdata.get(BlockFluids.LEVEL);
 
+                final org.bukkit.World bWorld = world.getWorld();
+                final org.bukkit.block.Block block2 = bWorld.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+
                 if (integer.intValue() == 0) {
+                    Bukkit.getServer().getPluginManager().callEvent(new BlockFromToEvent(block2, block2));
                     world.setTypeUpdate(blockposition, Blocks.OBSIDIAN.getBlockData());
                     this.fizz(world, blockposition);
                     return true;
                 }
 
                 if (integer.intValue() > 0) { // PaperSpigot
+                    Bukkit.getServer().getPluginManager().callEvent(new BlockFromToEvent(block2, block2));
                     world.setTypeUpdate(blockposition, Blocks.COBBLESTONE.getBlockData());
                     this.fizz(world, blockposition);
                     return true;
@@ -186,7 +194,7 @@ public abstract class BlockFluids extends Block {
         return ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockFluids.LEVEL});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockGrass.java b/src/main/java/net/minecraft/server/BlockGrass.java
index 844ad30f..18278c0b 100644
--- a/src/main/java/net/minecraft/server/BlockGrass.java
+++ b/src/main/java/net/minecraft/server/BlockGrass.java
@@ -130,7 +130,7 @@ public class BlockGrass extends Block implements IBlockFragilePlantElement {
         return 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockGrass.SNOWY});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockHopper.java b/src/main/java/net/minecraft/server/BlockHopper.java
index 9f9b45db..26bc4767 100644
--- a/src/main/java/net/minecraft/server/BlockHopper.java
+++ b/src/main/java/net/minecraft/server/BlockHopper.java
@@ -155,7 +155,7 @@ public class BlockHopper extends BlockContainer {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockHopper.FACING, BlockHopper.ENABLED});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockJukeBox.java b/src/main/java/net/minecraft/server/BlockJukeBox.java
index b1bfb7eb..f22345c5 100644
--- a/src/main/java/net/minecraft/server/BlockJukeBox.java
+++ b/src/main/java/net/minecraft/server/BlockJukeBox.java
@@ -103,7 +103,7 @@ public class BlockJukeBox extends BlockContainer {
         return ((Boolean) iblockdata.get(BlockJukeBox.HAS_RECORD)).booleanValue() ? 1 : 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockJukeBox.HAS_RECORD});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockLever.java b/src/main/java/net/minecraft/server/BlockLever.java
index c9015eb9..cae1deb1 100644
--- a/src/main/java/net/minecraft/server/BlockLever.java
+++ b/src/main/java/net/minecraft/server/BlockLever.java
@@ -220,7 +220,7 @@ public class BlockLever extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockLever.FACING, BlockLever.POWERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockMinecartDetector.java b/src/main/java/net/minecraft/server/BlockMinecartDetector.java
index f3ce4a9c..cd9b990d 100644
--- a/src/main/java/net/minecraft/server/BlockMinecartDetector.java
+++ b/src/main/java/net/minecraft/server/BlockMinecartDetector.java
@@ -156,7 +156,7 @@ public class BlockMinecartDetector extends BlockMinecartTrackAbstract {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockMinecartDetector.SHAPE, BlockMinecartDetector.POWERED});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockMonsterEggs.java b/src/main/java/net/minecraft/server/BlockMonsterEggs.java
index 0b58e4ff..83938677 100644
--- a/src/main/java/net/minecraft/server/BlockMonsterEggs.java
+++ b/src/main/java/net/minecraft/server/BlockMonsterEggs.java
@@ -72,7 +72,7 @@ public class BlockMonsterEggs extends Block {
         return ((BlockMonsterEggs.EnumMonsterEggVarient) iblockdata.get(BlockMonsterEggs.VARIANT)).a();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockMonsterEggs.VARIANT});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockMycel.java b/src/main/java/net/minecraft/server/BlockMycel.java
index d2bd4dd9..36dbb83a 100644
--- a/src/main/java/net/minecraft/server/BlockMycel.java
+++ b/src/main/java/net/minecraft/server/BlockMycel.java
@@ -79,7 +79,7 @@ public class BlockMycel extends Block {
         return 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockMycel.SNOWY});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockNetherWart.java b/src/main/java/net/minecraft/server/BlockNetherWart.java
index 374f06ca..9569db45 100644
--- a/src/main/java/net/minecraft/server/BlockNetherWart.java
+++ b/src/main/java/net/minecraft/server/BlockNetherWart.java
@@ -70,7 +70,7 @@ public class BlockNetherWart extends BlockPlant {
         return ((Integer) iblockdata.get(BlockNetherWart.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockNetherWart.AGE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockPiston.java b/src/main/java/net/minecraft/server/BlockPiston.java
index b582f4bc..dba9b3b3 100644
--- a/src/main/java/net/minecraft/server/BlockPiston.java
+++ b/src/main/java/net/minecraft/server/BlockPiston.java
@@ -431,7 +431,7 @@ public class BlockPiston extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPiston.FACING, BlockPiston.EXTENDED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockPortal.java b/src/main/java/net/minecraft/server/BlockPortal.java
index 170f7763..288274f9 100644
--- a/src/main/java/net/minecraft/server/BlockPortal.java
+++ b/src/main/java/net/minecraft/server/BlockPortal.java
@@ -128,7 +128,7 @@ public class BlockPortal extends BlockHalfTransparent {
         return a((EnumDirection.EnumAxis) iblockdata.get(BlockPortal.AXIS));
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPortal.AXIS});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 0d0e0abb..7862bee8 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.AbstractIterator;
+
 import java.util.Iterator;
 
 public class BlockPosition extends BaseBlockPosition {
@@ -9,7 +10,7 @@ public class BlockPosition extends BaseBlockPosition {
     private static final int c = 1 + MathHelper.c(MathHelper.b(30000000));
     private static final int d = BlockPosition.c;
     private static final int e = 64 - BlockPosition.c - BlockPosition.d;
-    private static final int f = 0 + BlockPosition.d;
+    private static final int f = BlockPosition.d;
     private static final int g = BlockPosition.f + BlockPosition.e;
     private static final long h = (1L << BlockPosition.c) - 1L;
     private static final long i = (1L << BlockPosition.e) - 1L;
@@ -112,7 +113,7 @@ public class BlockPosition extends BaseBlockPosition {
     }
 
     public long asLong() {
-        return ((long) this.getX() & BlockPosition.h) << BlockPosition.g | ((long) this.getY() & BlockPosition.i) << BlockPosition.f | ((long) this.getZ() & BlockPosition.j) << 0;
+        return ((long) this.getX() & BlockPosition.h) << BlockPosition.g | ((long) this.getY() & BlockPosition.i) << BlockPosition.f | ((long) this.getZ() & BlockPosition.j);
     }
 
     public static BlockPosition fromLong(long i) {
@@ -123,10 +124,7 @@ public class BlockPosition extends BaseBlockPosition {
         return new BlockPosition(j, k, l);
     }
 
-    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
-        final BlockPosition blockposition2 = new BlockPosition(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()));
-        final BlockPosition blockposition3 = new BlockPosition(Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
-
+    public static Iterable<BlockPosition> a(BlockPosition firstPosition, BlockPosition secondPosition) {
         return new Iterable() {
             public Iterator<BlockPosition> iterator() {
                 return new AbstractIterator() {
@@ -134,23 +132,23 @@ public class BlockPosition extends BaseBlockPosition {
 
                     protected BlockPosition a() {
                         if (this.b == null) {
-                            this.b = blockposition;
+                            this.b = firstPosition;
                             return this.b;
-                        } else if (this.b.equals(blockposition1)) {
+                        } else if (this.b.equals(secondPosition)) {
                             return (BlockPosition) this.endOfData();
                         } else {
                             int i = this.b.getX();
                             int j = this.b.getY();
                             int k = this.b.getZ();
 
-                            if (i < blockposition1.getX()) {
+                            if (i < secondPosition.getX()) {
                                 ++i;
-                            } else if (j < blockposition1.getY()) {
-                                i = blockposition.getX();
+                            } else if (j < secondPosition.getY()) {
+                                i = firstPosition.getX();
                                 ++j;
-                            } else if (k < blockposition1.getZ()) {
-                                i = blockposition.getX();
-                                j = blockposition.getY();
+                            } else if (k < secondPosition.getZ()) {
+                                i = firstPosition.getX();
+                                j = firstPosition.getY();
                                 ++k;
                             }
 
@@ -168,9 +166,6 @@ public class BlockPosition extends BaseBlockPosition {
     }
 
     public static Iterable<BlockPosition.MutableBlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
-        final BlockPosition blockposition2 = new BlockPosition(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()));
-        final BlockPosition blockposition3 = new BlockPosition(Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
-
         return new Iterable() {
             public Iterator<BlockPosition.MutableBlockPosition> iterator() {
                 return new AbstractIterator() {
@@ -198,11 +193,10 @@ public class BlockPosition extends BaseBlockPosition {
                                 ++k;
                             }
 
-                            // PaperSpigot start
                             this.b.setX(i);
                             this.b.setY(j);
                             this.b.setZ(k);
-                            // PaperSpigot stop
+
                             return this.b;
                         }
                     }
@@ -221,15 +215,8 @@ public class BlockPosition extends BaseBlockPosition {
 
     public static final class MutableBlockPosition extends BlockPosition {
 
-        // PaperSpigot start - remove our overriding variables
-        /*
-        private int c;
-        private int d;
-        private int e;
-        */
-
         public void setX(int x) {
-            ((BaseBlockPosition) this).a = x;
+            (this).a = x;
         }
 
         public void setY(int y) {
@@ -239,7 +226,6 @@ public class BlockPosition extends BaseBlockPosition {
         public void setZ(int z) {
             ((BaseBlockPosition) this).d = z;
         }
-        // PaperSpigot end
 
         public MutableBlockPosition() {
             this(0, 0, 0);
@@ -247,31 +233,17 @@ public class BlockPosition extends BaseBlockPosition {
 
         public MutableBlockPosition(int i, int j, int k) {
             super(0, 0, 0);
-            // PaperSpigot start - modify base x,y,z
+
             this.setX(i);
             this.setY(j);
             this.setZ(k);
         }
 
-        /*
-        public int getX() {
-            return this.c;
-        }
-
-        public int getY() {
-            return this.d;
-        }
-
-        public int getZ() {
-            return this.e;
-        }
-        */
-
         public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
             setX(i);
             setY(j);
             setZ(k);
-            // PaperSpigot end
+
             return this;
         }
 
diff --git a/src/main/java/net/minecraft/server/BlockPoweredRail.java b/src/main/java/net/minecraft/server/BlockPoweredRail.java
index 43a400fe..6dd1e6e5 100644
--- a/src/main/java/net/minecraft/server/BlockPoweredRail.java
+++ b/src/main/java/net/minecraft/server/BlockPoweredRail.java
@@ -153,7 +153,7 @@ public class BlockPoweredRail extends BlockMinecartTrackAbstract {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPoweredRail.SHAPE, BlockPoweredRail.POWERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockPressurePlateBinary.java b/src/main/java/net/minecraft/server/BlockPressurePlateBinary.java
index ada3875a..770e0819 100644
--- a/src/main/java/net/minecraft/server/BlockPressurePlateBinary.java
+++ b/src/main/java/net/minecraft/server/BlockPressurePlateBinary.java
@@ -55,6 +55,7 @@ public class BlockPressurePlateBinary extends BlockPressurePlateAbstract {
 
                     if (entity instanceof EntityHuman) {
                         cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null, null);
+//                        cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null);
                     } else {
                         cancellable = new EntityInteractEvent(entity.getBukkitEntity(), bworld.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
                         manager.callEvent((EntityInteractEvent) cancellable);
@@ -84,7 +85,7 @@ public class BlockPressurePlateBinary extends BlockPressurePlateAbstract {
         return ((Boolean) iblockdata.get(BlockPressurePlateBinary.POWERED)).booleanValue() ? 1 : 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPressurePlateBinary.POWERED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockPressurePlateWeighted.java b/src/main/java/net/minecraft/server/BlockPressurePlateWeighted.java
index 5e96f9bd..70244468 100644
--- a/src/main/java/net/minecraft/server/BlockPressurePlateWeighted.java
+++ b/src/main/java/net/minecraft/server/BlockPressurePlateWeighted.java
@@ -30,6 +30,7 @@ public class BlockPressurePlateWeighted extends BlockPressurePlateAbstract {
 
             if (entity instanceof EntityHuman) {
                 cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null, null);
+//                cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null);
             } else {
                 cancellable = new EntityInteractEvent(entity.getBukkitEntity(), world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
                 world.getServer().getPluginManager().callEvent((EntityInteractEvent) cancellable);
@@ -73,7 +74,7 @@ public class BlockPressurePlateWeighted extends BlockPressurePlateAbstract {
         return ((Integer) iblockdata.get(BlockPressurePlateWeighted.POWER)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPressurePlateWeighted.POWER});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockPumpkin.java b/src/main/java/net/minecraft/server/BlockPumpkin.java
index 12958201..bce11456 100644
--- a/src/main/java/net/minecraft/server/BlockPumpkin.java
+++ b/src/main/java/net/minecraft/server/BlockPumpkin.java
@@ -129,7 +129,7 @@ public class BlockPumpkin extends BlockDirectional {
         return ((EnumDirection) iblockdata.get(BlockPumpkin.FACING)).b();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockPumpkin.FACING});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockRedstoneOre.java b/src/main/java/net/minecraft/server/BlockRedstoneOre.java
index 119354ad..bf8f3017 100644
--- a/src/main/java/net/minecraft/server/BlockRedstoneOre.java
+++ b/src/main/java/net/minecraft/server/BlockRedstoneOre.java
@@ -35,6 +35,7 @@ public class BlockRedstoneOre extends Block {
         // super.a(world, blockposition, entity);
         if (entity instanceof EntityHuman) {
             org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null, null);
+//            org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null);
             if (!event.isCancelled()) {
                 this.e(world, blockposition, entity); // add entity
                 super.a(world, blockposition, entity);
diff --git a/src/main/java/net/minecraft/server/BlockRedstoneWire.java b/src/main/java/net/minecraft/server/BlockRedstoneWire.java
index 532188e2..42c07d5e 100644
--- a/src/main/java/net/minecraft/server/BlockRedstoneWire.java
+++ b/src/main/java/net/minecraft/server/BlockRedstoneWire.java
@@ -372,7 +372,7 @@ public class BlockRedstoneWire extends Block {
         return ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockRedstoneWire.NORTH, BlockRedstoneWire.EAST, BlockRedstoneWire.SOUTH, BlockRedstoneWire.WEST, BlockRedstoneWire.POWER});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockReed.java b/src/main/java/net/minecraft/server/BlockReed.java
index 337f2c40..f151b22f 100644
--- a/src/main/java/net/minecraft/server/BlockReed.java
+++ b/src/main/java/net/minecraft/server/BlockReed.java
@@ -110,7 +110,7 @@ public class BlockReed extends Block {
         return ((Integer) iblockdata.get(BlockReed.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockReed.AGE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockSapling.java b/src/main/java/net/minecraft/server/BlockSapling.java
index 45fbf5c3..8ee6b734 100644
--- a/src/main/java/net/minecraft/server/BlockSapling.java
+++ b/src/main/java/net/minecraft/server/BlockSapling.java
@@ -225,7 +225,7 @@ public class BlockSapling extends BlockPlant implements IBlockFragilePlantElemen
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockSapling.TYPE, BlockSapling.STAGE});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockSkull.java b/src/main/java/net/minecraft/server/BlockSkull.java
index 95a10490..dcc8a61e 100644
--- a/src/main/java/net/minecraft/server/BlockSkull.java
+++ b/src/main/java/net/minecraft/server/BlockSkull.java
@@ -239,7 +239,7 @@ public class BlockSkull extends BlockContainer {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockSkull.FACING, BlockSkull.NODROP});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockSnow.java b/src/main/java/net/minecraft/server/BlockSnow.java
index 03b1a8bc..d45a4316 100644
--- a/src/main/java/net/minecraft/server/BlockSnow.java
+++ b/src/main/java/net/minecraft/server/BlockSnow.java
@@ -108,7 +108,7 @@ public class BlockSnow extends Block {
         return ((Integer) iblockdata.get(BlockSnow.LAYERS)).intValue() - 1;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockSnow.LAYERS});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockSoil.java b/src/main/java/net/minecraft/server/BlockSoil.java
index 362a346f..0d549b74 100644
--- a/src/main/java/net/minecraft/server/BlockSoil.java
+++ b/src/main/java/net/minecraft/server/BlockSoil.java
@@ -65,6 +65,7 @@ public class BlockSoil extends Block {
                 org.bukkit.event.Cancellable cancellable;
                 if (entity instanceof EntityHuman) {
                     cancellable = CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null, null);
+//                    cancellable = CraftEventFactory.callPlayerInteractEvent((EntityHuman) entity, org.bukkit.event.block.Action.PHYSICAL, blockposition, null);
                 } else {
                     cancellable = new EntityInteractEvent(entity.getBukkitEntity(), world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()));
                     world.getServer().getPluginManager().callEvent((EntityInteractEvent) cancellable);
@@ -128,7 +129,7 @@ public class BlockSoil extends Block {
         return ((Integer) iblockdata.get(BlockSoil.MOISTURE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockSoil.MOISTURE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockStem.java b/src/main/java/net/minecraft/server/BlockStem.java
index 2618c40f..f485416f 100644
--- a/src/main/java/net/minecraft/server/BlockStem.java
+++ b/src/main/java/net/minecraft/server/BlockStem.java
@@ -152,7 +152,7 @@ public class BlockStem extends BlockPlant implements IBlockFragilePlantElement {
         return ((Integer) iblockdata.get(BlockStem.AGE)).intValue();
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockStem.AGE, BlockStem.FACING});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockTNT.java b/src/main/java/net/minecraft/server/BlockTNT.java
index 3d1e583f..51501735 100644
--- a/src/main/java/net/minecraft/server/BlockTNT.java
+++ b/src/main/java/net/minecraft/server/BlockTNT.java
@@ -111,7 +111,7 @@ public class BlockTNT extends Block {
         return ((Boolean) iblockdata.get(BlockTNT.EXPLODE)).booleanValue() ? 1 : 0;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockTNT.EXPLODE});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockTrapdoor.java b/src/main/java/net/minecraft/server/BlockTrapdoor.java
index 1a2cdd1b..3622a8a5 100644
--- a/src/main/java/net/minecraft/server/BlockTrapdoor.java
+++ b/src/main/java/net/minecraft/server/BlockTrapdoor.java
@@ -205,7 +205,7 @@ public class BlockTrapdoor extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockTrapdoor.FACING, BlockTrapdoor.OPEN, BlockTrapdoor.HALF});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockTripwire.java b/src/main/java/net/minecraft/server/BlockTripwire.java
index bc61e17a..6605def8 100644
--- a/src/main/java/net/minecraft/server/BlockTripwire.java
+++ b/src/main/java/net/minecraft/server/BlockTripwire.java
@@ -171,6 +171,7 @@ public class BlockTripwire extends Block {
 
                     if (object instanceof EntityHuman) {
                         cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) object, org.bukkit.event.block.Action.PHYSICAL, blockposition, null, null);
+//                        cancellable = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent((EntityHuman) object, org.bukkit.event.block.Action.PHYSICAL, blockposition, null);
                     } else if (object instanceof Entity) {
                         cancellable = new EntityInteractEvent(((Entity) object).getBukkitEntity(), block);
                         manager.callEvent((EntityInteractEvent) cancellable);
@@ -248,7 +249,7 @@ public class BlockTripwire extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockTripwire.POWERED, BlockTripwire.SUSPENDED, BlockTripwire.ATTACHED, BlockTripwire.DISARMED, BlockTripwire.NORTH, BlockTripwire.EAST, BlockTripwire.WEST, BlockTripwire.SOUTH});
     }
 }
diff --git a/src/main/java/net/minecraft/server/BlockTripwireHook.java b/src/main/java/net/minecraft/server/BlockTripwireHook.java
index 0ad4a20f..fd099a76 100644
--- a/src/main/java/net/minecraft/server/BlockTripwireHook.java
+++ b/src/main/java/net/minecraft/server/BlockTripwireHook.java
@@ -278,7 +278,7 @@ public class BlockTripwireHook extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockTripwireHook.FACING, BlockTripwireHook.POWERED, BlockTripwireHook.ATTACHED, BlockTripwireHook.SUSPENDED});
     }
 
diff --git a/src/main/java/net/minecraft/server/BlockVine.java b/src/main/java/net/minecraft/server/BlockVine.java
index 25d19c4c..39fff232 100644
--- a/src/main/java/net/minecraft/server/BlockVine.java
+++ b/src/main/java/net/minecraft/server/BlockVine.java
@@ -359,7 +359,7 @@ public class BlockVine extends Block {
         return i;
     }
 
-    protected BlockStateList getStateList() {
+    public BlockStateList getStateList() {
         return new BlockStateList(this, new IBlockState[] { BlockVine.UP, BlockVine.NORTH, BlockVine.EAST, BlockVine.SOUTH, BlockVine.WEST});
     }
 
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index ab0d41ca..d5939b63 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -19,7 +19,6 @@ import org.apache.logging.log4j.Logger;
 import com.google.common.collect.Lists; // CraftBukkit
 import org.bukkit.Bukkit; // CraftBukkit
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.github.paperspigot.event.ServerExceptionEvent;
 import org.github.paperspigot.exception.ServerInternalException;
 
 public class Chunk {
@@ -722,7 +721,7 @@ public class Chunk {
         if (i != this.locX || j != this.locZ) {
             // CraftBukkit start
             Bukkit.getLogger().warning("Wrong location for " + entity + " in world '" + world.getWorld().getName() + "'!");
-            // Chunk.c.warn("Wrong location! (" + i + ", " + j + ") should be (" + this.locX + ", " + this.locZ + "), " + entity, new Object[] { entity});
+            // Chunk.setServerIp.warn("Wrong location! (" + i + ", " + j + ") should be (" + this.locX + ", " + this.locZ + "), " + entity, new Object[] { entity});
             Bukkit.getLogger().warning("Entity is at " + entity.locX + "," + entity.locZ + " (chunk " + i + "," + j + ") but was stored in chunk " + this.locX + "," + this.locZ);
             // CraftBukkit end
             entity.die();
@@ -984,7 +983,7 @@ public class Chunk {
                 Iterator iterator = this.entitySlices[k].iterator();
                 // PaperSpigot start - Don't search for inventories if we have none, and that is all we want
                 /*
-                 * We check if they want inventories by seeing if it is the static `IEntitySelector.c`
+                 * We check if they want inventories by seeing if it is the static `IEntitySelector.setServerIp`
                  *
                  * Make sure the inventory selector stays in sync.
                  * It should be the one that checks `var1 instanceof IInventory && var1.isAlive()`
@@ -1053,7 +1052,7 @@ public class Chunk {
             if (this.r && this.world.getTime() != this.lastSaved || this.q) {
                 return true;
             }
-        } else if (this.r && this.world.getTime() >= this.lastSaved + MinecraftServer.getServer().autosavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
+        } else if (this.r && this.world.getTime() >= this.lastSaved + MinecraftServer.getServer().autoSavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
             return true;
         }
 
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index c4dab42b..53f7501b 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -1,19 +1,16 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import org.potionspigot.PotionSpigot;
+
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
 
 import org.bukkit.Bukkit;
 import org.bukkit.Server;
@@ -22,6 +19,7 @@ import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.util.LongObjectHashMap;
 import org.bukkit.event.world.ChunkUnloadEvent;
+import org.bukkit.event.world.PreChunkLoadEvent;
 import org.github.paperspigot.event.ServerExceptionEvent;
 import org.github.paperspigot.exception.ServerInternalException;
 // CraftBukkit end
@@ -57,6 +55,9 @@ public class ChunkProviderServer implements IChunkProvider {
 
     public void queueUnload(int i, int j) {
         // PaperSpigot start - Asynchronous lighting updates
+        if (PotionSpigot.INSTANCE.getConfig().isDoChunkUnload()) {
+            return;
+        }
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
         if (chunk != null && chunk.world.paperSpigotConfig.useAsyncLighting && (chunk.pendingLightUpdates.get() > 0 || chunk.world.getTime() - chunk.lightUpdateTime < 20)) {
             return;
@@ -151,6 +152,20 @@ public class ChunkProviderServer implements IChunkProvider {
         boolean newChunk = false;
         // CraftBukkit end
 
+        Server server = world.getServer();
+        if (server != null) {
+                /*
+                 * If it's a new world, the first few chunks are generated inside
+                 * the World constructor. We can't reliably alter that, so we have
+                 * no way of creating a CraftWorld/CraftServer at that point.
+                 */
+            PreChunkLoadEvent event = new PreChunkLoadEvent();
+            server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return null;
+            }
+        }
+
         if (chunk == null) {
             world.timings.syncChunkLoadTimer.startTiming(); // Spigot
             chunk = this.loadChunk(i, j);
@@ -176,9 +191,8 @@ public class ChunkProviderServer implements IChunkProvider {
             this.chunks.put(LongHash.toLong(i, j), chunk);
             
             chunk.addEntities();
-            
+
             // CraftBukkit start
-            Server server = world.getServer();
             if (server != null) {
                 /*
                  * If it's a new world, the first few chunks are generated inside
diff --git a/src/main/java/net/minecraft/server/CommandGamemode.java b/src/main/java/net/minecraft/server/CommandGamemode.java
index abd23e7e..86993e98 100644
--- a/src/main/java/net/minecraft/server/CommandGamemode.java
+++ b/src/main/java/net/minecraft/server/CommandGamemode.java
@@ -20,7 +20,7 @@ public class CommandGamemode extends CommandAbstract {
 
     public void execute(ICommandListener icommandlistener, String[] astring) throws CommandException {
         if (astring.length <= 0) {
-            throw new ExceptionUsage("commands.gamemode.usage", new Object[0]);
+            throw new ExceptionUsage("commands.gamemode.usage");
         } else {
             WorldSettings.EnumGamemode worldsettings_enumgamemode = this.h(icommandlistener, astring[0]);
             EntityPlayer entityplayer = astring.length >= 2 ? a(icommandlistener, astring[1]) : b(icommandlistener);
@@ -35,26 +35,26 @@ public class CommandGamemode extends CommandAbstract {
 
             entityplayer.fallDistance = 0.0F;
             if (icommandlistener.getWorld().getGameRules().getBoolean("sendCommandFeedback")) {
-                entityplayer.sendMessage(new ChatMessage("gameMode.changed", new Object[0]));
+                entityplayer.sendMessage(new ChatMessage("gameMode.changed"));
             }
 
-            ChatMessage chatmessage = new ChatMessage("gameMode." + worldsettings_enumgamemode.b(), new Object[0]);
+            ChatMessage chatmessage = new ChatMessage("gameMode." + worldsettings_enumgamemode.b());
 
             if (entityplayer != icommandlistener) {
-                a(icommandlistener, this, 1, "commands.gamemode.success.other", new Object[] { entityplayer.getName(), chatmessage});
+                a(icommandlistener, this, 1, "commands.gamemode.success.other", entityplayer.getName(), chatmessage);
             } else {
-                a(icommandlistener, this, 1, "commands.gamemode.success.self", new Object[] { chatmessage});
+                a(icommandlistener, this, 1, "commands.gamemode.success.self", chatmessage);
             }
 
         }
     }
 
     protected WorldSettings.EnumGamemode h(ICommandListener icommandlistener, String s) throws ExceptionInvalidNumber {
-        return !s.equalsIgnoreCase(WorldSettings.EnumGamemode.SURVIVAL.b()) && !s.equalsIgnoreCase("s") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.CREATIVE.b()) && !s.equalsIgnoreCase("c") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.ADVENTURE.b()) && !s.equalsIgnoreCase("a") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.SPECTATOR.b()) && !s.equalsIgnoreCase("sp") ? WorldSettings.a(a(s, 0, WorldSettings.EnumGamemode.values().length - 2)) : WorldSettings.EnumGamemode.SPECTATOR) : WorldSettings.EnumGamemode.ADVENTURE) : WorldSettings.EnumGamemode.CREATIVE) : WorldSettings.EnumGamemode.SURVIVAL;
+        return !s.equalsIgnoreCase(WorldSettings.EnumGamemode.SURVIVAL.b()) && !s.equalsIgnoreCase("s") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.CREATIVE.b()) && !s.equalsIgnoreCase("setServerIp") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.ADVENTURE.b()) && !s.equalsIgnoreCase("a") ? (!s.equalsIgnoreCase(WorldSettings.EnumGamemode.SPECTATOR.b()) && !s.equalsIgnoreCase("sp") ? WorldSettings.a(a(s, 0, WorldSettings.EnumGamemode.values().length - 2)) : WorldSettings.EnumGamemode.SPECTATOR) : WorldSettings.EnumGamemode.ADVENTURE) : WorldSettings.EnumGamemode.CREATIVE) : WorldSettings.EnumGamemode.SURVIVAL;
     }
 
     public List<String> tabComplete(ICommandListener icommandlistener, String[] astring, BlockPosition blockposition) {
-        return astring.length == 1 ? a(astring, new String[] { "survival", "creative", "adventure", "spectator"}) : (astring.length == 2 ? a(astring, this.d()) : null);
+        return astring.length == 1 ? a(astring, "survival", "creative", "adventure", "spectator") : (astring.length == 2 ? a(astring, this.d()) : null);
     }
 
     protected String[] d() {
@@ -68,7 +68,7 @@ public class CommandGamemode extends CommandAbstract {
     // CraftBukkit start - fix decompiler error
     @Override
     public int compareTo(ICommand o) {
-        return a((ICommand) o);
+        return a(o);
     }
     // CraftBukkit end
 }
diff --git a/src/main/java/net/minecraft/server/CommandSpreadPlayers.java b/src/main/java/net/minecraft/server/CommandSpreadPlayers.java
index 53c5d92e..72166493 100644
--- a/src/main/java/net/minecraft/server/CommandSpreadPlayers.java
+++ b/src/main/java/net/minecraft/server/CommandSpreadPlayers.java
@@ -3,6 +3,8 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import net.jafama.FastMath;
+
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
diff --git a/src/main/java/net/minecraft/server/ContainerAnvil.java b/src/main/java/net/minecraft/server/ContainerAnvil.java
index 2816de67..49c23d26 100644
--- a/src/main/java/net/minecraft/server/ContainerAnvil.java
+++ b/src/main/java/net/minecraft/server/ContainerAnvil.java
@@ -1,396 +1,472 @@
 package net.minecraft.server;
 
+import org.potionspigot.event.inventory.PrepareAnvilRepairEvent;
+
 import java.util.Iterator;
 import java.util.Map;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
-import org.bukkit.craftbukkit.inventory.CraftInventoryView; // CraftBukkit
+import org.apache.commons.lang3.StringUtils;
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.inventory.CraftInventoryView;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
 
 public class ContainerAnvil extends Container {
 
-    private static final Logger f = LogManager.getLogger();
-    private IInventory g = new InventoryCraftResult();
-    private IInventory h = new InventorySubcontainer("Repair", true, 2) {
-        public void update() {
-            super.update();
-            ContainerAnvil.this.a((IInventory) this);
-        }
-    };
-    private World i;
-    private BlockPosition j;
-    public int a;
-    private int k;
-    private String l;
-    private final EntityHuman m;
-    // CraftBukkit start
-    private CraftInventoryView bukkitEntity = null;
-    private PlayerInventory player;
-    // CraftBukkit end
-
-    public ContainerAnvil(PlayerInventory playerinventory, final World world, final BlockPosition blockposition, EntityHuman entityhuman) {
-        this.player = playerinventory; // CraftBukkit
-        this.j = blockposition;
-        this.i = world;
-        this.m = entityhuman;
-        this.a(new Slot(this.h, 0, 27, 47));
-        this.a(new Slot(this.h, 1, 76, 47));
-        this.a(new Slot(this.g, 2, 134, 47) {
-            public boolean isAllowed(ItemStack itemstack) {
-                return false;
-            }
-
-            public boolean isAllowed(EntityHuman entityhuman) {
-                return (entityhuman.abilities.canInstantlyBuild || entityhuman.expLevel >= ContainerAnvil.this.a) && ContainerAnvil.this.a > 0 && this.hasItem();
-            }
-
-            public void a(EntityHuman entityhuman, ItemStack itemstack) {
-                if (!entityhuman.abilities.canInstantlyBuild) {
-                    entityhuman.levelDown(-ContainerAnvil.this.a);
-                }
-
-                ContainerAnvil.this.h.setItem(0, (ItemStack) null);
-                if (ContainerAnvil.this.k > 0) {
-                    ItemStack itemstack1 = ContainerAnvil.this.h.getItem(1);
-
-                    if (itemstack1 != null && itemstack1.count > ContainerAnvil.this.k) {
-                        itemstack1.count -= ContainerAnvil.this.k;
-                        ContainerAnvil.this.h.setItem(1, itemstack1);
-                    } else {
-                        ContainerAnvil.this.h.setItem(1, (ItemStack) null);
-                    }
-                } else {
-                    ContainerAnvil.this.h.setItem(1, (ItemStack) null);
-                }
-
-                ContainerAnvil.this.a = 0;
-                IBlockData iblockdata = world.getType(blockposition);
-
-                if (!entityhuman.abilities.canInstantlyBuild && !world.isClientSide && iblockdata.getBlock() == Blocks.ANVIL && entityhuman.bc().nextFloat() < 0.12F) {
-                    int i = ((Integer) iblockdata.get(BlockAnvil.DAMAGE)).intValue();
-
-                    ++i;
-                    if (i > 2) {
-                        world.setAir(blockposition);
-                        world.triggerEffect(1020, blockposition, 0);
-                    } else {
-                        world.setTypeAndData(blockposition, iblockdata.set(BlockAnvil.DAMAGE, Integer.valueOf(i)), 2);
-                        world.triggerEffect(1021, blockposition, 0);
-                    }
-                } else if (!world.isClientSide) {
-                    world.triggerEffect(1021, blockposition, 0);
-                }
-
-            }
-        });
-
-        int i;
-
-        for (i = 0; i < 3; ++i) {
-            for (int j = 0; j < 9; ++j) {
-                this.a(new Slot(playerinventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
-            }
-        }
-
-        for (i = 0; i < 9; ++i) {
-            this.a(new Slot(playerinventory, i, 8 + i * 18, 142));
-        }
-
-    }
-
-    public void a(IInventory iinventory) {
-        super.a(iinventory);
-        if (iinventory == this.h) {
-            this.e();
-        }
-
-    }
-
-    public void e() {
-        boolean flag = false;
-        boolean flag1 = true;
-        boolean flag2 = true;
-        boolean flag3 = true;
-        boolean flag4 = true;
-        boolean flag5 = true;
-        boolean flag6 = true;
-        ItemStack itemstack = this.h.getItem(0);
-
-        this.a = 1;
-        int i = 0;
-        byte b0 = 0;
-        byte b1 = 0;
-
-        if (itemstack == null) {
-            this.g.setItem(0, (ItemStack) null);
-            this.a = 0;
-        } else {
-            ItemStack itemstack1 = itemstack.cloneItemStack();
-            ItemStack itemstack2 = this.h.getItem(1);
-            Map map = EnchantmentManager.a(itemstack1);
-            boolean flag7 = false;
-            int j = b0 + itemstack.getRepairCost() + (itemstack2 == null ? 0 : itemstack2.getRepairCost());
-
-            this.k = 0;
-            int k;
-
-            if (itemstack2 != null) {
-                flag7 = itemstack2.getItem() == Items.ENCHANTED_BOOK && Items.ENCHANTED_BOOK.h(itemstack2).size() > 0;
-                int l;
-                int i1;
-
-                if (itemstack1.e() && itemstack1.getItem().a(itemstack, itemstack2)) {
-                    k = Math.min(itemstack1.h(), itemstack1.j() / 4);
-                    if (k <= 0) {
-                        this.g.setItem(0, (ItemStack) null);
-                        this.a = 0;
-                        return;
-                    }
-
-                    for (l = 0; k > 0 && l < itemstack2.count; ++l) {
-                        i1 = itemstack1.h() - k;
-                        itemstack1.setData(i1);
-                        ++i;
-                        k = Math.min(itemstack1.h(), itemstack1.j() / 4);
-                    }
-
-                    this.k = l;
-                } else {
-                    if (!flag7 && (itemstack1.getItem() != itemstack2.getItem() || !itemstack1.e())) {
-                        this.g.setItem(0, (ItemStack) null);
-                        this.a = 0;
-                        return;
-                    }
-
-                    int j1;
-
-                    if (itemstack1.e() && !flag7) {
-                        k = itemstack.j() - itemstack.h();
-                        l = itemstack2.j() - itemstack2.h();
-                        i1 = l + itemstack1.j() * 12 / 100;
-                        int k1 = k + i1;
-
-                        j1 = itemstack1.j() - k1;
-                        if (j1 < 0) {
-                            j1 = 0;
-                        }
-
-                        if (j1 < itemstack1.getData()) {
-                            itemstack1.setData(j1);
-                            i += 2;
-                        }
-                    }
-
-                    Map map1 = EnchantmentManager.a(itemstack2);
-                    Iterator iterator = map1.keySet().iterator();
-
-                    while (iterator.hasNext()) {
-                        i1 = ((Integer) iterator.next()).intValue();
-                        Enchantment enchantment = Enchantment.getById(i1);
-
-                        if (enchantment != null) {
-                            j1 = map.containsKey(Integer.valueOf(i1)) ? ((Integer) map.get(Integer.valueOf(i1))).intValue() : 0;
-                            int l1 = ((Integer) map1.get(Integer.valueOf(i1))).intValue();
-                            int i2;
-
-                            if (j1 == l1) {
-                                ++l1;
-                                i2 = l1;
-                            } else {
-                                i2 = Math.max(l1, j1);
-                            }
-
-                            l1 = i2;
-                            boolean flag8 = enchantment.canEnchant(itemstack);
-
-                            if (this.m.abilities.canInstantlyBuild || itemstack.getItem() == Items.ENCHANTED_BOOK) {
-                                flag8 = true;
-                            }
-
-                            Iterator iterator1 = map.keySet().iterator();
-
-                            while (iterator1.hasNext()) {
-                                int j2 = ((Integer) iterator1.next()).intValue();
-
-                                if (j2 != i1 && !enchantment.a(Enchantment.getById(j2))) {
-                                    flag8 = false;
-                                    ++i;
-                                }
-                            }
-
-                            if (flag8) {
-                                if (l1 > enchantment.getMaxLevel()) {
-                                    l1 = enchantment.getMaxLevel();
-                                }
-
-                                map.put(Integer.valueOf(i1), Integer.valueOf(l1));
-                                int k2 = 0;
-
-                                switch (enchantment.getRandomWeight()) {
-                                case 1:
-                                    k2 = 8;
-                                    break;
-
-                                case 2:
-                                    k2 = 4;
-
-                                case 3:
-                                case 4:
-                                case 6:
-                                case 7:
-                                case 8:
-                                case 9:
-                                default:
-                                    break;
-
-                                case 5:
-                                    k2 = 2;
-                                    break;
-
-                                case 10:
-                                    k2 = 1;
-                                }
-
-                                if (flag7) {
-                                    k2 = Math.max(1, k2 / 2);
-                                }
-
-                                i += k2 * l1;
-                            }
-                        }
-                    }
-                }
-            }
-
-            if (StringUtils.isBlank(this.l)) {
-                if (itemstack.hasName()) {
-                    b1 = 1;
-                    i += b1;
-                    itemstack1.r();
-                }
-            } else if (!this.l.equals(itemstack.getName())) {
-                b1 = 1;
-                i += b1;
-                itemstack1.c(this.l);
-            }
-
-            this.a = j + i;
-            if (i <= 0) {
-                itemstack1 = null;
-            }
-
-            if (b1 == i && b1 > 0 && this.a >= 40) {
-                this.a = 39;
-            }
-
-            if (this.a >= 40 && !this.m.abilities.canInstantlyBuild) {
-                itemstack1 = null;
-            }
-
-            if (itemstack1 != null) {
-                k = itemstack1.getRepairCost();
-                if (itemstack2 != null && k < itemstack2.getRepairCost()) {
-                    k = itemstack2.getRepairCost();
-                }
-
-                k = k * 2 + 1;
-                itemstack1.setRepairCost(k);
-                EnchantmentManager.a(map, itemstack1);
-            }
-
-            this.g.setItem(0, itemstack1);
-            this.b();
-        }
-    }
-
-    public void addSlotListener(ICrafting icrafting) {
-        super.addSlotListener(icrafting);
-        icrafting.setContainerData(this, 0, this.a);
-    }
-
-    public void b(EntityHuman entityhuman) {
-        super.b(entityhuman);
-        if (!this.i.isClientSide) {
-            for (int i = 0; i < this.h.getSize(); ++i) {
-                ItemStack itemstack = this.h.splitWithoutUpdate(i);
-
-                if (itemstack != null) {
-                    entityhuman.drop(itemstack, false);
-                }
-            }
-
-        }
-    }
-
-    public boolean a(EntityHuman entityhuman) {
-        if (!this.checkReachable) return true; // CraftBukkit
-        return this.i.getType(this.j).getBlock() != Blocks.ANVIL ? false : entityhuman.e((double) this.j.getX() + 0.5D, (double) this.j.getY() + 0.5D, (double) this.j.getZ() + 0.5D) <= 64.0D;
-    }
-
-    public ItemStack b(EntityHuman entityhuman, int i) {
-        ItemStack itemstack = null;
-        Slot slot = (Slot) this.c.get(i);
-
-        if (slot != null && slot.hasItem()) {
-            ItemStack itemstack1 = slot.getItem();
-
-            itemstack = itemstack1.cloneItemStack();
-            if (i == 2) {
-                if (!this.a(itemstack1, 3, 39, true)) {
-                    return null;
-                }
-
-                slot.a(itemstack1, itemstack);
-            } else if (i != 0 && i != 1) {
-                if (i >= 3 && i < 39 && !this.a(itemstack1, 0, 2, false)) {
-                    return null;
-                }
-            } else if (!this.a(itemstack1, 3, 39, false)) {
-                return null;
-            }
-
-            if (itemstack1.count == 0) {
-                slot.set((ItemStack) null);
-            } else {
-                slot.f();
-            }
-
-            if (itemstack1.count == itemstack.count) {
-                return null;
-            }
-
-            slot.a(entityhuman, itemstack1);
-        }
-
-        return itemstack;
-    }
-
-    public void a(String s) {
-        this.l = s;
-        if (this.getSlot(2).hasItem()) {
-            ItemStack itemstack = this.getSlot(2).getItem();
-
-            if (StringUtils.isBlank(s)) {
-                itemstack.r();
-            } else {
-                itemstack.c(this.l);
-            }
-        }
-
-        this.e();
-    }
-
-    // CraftBukkit start
-    @Override
-    public CraftInventoryView getBukkitView() {
-        if (bukkitEntity != null) {
-            return bukkitEntity;
-        }
-
-        org.bukkit.craftbukkit.inventory.CraftInventory inventory = new org.bukkit.craftbukkit.inventory.CraftInventoryAnvil(this.h, this.g);
-        bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), inventory, this);
-        return bukkitEntity;
-    }
-    // CraftBukkit end
+	private final EntityHuman k;
+	public int a;
+	private IInventory g = new InventoryCraftResult();
+	private World i;
+	private BlockPosition j;
+	private int m;
+	private String l;
+	private CraftInventoryView bukkitEntity = null;
+	private PlayerInventory player;
+	private IInventory h = new InventorySubcontainer("Repair", true, 2) {
+		public void update() {
+			super.update();
+			ContainerAnvil.this.a(this);
+		}
+	};
+
+	public ContainerAnvil(PlayerInventory playerinventory, final World world, final BlockPosition blockposition, EntityHuman entityhuman) {
+		this.player = playerinventory;
+		this.j = blockposition;
+		this.i = world;
+		this.k = entityhuman;
+		this.a(new Slot(this.h, 0, 27, 47));
+		this.a(new Slot(this.h, 1, 76, 47));
+		this.a(new Slot(this.g, 2, 134, 47) {
+			public boolean isAllowed(ItemStack itemstack) {
+				return false;
+			}
+
+			public boolean isAllowed(EntityHuman entityhuman) {
+				return (entityhuman.abilities.canInstantlyBuild || entityhuman.expLevel >= ContainerAnvil.this.a) &&
+				       ContainerAnvil.this.a > 0 && this.hasItem();
+			}
+
+			public void a(EntityHuman entityhuman, ItemStack itemstack) {
+				if (!entityhuman.abilities.canInstantlyBuild) {
+					entityhuman.levelDown(-ContainerAnvil.this.a);
+				}
+
+				ContainerAnvil.this.h.setItem(0, null);
+				if (ContainerAnvil.this.m > 0) {
+					ItemStack itemstack1 = ContainerAnvil.this.h.getItem(1);
+
+					if (itemstack1 != null && itemstack1.count > ContainerAnvil.this.m) {
+						itemstack1.count -= ContainerAnvil.this.m;
+						ContainerAnvil.this.h.setItem(1, itemstack1);
+					} else {
+						ContainerAnvil.this.h.setItem(1, null);
+					}
+				} else {
+					ContainerAnvil.this.h.setItem(1, null);
+				}
+
+				ContainerAnvil.this.a = 0;
+				IBlockData iblockdata = world.getType(blockposition);
+
+				if (!entityhuman.abilities.canInstantlyBuild && !world.isClientSide &&
+				    iblockdata.getBlock() == Blocks.ANVIL && entityhuman.bc().nextFloat() < 0.12F) {
+					int i = iblockdata.get(BlockAnvil.DAMAGE);
+
+					++i;
+
+					if (i > 2) {
+						world.setAir(blockposition);
+						world.triggerEffect(1020, blockposition, 0);
+					} else {
+						world.setTypeAndData(blockposition, iblockdata.set(BlockAnvil.DAMAGE, i), 2);
+						world.triggerEffect(1021, blockposition, 0);
+					}
+				} else if (!world.isClientSide) {
+					world.triggerEffect(1021, blockposition, 0);
+				}
+			}
+		});
+
+		int i;
+
+		for (i = 0; i < 3; ++i) {
+			for (int j = 0; j < 9; ++j) {
+				this.a(new Slot(playerinventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
+			}
+		}
+
+		for (i = 0; i < 9; ++i) {
+			this.a(new Slot(playerinventory, i, 8 + i * 18, 142));
+		}
+
+	}
+
+	public void a(IInventory iinventory) {
+		super.a(iinventory);
+		if (iinventory == this.h) {
+			this.e();
+		}
+
+	}
+
+	public void e() {
+		ItemStack itemstack = this.h.getItem(0);
+
+		this.a = 0;
+		int i = 0;
+		byte b0 = 0;
+		int j = 0;
+
+		if (itemstack == null) {
+			this.g.setItem(0, null);
+			this.a = 0;
+		} else {
+			ItemStack clonedItemStack = itemstack.cloneItemStack();
+			ItemStack nextItemStack = this.h.getItem(1);
+			Map map = EnchantmentManager.a(clonedItemStack);
+			boolean flag = false;
+			int k = b0 + itemstack.getRepairCost() + (nextItemStack == null ? 0 : nextItemStack.getRepairCost());
+
+			this.m = 0;
+			int l;
+			int i1;
+			int j1;
+			int k1;
+			int l1;
+			Iterator iterator;
+			Enchantment enchantment;
+
+			if (nextItemStack != null) {
+				flag = nextItemStack.getItem() == Items.ENCHANTED_BOOK && Items.ENCHANTED_BOOK.h(nextItemStack).size() > 0;
+
+				if (clonedItemStack.e() && clonedItemStack.getItem().a(itemstack, nextItemStack)) {
+					l = Math.min(clonedItemStack.h(), clonedItemStack.j() / 4);
+
+					if (l <= 0) {
+						this.g.setItem(0, null);
+						this.a = 0;
+						return;
+					}
+
+					for (i1 = 0; l > 0 && i1 < nextItemStack.count; ++i1) {
+						j1 = clonedItemStack.h() - l;
+						clonedItemStack.setData(j1);
+						i += Math.max(1, l / 100) + map.size();
+						l = Math.min(clonedItemStack.h(), clonedItemStack.j() / 4);
+					}
+
+					this.m = i1;
+				} else {
+					if (!flag && (clonedItemStack.getItem() != nextItemStack.getItem() || !clonedItemStack.e())) {
+						this.g.setItem(0, null);
+						this.a = 0;
+						return;
+					}
+
+					if (clonedItemStack.e() && !flag) {
+						l = itemstack.j() - itemstack.h();
+						i1 = nextItemStack.j() - nextItemStack.h();
+						j1 = i1 + clonedItemStack.j() * 12 / 100;
+						int i2 = l + j1;
+
+						k1 = clonedItemStack.j() - i2;
+
+						if (k1 < 0) {
+							k1 = 0;
+						}
+
+						if (k1 < clonedItemStack.getData()) {
+							clonedItemStack.setData(k1);
+							i += Math.max(1, j1 / 100);
+						}
+					}
+
+					Map map1 = EnchantmentManager.a(nextItemStack);
+
+					iterator = map1.keySet().iterator();
+
+					while (iterator.hasNext()) {
+						j1 = (Integer) iterator.next();
+						enchantment = Enchantment.getById(j1);
+						k1 = map.containsKey(j1) ? (Integer) map.get(j1) : 0;
+						l1 = (Integer) map1.get(j1);
+
+						int j2;
+
+						if (k1 == l1) {
+							++l1;
+							j2 = l1;
+						} else {
+							j2 = Math.max(l1, k1);
+						}
+
+						l1 = j2;
+						int k2 = l1 - k1;
+						boolean flag1 = enchantment.canEnchant(itemstack);
+
+						if (this.k.abilities.canInstantlyBuild || itemstack.getItem() == Items.ENCHANTED_BOOK) {
+							flag1 = true;
+						}
+
+						Iterator iterator1 = map.keySet().iterator();
+
+						while (iterator1.hasNext()) {
+							int l2 = ((Integer) iterator1.next()).intValue();
+
+							if (l2 != j1 && !enchantment.a(Enchantment.getById(l2))) {
+								flag1 = false;
+								i += k2;
+							}
+						}
+
+						if (flag1) {
+							if (l1 > enchantment.getMaxLevel()) {
+								l1 = enchantment.getMaxLevel();
+							}
+
+							map.put(Integer.valueOf(j1), Integer.valueOf(l1));
+							int i3 = 0;
+
+							switch (enchantment.getRandomWeight()) {
+								case 1:
+									i3 = 8;
+									break;
+
+								case 2:
+									i3 = 4;
+
+								case 3:
+								case 4:
+								case 6:
+								case 7:
+								case 8:
+								case 9:
+								default:
+									break;
+
+								case 5:
+									i3 = 2;
+									break;
+
+								case 10:
+									i3 = 1;
+							}
+
+							if (flag) {
+								i3 = Math.max(1, i3 / 2);
+							}
+
+							i += i3 * k2;
+						}
+					}
+				}
+			}
+
+			if (StringUtils.isBlank(this.l)) {
+				if (itemstack.hasName()) {
+					j = itemstack.g() ? 7 : itemstack.count * 5;
+					i += j;
+					clonedItemStack.r();
+				}
+			} else if (!this.l.equals(itemstack.getName())) {
+				j = itemstack.g() ? 7 : itemstack.count * 5;
+				i += j;
+				if (itemstack.hasName()) {
+					k += j / 2;
+				}
+
+				clonedItemStack.c(this.l);
+			}
+
+			l = 0;
+
+			for (iterator = map.keySet().iterator(); iterator.hasNext(); k += l + k1 * l1) {
+				j1 = (Integer) iterator.next();
+				enchantment = Enchantment.getById(j1);
+				k1 = (Integer) map.get(j1);
+				l1 = 0;
+
+				++l;
+
+				switch (enchantment.getRandomWeight()) {
+					case 1:
+						l1 = 8;
+						break;
+
+					case 2:
+						l1 = 4;
+
+					case 3:
+					case 4:
+					case 6:
+					case 7:
+					case 8:
+					case 9:
+					default:
+						break;
+
+					case 5:
+						l1 = 2;
+						break;
+
+					case 10:
+						l1 = 1;
+				}
+
+				if (flag) {
+					l1 = Math.max(1, l1 / 2);
+				}
+			}
+
+			if (flag) {
+				k = Math.max(1, k / 2);
+			}
+
+			this.a = k + i;
+			if (i <= 0) {
+				clonedItemStack = null;
+			}
+
+			if (j == i && j > 0 && this.a >= 40) {
+				this.a = 39;
+			}
+
+			if (this.a >= 40 && !this.k.abilities.canInstantlyBuild) {
+				clonedItemStack = null;
+			}
+
+			if (clonedItemStack != null) {
+				i1 = clonedItemStack.getRepairCost();
+				if (nextItemStack != null && i1 < nextItemStack.getRepairCost()) {
+					i1 = nextItemStack.getRepairCost();
+				}
+
+				if (clonedItemStack.hasName()) {
+					i1 -= 9;
+				}
+
+				if (i1 < 0) {
+					i1 = 0;
+				}
+
+				i1 += 2;
+				clonedItemStack.setRepairCost(i1);
+				EnchantmentManager.a(map, clonedItemStack);
+
+				if (clonedItemStack != null) {
+					PrepareAnvilRepairEvent prepareAnvilRepairEvent = new PrepareAnvilRepairEvent(this.k
+							.getBukkitEntity(), this.getBukkitView(), this.k.world.getWorld().getBlockAt(this.j.getX
+							(), this.j.getY(), this.j.getZ()), CraftItemStack.asBukkitCopy(itemstack), CraftItemStack
+							.asBukkitCopy(nextItemStack), CraftItemStack.asBukkitCopy(clonedItemStack));
+					Bukkit.getPluginManager().callEvent(prepareAnvilRepairEvent);
+
+					if (prepareAnvilRepairEvent.isCancelled() ||
+					    prepareAnvilRepairEvent.getResult().getType() == Material.AIR) {
+						return;
+					}
+
+					clonedItemStack = CraftItemStack.asNMSCopy(prepareAnvilRepairEvent.getResult());
+
+				}
+			}
+
+			this.g.setItem(0, clonedItemStack);
+			this.b();
+		}
+	}
+
+	public void addSlotListener(ICrafting icrafting) {
+		super.addSlotListener(icrafting);
+		icrafting.setContainerData(this, 0, this.a);
+	}
+
+	public void b(EntityHuman entityhuman) {
+		super.b(entityhuman);
+
+		if (!this.i.isClientSide) {
+			for (int i = 0; i < this.h.getSize(); ++i) {
+				ItemStack itemstack = this.h.splitWithoutUpdate(i);
+
+				if (itemstack != null) {
+					entityhuman.drop(itemstack, false);
+				}
+			}
+		}
+	}
+
+	public boolean a(EntityHuman entityhuman) {
+		if (!this.checkReachable) {
+			return true;
+		}
+
+		return this.i.getType(this.j).getBlock() != Blocks.ANVIL ? false : entityhuman.e((double) this.j.getX() + 0.5D,
+				(double) this.j.getY() + 0.5D, (double) this.j.getZ() + 0.5D) <= 64.0D;
+	}
+
+	public ItemStack b(EntityHuman entityhuman, int i) {
+		ItemStack itemstack = null;
+		Slot slot = this.c.get(i);
+
+		if (slot != null && slot.hasItem()) {
+			ItemStack itemstack1 = slot.getItem();
+			itemstack = itemstack1.cloneItemStack();
+
+			if (i == 2) {
+				if (!this.a(itemstack1, 3, 39, true)) {
+					return null;
+				}
+
+				slot.a(itemstack1, itemstack);
+			} else if (i != 0 && i != 1) {
+				if (i >= 3 && i < 39 && !this.a(itemstack1, 0, 2, false)) {
+					return null;
+				}
+			} else if (!this.a(itemstack1, 3, 39, false)) {
+				return null;
+			}
+
+			if (itemstack1.count == 0) {
+				slot.set(null);
+			} else {
+				slot.f();
+			}
+
+			if (itemstack1.count == itemstack.count) {
+				return null;
+			}
+
+			slot.a(entityhuman, itemstack1);
+		}
+
+		return itemstack;
+	}
+
+	public void a(String s) {
+		this.l = s;
+		if (this.getSlot(2).hasItem()) {
+			ItemStack itemstack = this.getSlot(2).getItem();
+
+			if (StringUtils.isBlank(s)) {
+				itemstack.r();
+			} else {
+				itemstack.c(this.l);
+			}
+		}
+
+		this.e();
+	}
+
+	@Override
+	public CraftInventoryView getBukkitView() {
+		if (bukkitEntity != null) {
+			return bukkitEntity;
+		}
+
+		org.bukkit.craftbukkit.inventory.CraftInventory inventory = new org.bukkit.craftbukkit.inventory.CraftInventoryAnvil(this.h, this.g);
+
+		bukkitEntity = new CraftInventoryView(this.player.player.getBukkitEntity(), inventory, this);
+
+		return bukkitEntity;
+	}
+
 }
diff --git a/src/main/java/net/minecraft/server/ContainerEnchantTable.java b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
index 5c473bef..a55d9211 100644
--- a/src/main/java/net/minecraft/server/ContainerEnchantTable.java
+++ b/src/main/java/net/minecraft/server/ContainerEnchantTable.java
@@ -1,376 +1,405 @@
 package net.minecraft.server;
 
 import java.util.List;
-import java.util.Random;
-
-// CraftBukkit start
 import java.util.Map;
-
+import java.util.Random;
+import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.inventory.CraftInventoryEnchanting;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Player;
 import org.bukkit.event.enchantment.EnchantItemEvent;
 import org.bukkit.event.enchantment.PrepareItemEnchantEvent;
-import org.bukkit.entity.Player;
+
+// CraftBukkit start
 // CraftBukkit end
 
 public class ContainerEnchantTable extends Container {
 
-    // CraftBukkit - make type specific (changed from IInventory)
-    public InventorySubcontainer enchantSlots = new InventorySubcontainer("Enchant", true, 2) {
-        public int getMaxStackSize() {
-            return 64;
-        }
-
-        public void update() {
-            super.update();
-            ContainerEnchantTable.this.a((IInventory) this);
-        }
-    };
-    private World world;
-    private BlockPosition position;
-    private Random k = new Random();
-    public int f;
-    public int[] costs = new int[3];
-    public int[] h = new int[] { -1, -1, -1};
-    // CraftBukkit start
-    private CraftInventoryView bukkitEntity = null;
-    private Player player;
-    // CraftBukkit end
-
-    public ContainerEnchantTable(PlayerInventory playerinventory, World world, BlockPosition blockposition) {
-        this.world = world;
-        this.position = blockposition;
-        this.f = playerinventory.player.cj();
-        this.a(new Slot(this.enchantSlots, 0, 15, 47) {
-            public boolean isAllowed(ItemStack itemstack) {
-                return true;
-            }
-
-            public int getMaxStackSize() {
-                return 1;
-            }
-        });
-        this.a(new Slot(this.enchantSlots, 1, 35, 47) {
-            public boolean isAllowed(ItemStack itemstack) {
-                return itemstack.getItem() == Items.DYE && EnumColor.fromInvColorIndex(itemstack.getData()) == EnumColor.BLUE;
-            }
-        });
-
-        int i;
-
-        for (i = 0; i < 3; ++i) {
-            for (int j = 0; j < 9; ++j) {
-                this.a(new Slot(playerinventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
-            }
-        }
-
-        for (i = 0; i < 9; ++i) {
-            this.a(new Slot(playerinventory, i, 8 + i * 18, 142));
-        }
-
-        // CraftBukkit start
-        player = (Player) playerinventory.player.getBukkitEntity();
-        // CraftBukkit end
-    }
-
-    public void addSlotListener(ICrafting icrafting) {
-        super.addSlotListener(icrafting);
-        icrafting.setContainerData(this, 0, this.costs[0]);
-        icrafting.setContainerData(this, 1, this.costs[1]);
-        icrafting.setContainerData(this, 2, this.costs[2]);
-        icrafting.setContainerData(this, 3, this.f & -16);
-        icrafting.setContainerData(this, 4, this.h[0]);
-        icrafting.setContainerData(this, 5, this.h[1]);
-        icrafting.setContainerData(this, 6, this.h[2]);
-    }
-
-    public void b() {
-        super.b();
-
-        for (int i = 0; i < this.listeners.size(); ++i) {
-            ICrafting icrafting = (ICrafting) this.listeners.get(i);
-
-            icrafting.setContainerData(this, 0, this.costs[0]);
-            icrafting.setContainerData(this, 1, this.costs[1]);
-            icrafting.setContainerData(this, 2, this.costs[2]);
-            icrafting.setContainerData(this, 3, this.f & -16);
-            icrafting.setContainerData(this, 4, this.h[0]);
-            icrafting.setContainerData(this, 5, this.h[1]);
-            icrafting.setContainerData(this, 6, this.h[2]);
-        }
-
-    }
-
-    public void a(IInventory iinventory) {
-        if (iinventory == this.enchantSlots) {
-            ItemStack itemstack = iinventory.getItem(0);
-            int i;
-
-            if (itemstack != null) { // CraftBukkit - relax condition
-                if (!this.world.isClientSide) {
-                    i = 0;
-
-                    int j;
-
-                    for (j = -1; j <= 1; ++j) {
-                        for (int k = -1; k <= 1; ++k) {
-                            if ((j != 0 || k != 0) && this.world.isEmpty(this.position.a(k, 0, j)) && this.world.isEmpty(this.position.a(k, 1, j))) {
-                                if (this.world.getType(this.position.a(k * 2, 0, j * 2)).getBlock() == Blocks.BOOKSHELF) {
-                                    ++i;
-                                }
-
-                                if (this.world.getType(this.position.a(k * 2, 1, j * 2)).getBlock() == Blocks.BOOKSHELF) {
-                                    ++i;
-                                }
-
-                                if (k != 0 && j != 0) {
-                                    if (this.world.getType(this.position.a(k * 2, 0, j)).getBlock() == Blocks.BOOKSHELF) {
-                                        ++i;
-                                    }
-
-                                    if (this.world.getType(this.position.a(k * 2, 1, j)).getBlock() == Blocks.BOOKSHELF) {
-                                        ++i;
-                                    }
-
-                                    if (this.world.getType(this.position.a(k, 0, j * 2)).getBlock() == Blocks.BOOKSHELF) {
-                                        ++i;
-                                    }
-
-                                    if (this.world.getType(this.position.a(k, 1, j * 2)).getBlock() == Blocks.BOOKSHELF) {
-                                        ++i;
-                                    }
-                                }
-                            }
-                        }
-                    }
-
-                    this.k.setSeed((long) this.f);
-
-                    for (j = 0; j < 3; ++j) {
-                        this.costs[j] = EnchantmentManager.a(this.k, j, i, itemstack);
-                        this.h[j] = -1;
+	private Random RANDOM = new Random();
+	public int f;
+	public int[] costs = new int[3];
+	public int[] h = new int[]{ -1, -1, -1 };
+	private World world;
+	private BlockPosition position;
+	// CraftBukkit start
+	private CraftInventoryView bukkitEntity = null;
+	private Player player;
+	// CraftBukkit - make type specific (changed from IInventory)
+	public InventorySubcontainer enchantSlots = new InventorySubcontainer("Enchant", true, 2) {
+		public int getMaxStackSize() {
+			return 64;
+		}
+
+		public void update() {
+			super.update();
+			ContainerEnchantTable.this.update(this);
+		}
+	};
+	// CraftBukkit end
+
+	public ContainerEnchantTable(PlayerInventory playerinventory, World world, BlockPosition blockposition) {
+		this.world = world;
+		this.position = blockposition;
+		this.a(new Slot(this.enchantSlots, 0, 15, 47) {
+			public boolean isAllowed(ItemStack itemstack) {
+				return true;
+			}
+
+			public int getMaxStackSize() {
+				return 1;
+			}
+		});
+		this.a(new Slot(this.enchantSlots, 1, 35, 47) {
+			public boolean isAllowed(ItemStack itemstack) {
+				return itemstack.getItem() == Items.DYE &&
+				       EnumColor.fromInvColorIndex(itemstack.getData()) == EnumColor.BLUE;
+			}
+		});
+
+		int i;
+
+		for (i = 0; i < 3; ++i) {
+			for (int j = 0; j < 9; ++j) {
+				this.a(new Slot(playerinventory, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));
+			}
+		}
+
+		for (i = 0; i < 9; ++i) {
+			this.a(new Slot(playerinventory, i, 8 + i * 18, 142));
+		}
+
+		// CraftBukkit start
+		player = (Player) playerinventory.player.getBukkitEntity();
+		// CraftBukkit end
+	}
+
+	public void addSlotListener(ICrafting icrafting) {
+		super.addSlotListener(icrafting);
+		icrafting.setContainerData(this, 0, this.costs[0]);
+		icrafting.setContainerData(this, 1, this.costs[1]);
+		icrafting.setContainerData(this, 2, this.costs[2]);
+		icrafting.setContainerData(this, 3, this.f & -16);
+		icrafting.setContainerData(this, 4, this.h[0]);
+		icrafting.setContainerData(this, 5, this.h[1]);
+		icrafting.setContainerData(this, 6, this.h[2]);
+	}
+
+	public void b() {
+		super.b();
+
+		for (int i = 0; i < this.listeners.size(); ++i) {
+			ICrafting icrafting = (ICrafting) this.listeners.get(i);
+
+			icrafting.setContainerData(this, 0, this.costs[0]);
+			icrafting.setContainerData(this, 1, this.costs[1]);
+			icrafting.setContainerData(this, 2, this.costs[2]);
+			icrafting.setContainerData(this, 3, this.f & -16);
+			icrafting.setContainerData(this, 4, this.h[0]);
+			icrafting.setContainerData(this, 5, this.h[1]);
+			icrafting.setContainerData(this, 6, this.h[2]);
+		}
+
+	}
+
+	public void update(IInventory iinventory) {
+		super.a(iinventory);
+
+		if (iinventory == this.enchantSlots) {
+			ItemStack itemstack = iinventory.getItem(0);
+			int i;
+
+			if (itemstack != null) { // CraftBukkit - relax condition
+				this.f = RANDOM.nextInt();
+				if (!this.world.isClientSide) {
+					i = 0;
+
+					int j;
+
+					for (j = -1; j <= 1; ++j) {
+						for (int k = -1; k <= 1; ++k) {
+							if ((j != 0 || k != 0) && this.world.isEmpty(this.position.a(k, 0, j)) &&
+							    this.world.isEmpty(this.position.a(k, 1, j))) {
+								if (this.world.getType(this.position.a(k * 2, 0, j * 2)).getBlock() ==
+								    Blocks.BOOKSHELF) {
+									++i;
+								}
+
+								if (this.world.getType(this.position.a(k * 2, 1, j * 2)).getBlock() ==
+								    Blocks.BOOKSHELF) {
+									++i;
+								}
+
+								if (k != 0 && j != 0) {
+									if (this.world.getType(this.position.a(k * 2, 0, j)).getBlock() ==
+									    Blocks.BOOKSHELF) {
+										++i;
+									}
+
+									if (this.world.getType(this.position.a(k * 2, 1, j)).getBlock() ==
+									    Blocks.BOOKSHELF) {
+										++i;
+									}
+
+									if (this.world.getType(this.position.a(k, 0, j * 2)).getBlock() ==
+									    Blocks.BOOKSHELF) {
+										++i;
+									}
+
+									if (this.world.getType(this.position.a(k, 1, j * 2)).getBlock() ==
+									    Blocks.BOOKSHELF) {
+										++i;
+									}
+								}
+							}
+						}
+					}
+
+					for (j = 0; j < 3; ++j) {
+						this.costs[j] = EnchantmentManager.a(RANDOM, j, i, itemstack);
+						this.h[j] = -1;
                         if (this.costs[j] < j + 1) {
                             this.costs[j] = 0;
                         }
-                    }
-
-                    // CraftBukkit start
-                    CraftItemStack item = CraftItemStack.asCraftMirror(itemstack);
-                    PrepareItemEnchantEvent event = new PrepareItemEnchantEvent(player, this.getBukkitView(), this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), item, this.costs, i);
-                    event.setCancelled(!itemstack.v());
-                    this.world.getServer().getPluginManager().callEvent(event);
-
-                    if (event.isCancelled()) {
-                        for (i = 0; i < 3; ++i) {
-                            this.costs[i] = 0;
-                        }
-                        return;
-                    }
-                    // CraftBukkit end
-
-                    for (j = 0; j < 3; ++j) {
-                        if (this.costs[j] > 0) {
-                            List list = this.a(itemstack, j, this.costs[j]);
-
-                            if (list != null && !list.isEmpty()) {
-                                WeightedRandomEnchant weightedrandomenchant = (WeightedRandomEnchant) list.get(this.k.nextInt(list.size()));
-
-                                this.h[j] = weightedrandomenchant.enchantment.id | weightedrandomenchant.level << 8;
-                            }
-                        }
-                    }
-
-                    this.b();
-                }
-            } else {
-                for (i = 0; i < 3; ++i) {
-                    this.costs[i] = 0;
-                    this.h[i] = -1;
-                }
-            }
-        }
-
-    }
-
-    public boolean a(EntityHuman entityhuman, int i) {
-        ItemStack itemstack = this.enchantSlots.getItem(0);
-        ItemStack itemstack1 = this.enchantSlots.getItem(1);
-        int j = i + 1;
-
-        if ((itemstack1 == null || itemstack1.count < j) && !entityhuman.abilities.canInstantlyBuild) {
-            return false;
-        } else if (this.costs[i] > 0 && itemstack != null && (entityhuman.expLevel >= j && entityhuman.expLevel >= this.costs[i] || entityhuman.abilities.canInstantlyBuild)) {
-            if (!this.world.isClientSide) {
-                List list = this.a(itemstack, i, this.costs[i]);
-                // CraftBukkit start - Provide an empty enchantment list
-                if (list == null) {
-                    list = new java.util.ArrayList<WeightedRandomEnchant>();
-                }
-                // CraftBukkit end
-                boolean flag = itemstack.getItem() == Items.BOOK;
-
-                if (list != null) {
-                    // CraftBukkit start
-                    Map<org.bukkit.enchantments.Enchantment, Integer> enchants = new java.util.HashMap<org.bukkit.enchantments.Enchantment, Integer>();
-                    for (Object obj : list) {
-                        WeightedRandomEnchant instance = (WeightedRandomEnchant) obj;
-                        enchants.put(org.bukkit.enchantments.Enchantment.getById(instance.enchantment.id), instance.level);
-                    }
-                    CraftItemStack item = CraftItemStack.asCraftMirror(itemstack);
-
-                    EnchantItemEvent event = new EnchantItemEvent((Player) entityhuman.getBukkitEntity(), this.getBukkitView(), this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), item, this.costs[i], enchants, i);
-                    this.world.getServer().getPluginManager().callEvent(event);
-
-                    int level = event.getExpLevelCost();
-                    if (event.isCancelled() || (level > entityhuman.expLevel && !entityhuman.abilities.canInstantlyBuild) || event.getEnchantsToAdd().isEmpty()) {
-                        return false;
-                    }
-                    if (flag) {
-                        itemstack.setItem(Items.ENCHANTED_BOOK);
-                    }
-
-                    for (Map.Entry<org.bukkit.enchantments.Enchantment, Integer> entry : event.getEnchantsToAdd().entrySet()) {
-                        try {
-                            if (flag) {
-                                int enchantId = entry.getKey().getId();
-                                if (Enchantment.getById(enchantId) == null) {
-                                    continue;
-                                }
-
-                                WeightedRandomEnchant enchantment = new WeightedRandomEnchant(Enchantment.getById(enchantId), entry.getValue());
-                                Items.ENCHANTED_BOOK.a(itemstack, enchantment);
-                            } else {
-                                item.addUnsafeEnchantment(entry.getKey(), entry.getValue());
-                            }
-                        } catch (IllegalArgumentException e) {
+					}
+
+					// CraftBukkit start
+					CraftItemStack item = CraftItemStack.asCraftMirror(itemstack);
+					PrepareItemEnchantEvent event = new PrepareItemEnchantEvent(player, this.getBukkitView(),
+							this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), item,
+							this.costs, i);
+					event.setCancelled(!itemstack.v());
+					this.world.getServer().getPluginManager().callEvent(event);
+
+					if (event.isCancelled()) {
+						for (i = 0; i < 3; ++i) {
+							this.costs[i] = 0;
+						}
+						return;
+					}
+					// CraftBukkit end
+
+					for (j = 0; j < 3; ++j) {
+						if (this.costs[j] > 0) {
+							List list = this.a(itemstack, j, this.costs[j]);
+
+							if (list != null && !list.isEmpty()) {
+								WeightedRandomEnchant weightedrandomenchant = (WeightedRandomEnchant) list
+										.get(RANDOM.nextInt(list.size()));
+
+								this.h[j] = weightedrandomenchant.enchantment.id | weightedrandomenchant.level << 8;
+							}
+						}
+					}
+
+					this.b();
+				}
+			} else {
+				for (i = 0; i < 3; ++i) {
+					this.costs[i] = 0;
+					this.h[i] = -1;
+				}
+			}
+		}
+	}
+
+	@Override
+	public void a(IInventory iinventory) {
+		this.update(iinventory);
+	}
+
+	public boolean a(EntityHuman entityhuman, int i) {
+		ItemStack itemstack = this.enchantSlots.getItem(0);
+		int j = i + 1;
+
+		if (this.costs[i] > 0 && itemstack != null &&
+		    (entityhuman.expLevel >= j && entityhuman.expLevel >= this.costs[i] ||
+		     entityhuman.abilities.canInstantlyBuild)) {
+			if (!this.world.isClientSide) {
+				List list = this.a(itemstack, i, this.costs[i]);
+				// CraftBukkit start - Provide an empty enchantment list
+				if (list == null) {
+					list = new java.util.ArrayList<WeightedRandomEnchant>();
+				}
+				// CraftBukkit end
+				boolean flag = itemstack.getItem() == Items.BOOK;
+
+				if (list != null) {
+					// CraftBukkit start
+					Map<org.bukkit.enchantments.Enchantment, Integer> enchants
+							= new java.util.HashMap<org.bukkit.enchantments.Enchantment, Integer>();
+					for (Object obj : list) {
+						WeightedRandomEnchant instance = (WeightedRandomEnchant) obj;
+						enchants.put(org.bukkit.enchantments.Enchantment.getById(instance.enchantment.id),
+								instance.level);
+					}
+					CraftItemStack item = CraftItemStack.asCraftMirror(itemstack);
+
+					Bukkit.getLogger().info("enchant item enchant " + player.getName());
+					EnchantItemEvent event = new EnchantItemEvent((Player) entityhuman.getBukkitEntity(),
+							this.getBukkitView(),
+							this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), item,
+							this.costs[i], enchants, i);
+					this.world.getServer().getPluginManager().callEvent(event);
+
+					int level = event.getExpLevelCost();
+					if (event.isCancelled() ||
+					    (level > entityhuman.expLevel && !entityhuman.abilities.canInstantlyBuild) ||
+					    event.getEnchantsToAdd().isEmpty()) {
+						return false;
+					}
+					if (flag) {
+						itemstack.setItem(Items.ENCHANTED_BOOK);
+					}
+
+					for (Map.Entry<org.bukkit.enchantments.Enchantment, Integer> entry : event.getEnchantsToAdd()
+					                                                                          .entrySet()) {
+						try {
+							if (flag) {
+								int enchantId = entry.getKey().getId();
+								if (Enchantment.getById(enchantId) == null) {
+									continue;
+								}
+
+								WeightedRandomEnchant enchantment = new WeightedRandomEnchant(
+										Enchantment.getById(enchantId), entry.getValue());
+								Items.ENCHANTED_BOOK.a(itemstack, enchantment);
+							} else {
+								item.addUnsafeEnchantment(entry.getKey(), entry.getValue());
+							}
+						} catch (IllegalArgumentException e) {
                             /* Just swallow invalid enchantments */
-                        }
-                    }
-
-                    entityhuman.enchantDone(j);
-                    // CraftBukkit end
-
-                    // CraftBukkit - TODO: let plugins change this
-                    if (!entityhuman.abilities.canInstantlyBuild) {
-                        itemstack1.count -= j;
-                        if (itemstack1.count <= 0) {
-                            this.enchantSlots.setItem(1, (ItemStack) null);
-                        }
-                    }
-
-                    entityhuman.b(StatisticList.W);
-                    this.enchantSlots.update();
-                    this.f = entityhuman.cj();
-                    this.a(this.enchantSlots);
-                }
-            }
-
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private List<WeightedRandomEnchant> a(ItemStack itemstack, int i, int j) {
-        this.k.setSeed((long) (this.f + i));
-        List list = EnchantmentManager.b(this.k, itemstack, j);
-
-        if (itemstack.getItem() == Items.BOOK && list != null && list.size() > 1) {
-            list.remove(this.k.nextInt(list.size()));
-        }
-
-        return list;
-    }
-
-    public void b(EntityHuman entityhuman) {
-        super.b(entityhuman);
-        // CraftBukkit Start - If an enchantable was opened from a null location, set the world to the player's world, preventing a crash
-        if(this.world == null) {
-            this.world = entityhuman.getWorld();
-        }
-        // CraftBukkit end
-        if (!this.world.isClientSide) {
-            for (int i = 0; i < this.enchantSlots.getSize(); ++i) {
-                ItemStack itemstack = this.enchantSlots.splitWithoutUpdate(i);
-
-                if (itemstack != null) {
-                    entityhuman.drop(itemstack, false);
-                }
-            }
-
-        }
-    }
-
-    public boolean a(EntityHuman entityhuman) {
-        if (!this.checkReachable) return true; // CraftBukkit
-        return this.world.getType(this.position).getBlock() != Blocks.ENCHANTING_TABLE ? false : entityhuman.e((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
-    }
-
-    public ItemStack b(EntityHuman entityhuman, int i) {
-        ItemStack itemstack = null;
-        Slot slot = (Slot) this.c.get(i);
-
-        if (slot != null && slot.hasItem()) {
-            ItemStack itemstack1 = slot.getItem();
-
-            itemstack = itemstack1.cloneItemStack();
-            if (i == 0) {
-                if (!this.a(itemstack1, 2, 38, true)) {
-                    return null;
-                }
-            } else if (i == 1) {
-                if (!this.a(itemstack1, 2, 38, true)) {
-                    return null;
-                }
-            } else if (itemstack1.getItem() == Items.DYE && EnumColor.fromInvColorIndex(itemstack1.getData()) == EnumColor.BLUE) {
-                if (!this.a(itemstack1, 1, 2, true)) {
-                    return null;
-                }
-            } else {
-                if (((Slot) this.c.get(0)).hasItem() || !((Slot) this.c.get(0)).isAllowed(itemstack1)) {
-                    return null;
-                }
-
-                if (itemstack1.hasTag() && itemstack1.count == 1) {
-                    ((Slot) this.c.get(0)).set(itemstack1.cloneItemStack());
-                    itemstack1.count = 0;
-                } else if (itemstack1.count >= 1) {
-                    // Spigot start
-                    ItemStack clone = itemstack1.cloneItemStack();
-                    clone.count = 1;
-                    ((Slot) this.c.get(0)).set(clone);
-                    // Spigot end
-                    --itemstack1.count;
-                }
-            }
-
-            if (itemstack1.count == 0) {
-                slot.set((ItemStack) null);
-            } else {
-                slot.f();
-            }
-
-            if (itemstack1.count == itemstack.count) {
-                return null;
-            }
-
-            slot.a(entityhuman, itemstack1);
-        }
-
-        return itemstack;
-    }
-
-    // CraftBukkit start
-    @Override
-    public CraftInventoryView getBukkitView() {
-        if (bukkitEntity != null) {
-            return bukkitEntity;
-        }
-
-        CraftInventoryEnchanting inventory = new CraftInventoryEnchanting(this.enchantSlots);
-        bukkitEntity = new CraftInventoryView(this.player, inventory, this);
-        return bukkitEntity;
-    }
-    // CraftBukkit end
+						}
+					}
+
+					entityhuman.enchantDone(j);
+					// CraftBukkit end
+
+					entityhuman.b(StatisticList.W);
+					this.enchantSlots.update();
+					this.a(this.enchantSlots);
+				}
+			}
+
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	private List<WeightedRandomEnchant> a(ItemStack itemstack, int i, int j) {
+		List list = EnchantmentManager.b(RANDOM, itemstack, j);
+
+		if (itemstack.getItem() == Items.BOOK && list != null && list.size() > 1) {
+			list.remove(RANDOM.nextInt(list.size()));
+		}
+
+		return list;
+	}
+
+	public void b(EntityHuman entityhuman) {
+		super.b(entityhuman);
+		// on container close
+		// CraftBukkit Start - If an enchantable was opened from a null location, set the world to the player's world, preventing a crash
+		if (this.world == null) {
+			this.world = entityhuman.getWorld();
+		}
+		// CraftBukkit end
+		if (!this.world.isClientSide) {
+			for (int i = 0; i < this.enchantSlots.getSize(); ++i) {
+				ItemStack itemstack = this.enchantSlots.splitWithoutUpdate(i);
+
+				if (itemstack != null) {
+					entityhuman.drop(itemstack, false);
+				}
+			}
+
+		}
+	}
+
+	public boolean a(EntityHuman entityhuman) {
+		if (!this.checkReachable) {
+			return true; // CraftBukkit
+		}
+		return this.world.getType(this.position).getBlock() != Blocks.ENCHANTING_TABLE ? false : entityhuman
+				                                                                                         .e((double) this.position
+								                                                                                         .getX() +
+				                                                                                            0.5D,
+						                                                                                         (double) this.position
+								                                                                                         .getY() +
+						                                                                                         0.5D,
+						                                                                                         (double) this.position
+								                                                                                         .getZ() +
+						                                                                                         0.5D) <=
+		                                                                                         64.0D;
+	}
+
+	public ItemStack b(EntityHuman entityhuman, int i) {
+		// When the item is shift clicked?
+		ItemStack itemstack = null;
+		Slot slot = (Slot) this.c.get(i);
+
+		if (slot != null && slot.hasItem()) {
+			ItemStack itemstack1 = slot.getItem();
+
+			itemstack = itemstack1.cloneItemStack();
+			if (i == 0) {
+				if (!this.a(itemstack1, 2, 38, true)) {
+					return null;
+				}
+			} else if (i == 1) {
+				if (!this.a(itemstack1, 2, 38, true)) {
+					return null;
+				}
+			} else if (itemstack1.getItem() == Items.DYE &&
+			           EnumColor.fromInvColorIndex(itemstack1.getData()) == EnumColor.BLUE) {
+				if (!this.a(itemstack1, 1, 2, true)) {
+					return null;
+				}
+			} else {
+				if (((Slot) this.c.get(0)).hasItem() || !((Slot) this.c.get(0)).isAllowed(itemstack1)) {
+					return null;
+				}
+
+				if (itemstack1.hasTag() && itemstack1.count == 1) {
+					((Slot) this.c.get(0)).set(itemstack1.cloneItemStack());
+					itemstack1.count = 0;
+				} else if (itemstack1.count >= 1) {
+					// Spigot start
+					ItemStack clone = itemstack1.cloneItemStack();
+					clone.count = 1;
+					((Slot) this.c.get(0)).set(clone);
+					// Spigot end
+					--itemstack1.count;
+				}
+			}
+
+			if (itemstack1.count == 0) {
+				slot.set((ItemStack) null);
+			} else {
+				slot.f();
+			}
+
+			if (itemstack1.count == itemstack.count) {
+				return null;
+			}
+
+			slot.a(entityhuman, itemstack1);
+		}
+
+		return itemstack;
+	}
+
+	// CraftBukkit start
+	@Override
+	public CraftInventoryView getBukkitView() {
+		if (bukkitEntity != null) {
+			return bukkitEntity;
+		}
+
+		CraftInventoryEnchanting inventory = new CraftInventoryEnchanting(this.enchantSlots);
+		bukkitEntity = new CraftInventoryView(this.player, inventory, this);
+		return bukkitEntity;
+	}
+	// CraftBukkit end
 }
diff --git a/src/main/java/net/minecraft/server/CraftingManager.java b/src/main/java/net/minecraft/server/CraftingManager.java
index 544ff0a6..ea2bb948 100644
--- a/src/main/java/net/minecraft/server/CraftingManager.java
+++ b/src/main/java/net/minecraft/server/CraftingManager.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -9,182 +10,181 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 
-import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 
 public class CraftingManager {
 
     private static final CraftingManager a = new CraftingManager();
+
     public List<IRecipe> recipes = Lists.newArrayList();
-    // CraftBukkit start
     public IRecipe lastRecipe;
     public org.bukkit.inventory.InventoryView lastCraftView;
-    // CraftBukkit end
 
     public static CraftingManager getInstance() {
         return CraftingManager.a;
     }
 
     public CraftingManager() {
-        (new RecipesTools()).a(this);
-        (new RecipesWeapons()).a(this);
-        (new RecipeIngots()).a(this);
-        (new RecipesFood()).a(this);
-        (new RecipesCrafting()).a(this);
-        (new RecipesArmor()).a(this);
-        (new RecipesDyes()).a(this);
+        new RecipesTools().a(this);
+        new RecipesWeapons().a(this);
+        new RecipeIngots().a(this);
+        new RecipesFood().a(this);
+        new RecipesCrafting().a(this);
+        new RecipesArmor().a(this);
+        new RecipesDyes().a(this);
         this.recipes.add(new RecipeArmorDye());
         this.recipes.add(new RecipeBookClone());
         this.recipes.add(new RecipeMapClone());
         this.recipes.add(new RecipeMapExtend());
         this.recipes.add(new RecipeFireworks());
         this.recipes.add(new RecipeRepair());
-        (new RecipesBanner()).a(this);
-        this.registerShapedRecipe(new ItemStack(Items.PAPER, 3), new Object[] { "###", Character.valueOf('#'), Items.REEDS});
-        this.registerShapelessRecipe(new ItemStack(Items.BOOK, 1), new Object[] { Items.PAPER, Items.PAPER, Items.PAPER, Items.LEATHER});
-        this.registerShapelessRecipe(new ItemStack(Items.WRITABLE_BOOK, 1), new Object[] { Items.BOOK, new ItemStack(Items.DYE, 1, EnumColor.BLACK.getInvColorIndex()), Items.FEATHER});
-        this.registerShapedRecipe(new ItemStack(Blocks.FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_FENCE, 3), new Object[] { "W#W", "W#W", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.COBBLESTONE_WALL, 6, BlockCobbleWall.EnumCobbleVariant.NORMAL.a()), new Object[] { "###", "###", Character.valueOf('#'), Blocks.COBBLESTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.COBBLESTONE_WALL, 6, BlockCobbleWall.EnumCobbleVariant.MOSSY.a()), new Object[] { "###", "###", Character.valueOf('#'), Blocks.MOSSY_COBBLESTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.NETHER_BRICK_FENCE, 6), new Object[] { "###", "###", Character.valueOf('#'), Blocks.NETHER_BRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_FENCE_GATE, 1), new Object[] { "#W#", "#W#", Character.valueOf('#'), Items.STICK, Character.valueOf('W'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.JUKEBOX, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Blocks.PLANKS, Character.valueOf('X'), Items.DIAMOND});
-        this.registerShapedRecipe(new ItemStack(Items.LEAD, 2), new Object[] { "~~ ", "~O ", "  ~", Character.valueOf('~'), Items.STRING, Character.valueOf('O'), Items.SLIME});
-        this.registerShapedRecipe(new ItemStack(Blocks.NOTEBLOCK, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Blocks.PLANKS, Character.valueOf('X'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.BOOKSHELF, 1), new Object[] { "###", "XXX", "###", Character.valueOf('#'), Blocks.PLANKS, Character.valueOf('X'), Items.BOOK});
-        this.registerShapedRecipe(new ItemStack(Blocks.SNOW, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.SNOWBALL});
-        this.registerShapedRecipe(new ItemStack(Blocks.SNOW_LAYER, 6), new Object[] { "###", Character.valueOf('#'), Blocks.SNOW});
-        this.registerShapedRecipe(new ItemStack(Blocks.CLAY, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.CLAY_BALL});
-        this.registerShapedRecipe(new ItemStack(Blocks.BRICK_BLOCK, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.BRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.GLOWSTONE, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.GLOWSTONE_DUST});
-        this.registerShapedRecipe(new ItemStack(Blocks.QUARTZ_BLOCK, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.QUARTZ});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOOL, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.STRING});
-        this.registerShapedRecipe(new ItemStack(Blocks.TNT, 1), new Object[] { "X#X", "#X#", "X#X", Character.valueOf('X'), Items.GUNPOWDER, Character.valueOf('#'), Blocks.SAND});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.COBBLESTONE.a()), new Object[] { "###", Character.valueOf('#'), Blocks.COBBLESTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.STONE.a()), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.STONE, BlockStone.EnumStoneVariant.STONE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.SAND.a()), new Object[] { "###", Character.valueOf('#'), Blocks.SANDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.BRICK.a()), new Object[] { "###", Character.valueOf('#'), Blocks.BRICK_BLOCK});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.SMOOTHBRICK.a()), new Object[] { "###", Character.valueOf('#'), Blocks.STONEBRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.NETHERBRICK.a()), new Object[] { "###", Character.valueOf('#'), Blocks.NETHER_BRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.QUARTZ.a()), new Object[] { "###", Character.valueOf('#'), Blocks.QUARTZ_BLOCK});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB2, 6, BlockDoubleStoneStepAbstract.EnumStoneSlab2Variant.RED_SANDSTONE.a()), new Object[] { "###", Character.valueOf('#'), Blocks.RED_SANDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 0), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.BIRCH.a()), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.SPRUCE.a()), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.JUNGLE.a()), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4), new Object[] { "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.LADDER, 3), new Object[] { "# #", "###", "# #", Character.valueOf('#'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Items.WOODEN_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Items.SPRUCE_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Items.BIRCH_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Items.JUNGLE_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Items.ACACIA_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.ACACIA.a())});
-        this.registerShapedRecipe(new ItemStack(Items.DARK_OAK_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.DARK_OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.TRAPDOOR, 2), new Object[] { "###", "###", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Items.IRON_DOOR, 3), new Object[] { "##", "##", "##", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Blocks.IRON_TRAPDOOR, 1), new Object[] { "##", "##", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Items.SIGN, 3), new Object[] { "###", "###", " X ", Character.valueOf('#'), Blocks.PLANKS, Character.valueOf('X'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Items.CAKE, 1), new Object[] { "AAA", "BEB", "CCC", Character.valueOf('A'), Items.MILK_BUCKET, Character.valueOf('B'), Items.SUGAR, Character.valueOf('C'), Items.WHEAT, Character.valueOf('E'), Items.EGG});
-        this.registerShapedRecipe(new ItemStack(Items.SUGAR, 1), new Object[] { "#", Character.valueOf('#'), Items.REEDS});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.OAK.a()), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.SPRUCE.a()), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.BIRCH.a()), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.JUNGLE.a()), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG2, 1, BlockWood.EnumLogVariant.ACACIA.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.LOG2, 1, BlockWood.EnumLogVariant.DARK_OAK.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Items.STICK, 4), new Object[] { "#", "#", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Blocks.TORCH, 4), new Object[] { "X", "#", Character.valueOf('X'), Items.COAL, Character.valueOf('#'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.TORCH, 4), new Object[] { "X", "#", Character.valueOf('X'), new ItemStack(Items.COAL, 1, 1), Character.valueOf('#'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Items.BOWL, 4), new Object[] { "# #", " # ", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Items.GLASS_BOTTLE, 3), new Object[] { "# #", " # ", Character.valueOf('#'), Blocks.GLASS});
-        this.registerShapedRecipe(new ItemStack(Blocks.RAIL, 16), new Object[] { "X X", "X#X", "X X", Character.valueOf('X'), Items.IRON_INGOT, Character.valueOf('#'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.GOLDEN_RAIL, 6), new Object[] { "X X", "X#X", "XRX", Character.valueOf('X'), Items.GOLD_INGOT, Character.valueOf('R'), Items.REDSTONE, Character.valueOf('#'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.ACTIVATOR_RAIL, 6), new Object[] { "XSX", "X#X", "XSX", Character.valueOf('X'), Items.IRON_INGOT, Character.valueOf('#'), Blocks.REDSTONE_TORCH, Character.valueOf('S'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.DETECTOR_RAIL, 6), new Object[] { "X X", "X#X", "XRX", Character.valueOf('X'), Items.IRON_INGOT, Character.valueOf('R'), Items.REDSTONE, Character.valueOf('#'), Blocks.STONE_PRESSURE_PLATE});
-        this.registerShapedRecipe(new ItemStack(Items.MINECART, 1), new Object[] { "# #", "###", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Items.CAULDRON, 1), new Object[] { "# #", "# #", "###", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Items.BREWING_STAND, 1), new Object[] { " B ", "###", Character.valueOf('#'), Blocks.COBBLESTONE, Character.valueOf('B'), Items.BLAZE_ROD});
-        this.registerShapedRecipe(new ItemStack(Blocks.LIT_PUMPKIN, 1), new Object[] { "A", "B", Character.valueOf('A'), Blocks.PUMPKIN, Character.valueOf('B'), Blocks.TORCH});
-        this.registerShapedRecipe(new ItemStack(Items.CHEST_MINECART, 1), new Object[] { "A", "B", Character.valueOf('A'), Blocks.CHEST, Character.valueOf('B'), Items.MINECART});
-        this.registerShapedRecipe(new ItemStack(Items.FURNACE_MINECART, 1), new Object[] { "A", "B", Character.valueOf('A'), Blocks.FURNACE, Character.valueOf('B'), Items.MINECART});
-        this.registerShapedRecipe(new ItemStack(Items.TNT_MINECART, 1), new Object[] { "A", "B", Character.valueOf('A'), Blocks.TNT, Character.valueOf('B'), Items.MINECART});
-        this.registerShapedRecipe(new ItemStack(Items.HOPPER_MINECART, 1), new Object[] { "A", "B", Character.valueOf('A'), Blocks.HOPPER, Character.valueOf('B'), Items.MINECART});
-        this.registerShapedRecipe(new ItemStack(Items.BOAT, 1), new Object[] { "# #", "###", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Items.BUCKET, 1), new Object[] { "# #", " # ", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Items.FLOWER_POT, 1), new Object[] { "# #", " # ", Character.valueOf('#'), Items.BRICK});
-        this.registerShapelessRecipe(new ItemStack(Items.FLINT_AND_STEEL, 1), new Object[] { new ItemStack(Items.IRON_INGOT, 1), new ItemStack(Items.FLINT, 1)});
-        this.registerShapedRecipe(new ItemStack(Items.BREAD, 1), new Object[] { "###", Character.valueOf('#'), Items.WHEAT});
-        this.registerShapedRecipe(new ItemStack(Blocks.OAK_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4)});
-        this.registerShapedRecipe(new ItemStack(Items.FISHING_ROD, 1), new Object[] { "  #", " #X", "# X", Character.valueOf('#'), Items.STICK, Character.valueOf('X'), Items.STRING});
-        this.registerShapedRecipe(new ItemStack(Items.CARROT_ON_A_STICK, 1), new Object[] { "# ", " X", Character.valueOf('#'), Items.FISHING_ROD, Character.valueOf('X'), Items.CARROT});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.COBBLESTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.BRICK_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.BRICK_BLOCK});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_BRICK_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.STONEBRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.NETHER_BRICK_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.NETHER_BRICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.SANDSTONE_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.SANDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.RED_SANDSTONE_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.RED_SANDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.QUARTZ_STAIRS, 4), new Object[] { "#  ", "## ", "###", Character.valueOf('#'), Blocks.QUARTZ_BLOCK});
-        this.registerShapedRecipe(new ItemStack(Items.PAINTING, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.STICK, Character.valueOf('X'), Blocks.WOOL});
-        this.registerShapedRecipe(new ItemStack(Items.ITEM_FRAME, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.STICK, Character.valueOf('X'), Items.LEATHER});
-        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_APPLE, 1, 0), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.GOLD_INGOT, Character.valueOf('X'), Items.APPLE});
-        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_APPLE, 1, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Blocks.GOLD_BLOCK, Character.valueOf('X'), Items.APPLE});
-        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_CARROT, 1, 0), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.GOLD_NUGGET, Character.valueOf('X'), Items.CARROT});
-        this.registerShapedRecipe(new ItemStack(Items.SPECKLED_MELON, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.GOLD_NUGGET, Character.valueOf('X'), Items.MELON});
-        this.registerShapedRecipe(new ItemStack(Blocks.LEVER, 1), new Object[] { "X", "#", Character.valueOf('#'), Blocks.COBBLESTONE, Character.valueOf('X'), Items.STICK});
-        this.registerShapedRecipe(new ItemStack(Blocks.TRIPWIRE_HOOK, 2), new Object[] { "I", "S", "#", Character.valueOf('#'), Blocks.PLANKS, Character.valueOf('S'), Items.STICK, Character.valueOf('I'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Blocks.REDSTONE_TORCH, 1), new Object[] { "X", "#", Character.valueOf('#'), Items.STICK, Character.valueOf('X'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Items.REPEATER, 1), new Object[] { "#X#", "III", Character.valueOf('#'), Blocks.REDSTONE_TORCH, Character.valueOf('X'), Items.REDSTONE, Character.valueOf('I'), new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a())});
-        this.registerShapedRecipe(new ItemStack(Items.COMPARATOR, 1), new Object[] { " # ", "#X#", "III", Character.valueOf('#'), Blocks.REDSTONE_TORCH, Character.valueOf('X'), Items.QUARTZ, Character.valueOf('I'), new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a())});
-        this.registerShapedRecipe(new ItemStack(Items.CLOCK, 1), new Object[] { " # ", "#X#", " # ", Character.valueOf('#'), Items.GOLD_INGOT, Character.valueOf('X'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Items.COMPASS, 1), new Object[] { " # ", "#X#", " # ", Character.valueOf('#'), Items.IRON_INGOT, Character.valueOf('X'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Items.MAP, 1), new Object[] { "###", "#X#", "###", Character.valueOf('#'), Items.PAPER, Character.valueOf('X'), Items.COMPASS});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_BUTTON, 1), new Object[] { "#", Character.valueOf('#'), new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_BUTTON, 1), new Object[] { "#", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Blocks.STONE_PRESSURE_PLATE, 1), new Object[] { "##", Character.valueOf('#'), new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a())});
-        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_PRESSURE_PLATE, 1), new Object[] { "##", Character.valueOf('#'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE, 1), new Object[] { "##", Character.valueOf('#'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, 1), new Object[] { "##", Character.valueOf('#'), Items.GOLD_INGOT});
-        this.registerShapedRecipe(new ItemStack(Blocks.DISPENSER, 1), new Object[] { "###", "#X#", "#R#", Character.valueOf('#'), Blocks.COBBLESTONE, Character.valueOf('X'), Items.BOW, Character.valueOf('R'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.DROPPER, 1), new Object[] { "###", "# #", "#R#", Character.valueOf('#'), Blocks.COBBLESTONE, Character.valueOf('R'), Items.REDSTONE});
-        this.registerShapedRecipe(new ItemStack(Blocks.PISTON, 1), new Object[] { "TTT", "#X#", "#R#", Character.valueOf('#'), Blocks.COBBLESTONE, Character.valueOf('X'), Items.IRON_INGOT, Character.valueOf('R'), Items.REDSTONE, Character.valueOf('T'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Blocks.STICKY_PISTON, 1), new Object[] { "S", "P", Character.valueOf('S'), Items.SLIME, Character.valueOf('P'), Blocks.PISTON});
-        this.registerShapedRecipe(new ItemStack(Items.BED, 1), new Object[] { "###", "XXX", Character.valueOf('#'), Blocks.WOOL, Character.valueOf('X'), Blocks.PLANKS});
-        this.registerShapedRecipe(new ItemStack(Blocks.ENCHANTING_TABLE, 1), new Object[] { " B ", "D#D", "###", Character.valueOf('#'), Blocks.OBSIDIAN, Character.valueOf('B'), Items.BOOK, Character.valueOf('D'), Items.DIAMOND});
-        this.registerShapedRecipe(new ItemStack(Blocks.ANVIL, 1), new Object[] { "III", " i ", "iii", Character.valueOf('I'), Blocks.IRON_BLOCK, Character.valueOf('i'), Items.IRON_INGOT});
-        this.registerShapedRecipe(new ItemStack(Items.LEATHER), new Object[] { "##", "##", Character.valueOf('#'), Items.RABBIT_HIDE});
-        this.registerShapelessRecipe(new ItemStack(Items.ENDER_EYE, 1), new Object[] { Items.ENDER_PEARL, Items.BLAZE_POWDER});
-        this.registerShapelessRecipe(new ItemStack(Items.FIRE_CHARGE, 3), new Object[] { Items.GUNPOWDER, Items.BLAZE_POWDER, Items.COAL});
-        this.registerShapelessRecipe(new ItemStack(Items.FIRE_CHARGE, 3), new Object[] { Items.GUNPOWDER, Items.BLAZE_POWDER, new ItemStack(Items.COAL, 1, 1)});
-        this.registerShapedRecipe(new ItemStack(Blocks.DAYLIGHT_DETECTOR), new Object[] { "GGG", "QQQ", "WWW", Character.valueOf('G'), Blocks.GLASS, Character.valueOf('Q'), Items.QUARTZ, Character.valueOf('W'), Blocks.WOODEN_SLAB});
-        this.registerShapedRecipe(new ItemStack(Blocks.HOPPER), new Object[] { "I I", "ICI", " I ", Character.valueOf('I'), Items.IRON_INGOT, Character.valueOf('C'), Blocks.CHEST});
-        this.registerShapedRecipe(new ItemStack(Items.ARMOR_STAND, 1), new Object[] { "///", " / ", "/_/", Character.valueOf('/'), Items.STICK, Character.valueOf('_'), new ItemStack(Blocks.STONE_SLAB, 1, BlockDoubleStepAbstract.EnumStoneSlabVariant.STONE.a())});
+        new RecipesBanner().a(this);
+        this.registerShapedRecipe(new ItemStack(Items.PAPER, 3), "###", '#', Items.REEDS);
+        this.registerShapelessRecipe(new ItemStack(Items.BOOK, 1), Items.PAPER, Items.PAPER, Items.PAPER, Items.LEATHER);
+        this.registerShapelessRecipe(new ItemStack(Items.WRITABLE_BOOK, 1), Items.BOOK, new ItemStack(Items.DYE, 1, EnumColor.BLACK.getInvColorIndex()), Items.FEATHER);
+        this.registerShapedRecipe(new ItemStack(Blocks.FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_FENCE, 3), "W#W", "W#W", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.COBBLESTONE_WALL, 6, BlockCobbleWall.EnumCobbleVariant.NORMAL.a()), "###", "###", '#', Blocks.COBBLESTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.COBBLESTONE_WALL, 6, BlockCobbleWall.EnumCobbleVariant.MOSSY.a()), "###", "###", '#', Blocks.MOSSY_COBBLESTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.NETHER_BRICK_FENCE, 6), "###", "###", '#', Blocks.NETHER_BRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_FENCE_GATE, 1), "#W#", "#W#", '#', Items.STICK, 'W', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.JUKEBOX, 1), "###", "#X#", "###", '#', Blocks.PLANKS, 'X', Items.DIAMOND);
+        this.registerShapedRecipe(new ItemStack(Items.LEAD, 2), "~~ ", "~O ", "  ~", '~', Items.STRING, 'O', Items.SLIME);
+        this.registerShapedRecipe(new ItemStack(Blocks.NOTEBLOCK, 1), "###", "#X#", "###", '#', Blocks.PLANKS, 'X', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.BOOKSHELF, 1), "###", "XXX", "###", '#', Blocks.PLANKS, 'X', Items.BOOK);
+        this.registerShapedRecipe(new ItemStack(Blocks.SNOW, 1), "##", "##", '#', Items.SNOWBALL);
+        this.registerShapedRecipe(new ItemStack(Blocks.SNOW_LAYER, 6), "###", '#', Blocks.SNOW);
+        this.registerShapedRecipe(new ItemStack(Blocks.CLAY, 1), "##", "##", '#', Items.CLAY_BALL);
+        this.registerShapedRecipe(new ItemStack(Blocks.BRICK_BLOCK, 1), "##", "##", '#', Items.BRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.GLOWSTONE, 1), "##", "##", '#', Items.GLOWSTONE_DUST);
+        this.registerShapedRecipe(new ItemStack(Blocks.QUARTZ_BLOCK, 1), "##", "##", '#', Items.QUARTZ);
+        this.registerShapedRecipe(new ItemStack(Blocks.WOOL, 1), "##", "##", '#', Items.STRING);
+        this.registerShapedRecipe(new ItemStack(Blocks.TNT, 1), "X#X", "#X#", "X#X", 'X', Items.GUNPOWDER, '#', Blocks.SAND);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.COBBLESTONE.a()), "###", '#', Blocks.COBBLESTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.STONE.a()), "###", '#', new ItemStack(Blocks.STONE, BlockStone.EnumStoneVariant.STONE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.SAND.a()), "###", '#', Blocks.SANDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.BRICK.a()), "###", '#', Blocks.BRICK_BLOCK);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.SMOOTHBRICK.a()), "###", '#', Blocks.STONEBRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.NETHERBRICK.a()), "###", '#', Blocks.NETHER_BRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB, 6, BlockDoubleStepAbstract.EnumStoneSlabVariant.QUARTZ.a()), "###", '#', Blocks.QUARTZ_BLOCK);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_SLAB2, 6, BlockDoubleStoneStepAbstract.EnumStoneSlab2Variant.RED_SANDSTONE.a()), "###", '#', Blocks.RED_SANDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 0), "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.BIRCH.a()), "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.SPRUCE.a()), "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, BlockWood.EnumLogVariant.JUNGLE.a()), "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4), "###", '#', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_SLAB, 6, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4), "###", '#', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.LADDER, 3), "# #", "###", "# #", '#', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Items.WOODEN_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Items.SPRUCE_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Items.BIRCH_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Items.JUNGLE_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Items.ACACIA_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.ACACIA.a()));
+        this.registerShapedRecipe(new ItemStack(Items.DARK_OAK_DOOR, 3), "##", "##", "##", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.DARK_OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.TRAPDOOR, 2), "###", "###", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Items.IRON_DOOR, 3), "##", "##", "##", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Blocks.IRON_TRAPDOOR, 1), "##", "##", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Items.SIGN, 3), "###", "###", " X ", '#', Blocks.PLANKS, 'X', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Items.CAKE, 1), "AAA", "BEB", "CCC", 'A', Items.MILK_BUCKET, 'B', Items.SUGAR, 'C', Items.WHEAT, 'E', Items.EGG);
+        this.registerShapedRecipe(new ItemStack(Items.SUGAR, 1), "#", '#', Items.REEDS);
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.OAK.a()), "#", '#', new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.SPRUCE.a()), "#", '#', new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.BIRCH.a()), "#", '#', new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, BlockWood.EnumLogVariant.JUNGLE.a()), "#", '#', new ItemStack(Blocks.LOG, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4), "#", '#', new ItemStack(Blocks.LOG2, 1, BlockWood.EnumLogVariant.ACACIA.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.PLANKS, 4, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4), "#", '#', new ItemStack(Blocks.LOG2, 1, BlockWood.EnumLogVariant.DARK_OAK.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Items.STICK, 4), "#", "#", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Blocks.TORCH, 4), "X", "#", 'X', Items.COAL, '#', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.TORCH, 4), "X", "#", 'X', new ItemStack(Items.COAL, 1, 1), '#', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Items.BOWL, 4), "# #", " # ", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Items.GLASS_BOTTLE, 3), "# #", " # ", '#', Blocks.GLASS);
+        this.registerShapedRecipe(new ItemStack(Blocks.RAIL, 16), "X X", "X#X", "X X", 'X', Items.IRON_INGOT, '#', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.GOLDEN_RAIL, 6), "X X", "X#X", "XRX", 'X', Items.GOLD_INGOT, 'R', Items.REDSTONE, '#', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.ACTIVATOR_RAIL, 6), "XSX", "X#X", "XSX", 'X', Items.IRON_INGOT, '#', Blocks.REDSTONE_TORCH, 'S', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.DETECTOR_RAIL, 6), "X X", "X#X", "XRX", 'X', Items.IRON_INGOT, 'R', Items.REDSTONE, '#', Blocks.STONE_PRESSURE_PLATE);
+        this.registerShapedRecipe(new ItemStack(Items.MINECART, 1), "# #", "###", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Items.CAULDRON, 1), "# #", "# #", "###", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Items.BREWING_STAND, 1), " B ", "###", '#', Blocks.COBBLESTONE, 'B', Items.BLAZE_ROD);
+        this.registerShapedRecipe(new ItemStack(Blocks.LIT_PUMPKIN, 1), "A", "B", 'A', Blocks.PUMPKIN, 'B', Blocks.TORCH);
+        this.registerShapedRecipe(new ItemStack(Items.CHEST_MINECART, 1), "A", "B", 'A', Blocks.CHEST, 'B', Items.MINECART);
+        this.registerShapedRecipe(new ItemStack(Items.FURNACE_MINECART, 1), "A", "B", 'A', Blocks.FURNACE, 'B', Items.MINECART);
+        this.registerShapedRecipe(new ItemStack(Items.TNT_MINECART, 1), "A", "B", 'A', Blocks.TNT, 'B', Items.MINECART);
+        this.registerShapedRecipe(new ItemStack(Items.HOPPER_MINECART, 1), "A", "B", 'A', Blocks.HOPPER, 'B', Items.MINECART);
+        this.registerShapedRecipe(new ItemStack(Items.BOAT, 1), "# #", "###", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Items.BUCKET, 1), "# #", " # ", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Items.FLOWER_POT, 1), "# #", " # ", '#', Items.BRICK);
+        this.registerShapelessRecipe(new ItemStack(Items.FLINT_AND_STEEL, 1), new ItemStack(Items.IRON_INGOT, 1), new ItemStack(Items.FLINT, 1));
+        this.registerShapedRecipe(new ItemStack(Items.BREAD, 1), "###", '#', Items.WHEAT);
+        this.registerShapedRecipe(new ItemStack(Blocks.OAK_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.OAK.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.BIRCH_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.BIRCH.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.SPRUCE_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.SPRUCE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.JUNGLE_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, BlockWood.EnumLogVariant.JUNGLE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.ACACIA_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.ACACIA.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Blocks.DARK_OAK_STAIRS, 4), "#  ", "## ", "###", '#', new ItemStack(Blocks.PLANKS, 1, 4 + BlockWood.EnumLogVariant.DARK_OAK.a() - 4));
+        this.registerShapedRecipe(new ItemStack(Items.FISHING_ROD, 1), "  #", " #X", "# X", '#', Items.STICK, 'X', Items.STRING);
+        this.registerShapedRecipe(new ItemStack(Items.CARROT_ON_A_STICK, 1), "# ", " X", '#', Items.FISHING_ROD, 'X', Items.CARROT);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.COBBLESTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.BRICK_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.BRICK_BLOCK);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_BRICK_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.STONEBRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.NETHER_BRICK_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.NETHER_BRICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.SANDSTONE_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.SANDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.RED_SANDSTONE_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.RED_SANDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.QUARTZ_STAIRS, 4), "#  ", "## ", "###", '#', Blocks.QUARTZ_BLOCK);
+        this.registerShapedRecipe(new ItemStack(Items.PAINTING, 1), "###", "#X#", "###", '#', Items.STICK, 'X', Blocks.WOOL);
+        this.registerShapedRecipe(new ItemStack(Items.ITEM_FRAME, 1), "###", "#X#", "###", '#', Items.STICK, 'X', Items.LEATHER);
+        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_APPLE, 1, 0), "###", "#X#", "###", '#', Items.GOLD_INGOT, 'X', Items.APPLE);
+        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_APPLE, 1, 1), "###", "#X#", "###", '#', Blocks.GOLD_BLOCK, 'X', Items.APPLE);
+        this.registerShapedRecipe(new ItemStack(Items.GOLDEN_CARROT, 1, 0), "###", "#X#", "###", '#', Items.GOLD_NUGGET, 'X', Items.CARROT);
+        this.registerShapedRecipe(new ItemStack(Items.SPECKLED_MELON, 1), "###", "#X#", "###", '#', Items.GOLD_NUGGET, 'X', Items.MELON);
+        this.registerShapedRecipe(new ItemStack(Blocks.LEVER, 1), "X", "#", '#', Blocks.COBBLESTONE, 'X', Items.STICK);
+        this.registerShapedRecipe(new ItemStack(Blocks.TRIPWIRE_HOOK, 2), "I", "S", "#", '#', Blocks.PLANKS, 'S', Items.STICK, 'I', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Blocks.REDSTONE_TORCH, 1), "X", "#", '#', Items.STICK, 'X', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Items.REPEATER, 1), "#X#", "III", '#', Blocks.REDSTONE_TORCH, 'X', Items.REDSTONE, 'I', new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a()));
+        this.registerShapedRecipe(new ItemStack(Items.COMPARATOR, 1), " # ", "#X#", "III", '#', Blocks.REDSTONE_TORCH, 'X', Items.QUARTZ, 'I', new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a()));
+        this.registerShapedRecipe(new ItemStack(Items.CLOCK, 1), " # ", "#X#", " # ", '#', Items.GOLD_INGOT, 'X', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Items.COMPASS, 1), " # ", "#X#", " # ", '#', Items.IRON_INGOT, 'X', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Items.MAP, 1), "###", "#X#", "###", '#', Items.PAPER, 'X', Items.COMPASS);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_BUTTON, 1), "#", '#', new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_BUTTON, 1), "#", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Blocks.STONE_PRESSURE_PLATE, 1), "##", '#', new ItemStack(Blocks.STONE, 1, BlockStone.EnumStoneVariant.STONE.a()));
+        this.registerShapedRecipe(new ItemStack(Blocks.WOODEN_PRESSURE_PLATE, 1), "##", '#', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Blocks.HEAVY_WEIGHTED_PRESSURE_PLATE, 1), "##", '#', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Blocks.LIGHT_WEIGHTED_PRESSURE_PLATE, 1), "##", '#', Items.GOLD_INGOT);
+        this.registerShapedRecipe(new ItemStack(Blocks.DISPENSER, 1), "###", "#X#", "#R#", '#', Blocks.COBBLESTONE, 'X', Items.BOW, 'R', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.DROPPER, 1), "###", "# #", "#R#", '#', Blocks.COBBLESTONE, 'R', Items.REDSTONE);
+        this.registerShapedRecipe(new ItemStack(Blocks.PISTON, 1), "TTT", "#X#", "#R#", '#', Blocks.COBBLESTONE, 'X', Items.IRON_INGOT, 'R', Items.REDSTONE, 'T', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Blocks.STICKY_PISTON, 1), "S", "P", 'S', Items.SLIME, 'P', Blocks.PISTON);
+        this.registerShapedRecipe(new ItemStack(Items.BED, 1), "###", "XXX", '#', Blocks.WOOL, 'X', Blocks.PLANKS);
+        this.registerShapedRecipe(new ItemStack(Blocks.ENCHANTING_TABLE, 1), " B ", "D#D", "###", '#', Blocks.OBSIDIAN, 'B', Items.BOOK, 'D', Items.DIAMOND);
+        this.registerShapedRecipe(new ItemStack(Blocks.ANVIL, 1), "III", " i ", "iii", 'I', Blocks.IRON_BLOCK, 'i', Items.IRON_INGOT);
+        this.registerShapedRecipe(new ItemStack(Items.LEATHER), "##", "##", '#', Items.RABBIT_HIDE);
+        this.registerShapelessRecipe(new ItemStack(Items.ENDER_EYE, 1), Items.ENDER_PEARL, Items.BLAZE_POWDER);
+        this.registerShapelessRecipe(new ItemStack(Items.FIRE_CHARGE, 3), Items.GUNPOWDER, Items.BLAZE_POWDER, Items.COAL);
+        this.registerShapelessRecipe(new ItemStack(Items.FIRE_CHARGE, 3), Items.GUNPOWDER, Items.BLAZE_POWDER, new ItemStack(Items.COAL, 1, 1));
+        this.registerShapedRecipe(new ItemStack(Blocks.DAYLIGHT_DETECTOR), "GGG", "QQQ", "WWW", 'G', Blocks.GLASS, 'Q', Items.QUARTZ, 'W', Blocks.WOODEN_SLAB);
+        this.registerShapedRecipe(new ItemStack(Blocks.HOPPER), "I I", "ICI", " I ", 'I', Items.IRON_INGOT, 'C', Blocks.CHEST);
+        this.registerShapedRecipe(new ItemStack(Items.ARMOR_STAND, 1), "///", " / ", "/_/", '/', Items.STICK, '_', new ItemStack(Blocks.STONE_SLAB, 1, BlockDoubleStepAbstract.EnumStoneSlabVariant.STONE.a()));
         sort();
     }
 
-    // CraftBukkit start
     public void sort() {
-       Collections.sort(this.recipes, new Comparator() {
-            public int a(IRecipe irecipe, IRecipe irecipe1) {
-                return irecipe instanceof ShapelessRecipes && irecipe1 instanceof ShapedRecipes ? 1 : (irecipe1 instanceof ShapelessRecipes && irecipe instanceof ShapedRecipes ? -1 : (irecipe1.a() < irecipe.a() ? -1 : (irecipe1.a() > irecipe.a() ? 1 : 0)));
+        Collections.sort(this.recipes, new Comparator() {
+            public int a(final IRecipe irecipe, final IRecipe irecipe1) {
+                return (irecipe instanceof ShapelessRecipes && irecipe1 instanceof ShapedRecipes) ? 1 : ((irecipe1 instanceof ShapelessRecipes && irecipe instanceof ShapedRecipes) ? -1 : ((irecipe1.a() < irecipe.a()) ? -1 : ((irecipe1.a() > irecipe.a()) ? 1 : 0)));
             }
 
-            public int compare(Object object, Object object1) {
-                return this.a((IRecipe) object, (IRecipe) object1);
+            @Override
+            public int compare(final Object object, final Object object1) {
+                return this.a((IRecipe)object, (IRecipe)object1);
             }
         });
     }
@@ -196,7 +196,7 @@ public class CraftingManager {
         int k = 0;
 
         if (aobject[i] instanceof String[]) {
-            String[] astring = (String[]) ((String[]) aobject[i++]);
+            String[] astring = (String[]) aobject[i++];
 
             for (int l = 0; l < astring.length; ++l) {
                 String s1 = astring[l];
@@ -215,48 +215,48 @@ public class CraftingManager {
             }
         }
 
-        HashMap hashmap;
+        HashMap<Character, ItemStack> map;
 
-        for (hashmap = Maps.newHashMap(); i < aobject.length; i += 2) {
+        for (map = Maps.newHashMap(); i < aobject.length; i += 2) {
             Character character = (Character) aobject[i];
-            ItemStack itemstack1 = null;
+            ItemStack itemStack = null;
 
             if (aobject[i + 1] instanceof Item) {
-                itemstack1 = new ItemStack((Item) aobject[i + 1]);
+                itemStack = new ItemStack((Item) aobject[i + 1]);
             } else if (aobject[i + 1] instanceof Block) {
-                itemstack1 = new ItemStack((Block) aobject[i + 1], 1, 32767);
+                itemStack = new ItemStack((Block) aobject[i + 1], 1, 32767);
             } else if (aobject[i + 1] instanceof ItemStack) {
-                itemstack1 = (ItemStack) aobject[i + 1];
+                itemStack = (ItemStack) aobject[i + 1];
             }
 
-            hashmap.put(character, itemstack1);
+            map.put(character, itemStack);
         }
 
-        ItemStack[] aitemstack = new ItemStack[j * k];
+        ItemStack[] itemStack = new ItemStack[j * k];
 
         for (int i1 = 0; i1 < j * k; ++i1) {
             char c0 = s.charAt(i1);
 
-            if (hashmap.containsKey(Character.valueOf(c0))) {
-                aitemstack[i1] = ((ItemStack) hashmap.get(Character.valueOf(c0))).cloneItemStack();
+            if (map.containsKey(c0)) {
+                itemStack[i1] = map.get(c0).cloneItemStack();
             } else {
-                aitemstack[i1] = null;
+                itemStack[i1] = null;
             }
         }
 
-        ShapedRecipes shapedrecipes = new ShapedRecipes(j, k, aitemstack, itemstack);
+        ShapedRecipes shapedrecipes = new ShapedRecipes(j, k, itemStack, itemstack);
 
         this.recipes.add(shapedrecipes);
         return shapedrecipes;
     }
 
-    public void registerShapelessRecipe(ItemStack itemstack, Object... aobject) {
+    public void registerShapelessRecipe(ItemStack itemstack, Object... providedObjects) {
         ArrayList arraylist = Lists.newArrayList();
-        Object[] aobject1 = aobject;
-        int i = aobject.length;
+        Object[] objects = providedObjects;
+        int i = providedObjects.length;
 
         for (int j = 0; j < i; ++j) {
-            Object object = aobject1[j];
+            Object object = objects[j];
 
             if (object instanceof ItemStack) {
                 arraylist.add(((ItemStack) object).cloneItemStack());
diff --git a/src/main/java/net/minecraft/server/DataWatcher.java b/src/main/java/net/minecraft/server/DataWatcher.java
index dec091e7..5a02cb7c 100644
--- a/src/main/java/net/minecraft/server/DataWatcher.java
+++ b/src/main/java/net/minecraft/server/DataWatcher.java
@@ -100,6 +100,16 @@ public class DataWatcher {
         return datawatcher_watchableobject;
     }
 
+    public DataWatcher clone() {
+        DataWatcher newWatcher = new DataWatcher(this.a);
+
+        for (int i : this.dataValues.keys()) {
+            newWatcher.a(i, ((WatchableObject) this.dataValues.get(i)).b());
+        }
+
+        return newWatcher;
+    }
+
     public Vector3f h(int i) {
         return (Vector3f) this.j(i).b();
     }
diff --git a/src/main/java/net/minecraft/server/DedicatedServer.java b/src/main/java/net/minecraft/server/DedicatedServer.java
index 088beb22..3dd80edf 100644
--- a/src/main/java/net/minecraft/server/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/DedicatedServer.java
@@ -1,10 +1,12 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.PotionSpigotConfig;
+
 import com.google.common.collect.Lists;
-import java.io.BufferedReader;
+
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStreamReader;
 import java.net.InetAddress;
 import java.net.Proxy;
 import java.util.Collections;
@@ -12,28 +14,25 @@ import java.util.List;
 import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-// CraftBukkit start
 import java.io.PrintStream;
-import org.apache.logging.log4j.Level;
 
+import org.apache.logging.log4j.Level;
 import org.bukkit.craftbukkit.LoggerOutputStream;
-import co.aikar.timings.SpigotTimings; // Spigot
 import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.craftbukkit.util.Waitable;
 import org.bukkit.event.server.RemoteServerCommandEvent;
-// CraftBukkit end
 
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList());
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
-    private EULA p;
     private boolean generateStructures;
     private WorldSettings.EnumGamemode r;
     private boolean s;
@@ -63,27 +62,23 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     protected boolean init() throws IOException {
         Thread thread = new Thread("Server console handler") {
             public void run() {
-                // CraftBukkit start
                 if (!org.bukkit.craftbukkit.Main.useConsole) {
                     return;
                 }
-                // CraftBukkit end
 
-                jline.console.ConsoleReader bufferedreader = reader; // CraftBukkit
+                jline.console.ConsoleReader bufferedreader = reader;
                 String s;
 
                 try {
-                    // CraftBukkit start - JLine disabling compatibility
                     while (!isStopped() && isRunning()) {
                         if (org.bukkit.craftbukkit.Main.useJline) {
                             s = bufferedreader.readLine(">", null);
                         } else {
                             s = bufferedreader.readLine();
                         }
-                        if (s != null && s.trim().length() > 0) { // Trim to filter lines which are just spaces
+                        if (s != null && s.trim().length() > 0) {
                             issueCommand(s, DedicatedServer.this);
                         }
-                        // CraftBukkit end
                     }
                 } catch (IOException ioexception) {
                     DedicatedServer.LOGGER.error("Exception handling console input", ioexception);
@@ -94,13 +89,17 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 
         // CraftBukkit start - TODO: handle command-line logging arguments
         java.util.logging.Logger global = java.util.logging.Logger.getLogger("");
+
         global.setUseParentHandlers(false);
+
         for (java.util.logging.Handler handler : global.getHandlers()) {
             global.removeHandler(handler);
         }
+
         global.addHandler(new org.bukkit.craftbukkit.util.ForwardLogHandler());
 
         final org.apache.logging.log4j.core.Logger logger = ((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger());
+
         for (org.apache.logging.log4j.core.Appender appender : logger.getAppenders().values()) {
             if (appender instanceof org.apache.logging.log4j.core.appender.ConsoleAppender) {
                 logger.removeAppender(appender);
@@ -115,212 +114,181 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 
         thread.setDaemon(true);
         thread.start();
+
         DedicatedServer.LOGGER.info("Starting minecraft server version 1.8.8");
-        if (Runtime.getRuntime().maxMemory() / 1024L / 1024L < 512L) {
-            DedicatedServer.LOGGER.warn("To start the server with more ram, launch it as \"java -Xmx1024M -Xms1024M -jar minecraft_server.jar\"");
+
+        this.propertyManager = new PropertyManager(this.options);
+
+        if (this.T()) {
+            this.setServerIp("127.0.0.1");
+        } else {
+            this.setOnlineMode(this.propertyManager.getBoolean("online-mode", true));
+            this.setServerIp(this.propertyManager.getString("server-ip", ""));
         }
 
-        DedicatedServer.LOGGER.info("Loading properties");
-        this.propertyManager = new PropertyManager(this.options); // CraftBukkit - CLI argument support
-        this.p = new EULA(new File("eula.txt"));
-        // Spigot Start
-        boolean eulaAgreed = Boolean.getBoolean( "com.mojang.eula.agree" );
-        if ( eulaAgreed )
-        {
-            System.err.println( "You have used the Spigot command line EULA agreement flag." );
-            System.err.println( "By using this setting you are indicating your agreement to Mojang's EULA (https://account.mojang.com/documents/minecraft_eula)." );
-            System.err.println( "If you do not agree to the above EULA please stop your server and remove this flag immediately." );
+        this.setSpawnAnimals(this.propertyManager.getBoolean("spawn-animals", false));
+        this.setSpawnNPCs(this.propertyManager.getBoolean("spawn-npcs", false));
+        this.setPVP(this.propertyManager.getBoolean("pvp", true));
+        this.setAllowFlight(this.propertyManager.getBoolean("allow-flight", false));
+        this.setResourcePack(this.propertyManager.getString("resource-pack", ""), this.propertyManager.getString("resource-pack-hash", ""));
+        this.setMotd(this.propertyManager.getString("motd", "A Minecraft Server"));
+        this.setForceGamemode(this.propertyManager.getBoolean("force-gamemode", false));
+        this.setIdleTimeout(this.propertyManager.getInt("player-idle-timeout", 0));
+
+        if (this.propertyManager.getInt("difficulty", 1) < 0) {
+            this.propertyManager.setProperty("difficulty", 0);
+        } else if (this.propertyManager.getInt("difficulty", 1) > 3) {
+            this.propertyManager.setProperty("difficulty", 3);
         }
-        // Spigot End
-        if (!this.p.a() && !eulaAgreed) { // Spigot
-            DedicatedServer.LOGGER.info("You need to agree to the EULA in order to run the server. Go to eula.txt for more info.");
-            this.p.b();
-            return false;
-        } else {
-            if (this.T()) {
-                this.c("127.0.0.1");
-            } else {
-                this.setOnlineMode(this.propertyManager.getBoolean("online-mode", true));
-                this.c(this.propertyManager.getString("server-ip", ""));
-            }
 
-            this.setSpawnAnimals(this.propertyManager.getBoolean("spawn-animals", true));
-            this.setSpawnNPCs(this.propertyManager.getBoolean("spawn-npcs", true));
-            this.setPVP(this.propertyManager.getBoolean("pvp", true));
-            this.setAllowFlight(this.propertyManager.getBoolean("allow-flight", false));
-            this.setResourcePack(this.propertyManager.getString("resource-pack", ""), this.propertyManager.getString("resource-pack-hash", ""));
-            this.setMotd(this.propertyManager.getString("motd", "A Minecraft Server"));
-            this.setForceGamemode(this.propertyManager.getBoolean("force-gamemode", false));
-            this.setIdleTimeout(this.propertyManager.getInt("player-idle-timeout", 0));
-            if (this.propertyManager.getInt("difficulty", 1) < 0) {
-                this.propertyManager.setProperty("difficulty", Integer.valueOf(0));
-            } else if (this.propertyManager.getInt("difficulty", 1) > 3) {
-                this.propertyManager.setProperty("difficulty", Integer.valueOf(3));
-            }
+        this.generateStructures = this.propertyManager.getBoolean("generate-structures", true);
+        int i = this.propertyManager.getInt("gamemode", WorldSettings.EnumGamemode.SURVIVAL.getId());
+        this.r = WorldSettings.a(i);
 
-            this.generateStructures = this.propertyManager.getBoolean("generate-structures", true);
-            int i = this.propertyManager.getInt("gamemode", WorldSettings.EnumGamemode.SURVIVAL.getId());
+        InetAddress inetaddress = null;
 
-            this.r = WorldSettings.a(i);
-            DedicatedServer.LOGGER.info("Default game type: " + this.r);
-            InetAddress inetaddress = null;
+        if (this.getServerIp().length() > 0) {
+            inetaddress = InetAddress.getByName(this.getServerIp());
+        }
 
-            if (this.getServerIp().length() > 0) {
-                inetaddress = InetAddress.getByName(this.getServerIp());
-            }
+        if (this.getPort() < 0) {
+            this.setPort(this.propertyManager.getInt("server-port", 25565));
+        }
 
-            if (this.R() < 0) {
-                this.setPort(this.propertyManager.getInt("server-port", 25565));
-            }
-            // Spigot start
-            this.a((PlayerList) (new DedicatedPlayerList(this)));
-            org.spigotmc.SpigotConfig.init((File) options.valueOf("spigot-settings"));
-            org.spigotmc.SpigotConfig.registerCommands();
-            // Spigot end
-            // PaperSpigot start
-            org.github.paperspigot.PaperSpigotConfig.init((File) options.valueOf("paper-settings"));
-            org.github.paperspigot.PaperSpigotConfig.registerCommands();
-            // PaperSpigot end
-
-            DedicatedServer.LOGGER.info("Generating keypair");
-            this.a(MinecraftEncryption.b());
-            DedicatedServer.LOGGER.info("Starting Minecraft server on " + (this.getServerIp().length() == 0 ? "*" : this.getServerIp()) + ":" + this.R());
+        // Register player list (which starts CraftServer)
+        this.a(new DedicatedPlayerList(this));
+
+        // Load Spigot settings
+        org.spigotmc.SpigotConfig.init((File) options.valueOf("spigot-settings"));
+        org.spigotmc.SpigotConfig.registerCommands();
+
+        // Load PaperSpigot settings
+        org.github.paperspigot.PaperSpigotConfig.init((File) options.valueOf("spigot-settings"));
+        org.github.paperspigot.PaperSpigotConfig.registerCommands();
+
+        // Load PaperSpigot
+        PotionSpigot.INSTANCE.setConfig(new PotionSpigotConfig());
+        PotionSpigot.INSTANCE.registerCommands();
+
+        DedicatedServer.LOGGER.info("* Allocated memory: " + (Runtime.getRuntime().maxMemory() / 1024L / 1024L));
+        DedicatedServer.LOGGER.info("* Online Mode: " + this.getOnlineMode());
+        DedicatedServer.LOGGER.info("* Server Address: " + this.getServerIp() + ":" + this.getPort());
+        DedicatedServer.LOGGER.info("* View Distance: " + this.getPlayerList().getCserver().getViewDistance());
+
+        this.a(MinecraftEncryption.b());
 
         if (!org.spigotmc.SpigotConfig.lateBind) {
             try {
-                this.aq().a(inetaddress, this.R());
+                this.aq().a(inetaddress, this.getPort());
             } catch (IOException ioexception) {
-                DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
-                DedicatedServer.LOGGER.warn("The exception was: {}", new Object[] { ioexception.toString()});
+                DedicatedServer.LOGGER.warn("** FAILED TO BIND PORT **");
+                DedicatedServer.LOGGER.warn("The exception was: {}", ioexception.toString());
                 DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
                 return false;
             }
         }
 
-            // Spigot Start - Move DedicatedPlayerList up and bring plugin loading from CraftServer to here
-            // this.a((PlayerList) (new DedicatedPlayerList(this))); // CraftBukkit
-            server.loadPlugins();
-            server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
-            // Spigot End
-
-            if (!this.getOnlineMode()) {
-                DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
-                DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
-                // Spigot start
-                if (org.spigotmc.SpigotConfig.bungee) {
-                    DedicatedServer.LOGGER.warn("Whilst this makes it possible to use BungeeCord, unless access to your server is properly restricted, it also opens up the ability for hackers to connect with any username they choose.");
-                    DedicatedServer.LOGGER.warn("Please see http://www.spigotmc.org/wiki/firewall-guide/ for further information.");
-                } else {
-                    DedicatedServer.LOGGER.warn("While this makes the game possible to play without internet access, it also opens up the ability for hackers to connect with any username they choose.");
-                }
-                // Spigot end
-                DedicatedServer.LOGGER.warn("To change this, set \"online-mode\" to \"true\" in the server.properties file.");
-            }
+        server.loadPlugins();
+        server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.STARTUP);
 
-            if (this.aR()) {
-                this.getUserCache().c();
-            }
+        if (this.aR()) {
+            this.getUserCache().c();
+        }
 
-            if (!NameReferencingFileConverter.a(this.propertyManager)) {
-                return false;
-            } else {
-                this.convertable = new WorldLoaderServer(server.getWorldContainer()); // CraftBukkit - moved from MinecraftServer constructor
-                long j = System.nanoTime();
+        if (!NameReferencingFileConverter.a(this.propertyManager)) {
+            return false;
+        } else {
+            this.convertable = new WorldLoaderServer(server.getWorldContainer());
+            long j = System.nanoTime();
 
-                if (this.U() == null) {
-                    this.setWorld(this.propertyManager.getString("level-name", "world"));
-                }
+            if (this.U() == null) {
+                this.setWorld(this.propertyManager.getString("level-name", "world"));
+            }
 
-                String s = this.propertyManager.getString("level-seed", "");
-                String s1 = this.propertyManager.getString("level-type", "DEFAULT");
-                String s2 = this.propertyManager.getString("generator-settings", "");
-                long k = (new Random()).nextLong();
+            final String levelSeed = this.propertyManager.getString("level-seed", "");
+            final String levelType = this.propertyManager.getString("level-type", "DEFAULT");
+            final String generatorSettings = this.propertyManager.getString("generator-settings", "");
+            long actualSeed = (new Random()).nextLong();
 
-                if (s.length() > 0) {
-                    try {
-                        long l = Long.parseLong(s);
+            if (levelSeed.length() > 0) {
+                try {
+                    long l = Long.parseLong(levelSeed);
 
-                        if (l != 0L) {
-                            k = l;
-                        }
-                    } catch (NumberFormatException numberformatexception) {
-                        k = (long) s.hashCode();
+                    if (l != 0L) {
+                        actualSeed = l;
                     }
+                } catch (NumberFormatException numberformatexception) {
+                    actualSeed = (long) levelSeed.hashCode();
                 }
+            }
 
-                WorldType worldtype = WorldType.getType(s1);
-
-                if (worldtype == null) {
-                    worldtype = WorldType.NORMAL;
-                }
-
-                this.aB();
-                this.getEnableCommandBlock();
-                this.p();
-                this.getSnooperEnabled();
-                this.aK();
-                this.c(this.propertyManager.getInt("max-build-height", 256));
-                this.c((this.getMaxBuildHeight() + 8) / 16 * 16);
-                this.c(MathHelper.clamp(this.getMaxBuildHeight(), 64, 256));
-                this.propertyManager.setProperty("max-build-height", Integer.valueOf(this.getMaxBuildHeight()));
-                DedicatedServer.LOGGER.info("Preparing level \"" + this.U() + "\"");
-                this.a(this.U(), this.U(), k, worldtype, s2);
-                long i1 = System.nanoTime() - j;
-                String s3 = String.format("%.3fs", new Object[] { Double.valueOf((double) i1 / 1.0E9D)});
-
-                DedicatedServer.LOGGER.info("Done (" + s3 + ")! For help, type \"help\" or \"?\"");
-                if (this.propertyManager.getBoolean("enable-query", false)) {
-                    DedicatedServer.LOGGER.info("Starting GS4 status listener");
-                    this.m = new RemoteStatusListener(this);
-                    this.m.a();
-                }
+            WorldType worldType = WorldType.getType(levelType);
 
-                if (this.propertyManager.getBoolean("enable-rcon", false)) {
-                    DedicatedServer.LOGGER.info("Starting remote control listener");
-                    this.n = new RemoteControlListener(this);
-                    this.n.a();
-                    this.remoteConsole = new org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender(); // CraftBukkit
-                }
+            if (worldType == null) {
+                worldType = WorldType.NORMAL;
+            }
 
-                // CraftBukkit start
-                if (this.server.getBukkitSpawnRadius() > -1) {
-                    DedicatedServer.LOGGER.info("'settings.spawn-radius' in bukkit.yml has been moved to 'spawn-protection' in server.properties. I will move your config for you.");
-                    this.propertyManager.properties.remove("spawn-protection");
-                    this.propertyManager.getInt("spawn-protection", this.server.getBukkitSpawnRadius());
-                    this.server.removeBukkitSpawnRadius();
-                    this.propertyManager.savePropertiesFile();
-                }
-                // CraftBukkit end
+            this.aB();
+            this.getEnableCommandBlock();
+            this.p();
+            this.getSnooperEnabled();
+            this.aK();
+            this.setMaxBuildHeight(this.propertyManager.getInt("max-build-height", 256));
+            this.setMaxBuildHeight((this.getMaxBuildHeight() + 8) / 16 * 16);
+            this.setMaxBuildHeight(MathHelper.clamp(this.getMaxBuildHeight(), 64, 256));
+            this.propertyManager.setProperty("max-build-height", this.getMaxBuildHeight());
+            this.a(this.U(), this.U(), actualSeed, worldType, generatorSettings);
+
+            long i1 = System.nanoTime() - j;
+            String s3 = String.format("%.3fs", (double) i1 / 1.0E9D);
+
+            DedicatedServer.LOGGER.info("Finished loading the server in " + s3 + "...");
+
+            if (this.propertyManager.getBoolean("enable-query", false)) {
+                DedicatedServer.LOGGER.info("* Enabled GS4 Query");
+                this.m = new RemoteStatusListener(this);
+                this.m.a();
+            }
 
-        if (org.spigotmc.SpigotConfig.lateBind) {
-            try {
-                this.aq().a(inetaddress, this.R());
-            } catch (IOException ioexception) {
-                DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
-                DedicatedServer.LOGGER.warn("The exception was: {}", new Object[] { ioexception.toString()});
-                DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
-                return false;
+            if (this.propertyManager.getBoolean("enable-rcon", false)) {
+                DedicatedServer.LOGGER.info("* Enabled RCON");
+                this.n = new RemoteControlListener(this);
+                this.n.a();
+                this.remoteConsole = new org.bukkit.craftbukkit.command.CraftRemoteConsoleCommandSender();
             }
-        }
 
-                if (false && this.aS() > 0L) {  // Spigot - disable
-                    Thread thread1 = new Thread(new ThreadWatchdog(this));
+            if (this.server.getBukkitSpawnRadius() > -1) {
+                this.propertyManager.properties.remove("spawn-protection");
+                this.propertyManager.getInt("spawn-protection", this.server.getBukkitSpawnRadius());
+                this.server.removeBukkitSpawnRadius();
+                this.propertyManager.savePropertiesFile();
+            }
 
-                    thread1.setName("Server Watchdog");
-                    thread1.setDaemon(true);
-                    thread1.start();
+            if (org.spigotmc.SpigotConfig.lateBind) {
+                try {
+                    this.aq().a(inetaddress, this.getPort());
+                } catch (IOException ioexception) {
+                    DedicatedServer.LOGGER.warn("**** FAILED TO BIND TO PORT!");
+                    DedicatedServer.LOGGER.warn("The exception was: {}", ioexception.toString());
+                    DedicatedServer.LOGGER.warn("Perhaps a server is already running on that port?");
+                    return false;
                 }
+            }
 
-                return true;
+            if (false && this.aS() > 0L) {
+                Thread watchdogThread = new Thread(new ThreadWatchdog(this));
+                watchdogThread.setName("Server Watchdog");
+                watchdogThread.setDaemon(true);
+                watchdogThread.start();
             }
+
+            return true;
         }
     }
 
-    // CraftBukkit start
     public PropertyManager getPropertyManager() {
         return this.propertyManager;
     }
-    // CraftBukkit end
 
     public void setGamemode(WorldSettings.EnumGamemode worldsettings_enumgamemode) {
         super.setGamemode(worldsettings_enumgamemode);
@@ -343,30 +311,27 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         return this.propertyManager.getBoolean("hardcore", false);
     }
 
-    protected void a(CrashReport crashreport) {}
+    protected void a(CrashReport crashreport) {
+    }
 
     public CrashReport b(CrashReport crashreport) {
         crashreport = super.b(crashreport);
-        crashreport.g().a("Is Modded", new Callable() {
-            public String a() throws Exception {
-                String s = DedicatedServer.this.getServerModName();
 
+        crashreport.g().a("Is Modded", new Callable<String>() {
+            @Override
+            public String call() throws Exception {
+                String s = DedicatedServer.this.getServerModName();
                 return !s.equals("vanilla") ? "Definitely; Server brand changed to \'" + s + "\'" : "Unknown (can\'t tell)";
             }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
         });
-        crashreport.g().a("Type", new Callable() {
-            public String a() throws Exception {
-                return "Dedicated Server (map_server.txt)";
-            }
 
-            public Object call() throws Exception {
-                return this.a();
+        crashreport.g().a("Type", new Callable<String>() {
+            @Override
+            public String call() throws Exception {
+                return "Dedicated Server (map_server.txt)";
             }
         });
+
         return crashreport;
     }
 
@@ -374,8 +339,8 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
         System.exit(0);
     }
 
-    public void B() { // CraftBukkit - fix decompile error
-        super.B();
+    public void tickServer() { // CraftBukkit - fix decompile error
+        super.tickServer();
         this.aO();
     }
 
@@ -388,8 +353,9 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(this.aP().getHasWhitelist()));
-        mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(this.aP().getWhitelisted().length));
+        mojangstatisticsgenerator.a("whitelist_enabled", this.aP().getHasWhitelist());
+        mojangstatisticsgenerator.a("whitelist_count", this.aP().getWhitelisted().length);
+
         super.a(mojangstatisticsgenerator);
     }
 
@@ -402,22 +368,21 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public void aO() {
-        SpigotTimings.serverCommandTimer.startTiming(); // Spigot
         while (!this.l.isEmpty()) {
-            ServerCommand servercommand = (ServerCommand) this.l.remove(0);
+            ServerCommand servercommand = this.l.remove(0);
 
-            // CraftBukkit start - ServerCommand for preprocessing
             ServerCommandEvent event = new ServerCommandEvent(console, servercommand.command);
+
             server.getPluginManager().callEvent(event);
-            if (event.isCancelled()) continue;
+
+            if (event.isCancelled()) {
+                continue;
+            }
+
             servercommand = new ServerCommand(event.getCommand(), servercommand.source);
 
-            // this.getCommandHandler().a(servercommand.source, servercommand.command); // Called in dispatchServerCommand
             server.dispatchServerCommand(console, servercommand);
-            // CraftBukkit end
         }
-
-        SpigotTimings.serverCommandTimer.stopTiming(); // Spigot
     }
 
     public boolean ae() {
@@ -504,7 +469,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
 
     public void setIdleTimeout(int i) {
         super.setIdleTimeout(i);
-        this.propertyManager.setProperty("player-idle-timeout", Integer.valueOf(i));
+        this.propertyManager.setProperty("player-idle-timeout", i);
         this.a();
     }
 
@@ -517,7 +482,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     public boolean aB() {
-        return this.propertyManager.getBoolean("announce-player-achievements", true);
+        return this.propertyManager.getBoolean("announce-player-achievements", false);
     }
 
     public int aI() {
@@ -537,7 +502,6 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
     }
 
     protected boolean aR() {
-        server.getLogger().info( "**** Beginning UUID conversion, this may take A LONG time ****"); // Spigot, let the user know whats up!
         boolean flag = false;
 
         int i;
@@ -548,7 +512,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag = NameReferencingFileConverter.a((MinecraftServer) this);
+            flag = NameReferencingFileConverter.a(this);
         }
 
         boolean flag1 = false;
@@ -559,7 +523,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag1 = NameReferencingFileConverter.b((MinecraftServer) this);
+            flag1 = NameReferencingFileConverter.b(this);
         }
 
         boolean flag2 = false;
@@ -570,7 +534,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag2 = NameReferencingFileConverter.c((MinecraftServer) this);
+            flag2 = NameReferencingFileConverter.c(this);
         }
 
         boolean flag3 = false;
@@ -581,7 +545,7 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 this.aU();
             }
 
-            flag3 = NameReferencingFileConverter.d((MinecraftServer) this);
+            flag3 = NameReferencingFileConverter.d(this);
         }
 
         boolean flag4 = false;
@@ -655,7 +619,9 @@ public class DedicatedServer extends MinecraftServer implements IMinecraftServer
                 return RemoteControlCommandListener.getInstance().j();
             }
         };
+
         processQueue.add(waitable);
+
         try {
             return waitable.get();
         } catch (java.util.concurrent.ExecutionException e) {
diff --git a/src/main/java/net/minecraft/server/DispenserRegistry.java b/src/main/java/net/minecraft/server/DispenserRegistry.java
index cc7a1e31..348a3d59 100644
--- a/src/main/java/net/minecraft/server/DispenserRegistry.java
+++ b/src/main/java/net/minecraft/server/DispenserRegistry.java
@@ -648,6 +648,7 @@ public class DispenserRegistry {
     public static void c() {
         if (!DispenserRegistry.b) {
             DispenserRegistry.b = true;
+
             if (DispenserRegistry.c.isDebugEnabled()) {
                 d();
             }
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index 2da303fe..f27057a7 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -1,1975 +1,1964 @@
 package net.minecraft.server;
 
+import org.potionspigot.util.OptimizedRemoveUtil;
+import co.aikar.timings.SpigotTimings;
+import co.aikar.timings.Timing;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
-// CraftBukkit start
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.Server;
 import org.bukkit.TravelAgent;
 import org.bukkit.block.BlockFace;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.Hanging;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Painting;
 import org.bukkit.entity.Vehicle;
-import co.aikar.timings.SpigotTimings; // Spigot
-import co.aikar.timings.Timing; // Spigot
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.painting.PaintingBreakByEntityEvent;
 import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
 import org.bukkit.event.vehicle.VehicleEnterEvent;
 import org.bukkit.event.vehicle.VehicleExitEvent;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.entity.CraftEntity;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.event.entity.EntityCombustEvent;
-import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
-// CraftBukkit end
-
-// PaperSpigot start
 import org.spigotmc.event.entity.EntityDismountEvent;
-// PaperSpigot end
-
-public abstract class Entity implements ICommandListener {
-
-    // CraftBukkit start
-    private static final int CURRENT_LEVEL = 2;
-    static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
-        return tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
-    }
-    // CraftBukikt end
-
-    private static final AxisAlignedBB a = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
-    private static int entityCount;
-    private int id;
-    public double j;
-    public boolean k;
-    public Entity passenger;
-    public Entity vehicle;
-    public boolean attachedToPlayer;
-    public World world;
-    public double lastX;
-    public double lastY;
-    public double lastZ;
-    public double locX;
-    public double locY;
-    public double locZ;
-    public double motX;
-    public double motY;
-    public double motZ;
-    public float yaw;
-    public float pitch;
-    public float lastYaw;
-    public float lastPitch;
-    private AxisAlignedBB boundingBox;
-    public boolean onGround;
-    public boolean positionChanged;
-    public boolean E;
-    public boolean F;
-    public boolean velocityChanged;
-    protected boolean H;
-    private boolean g;
-    public boolean dead;
-    public float width;
-    public float length;
-    public float L;
-    public float M;
-    public float N;
-    public float fallDistance;
-    private int h;
-    public double P;
-    public double Q;
-    public double R;
-    public float S;
-    public boolean noclip;
-    public float U;
-    protected Random random;
-    public int ticksLived;
-    public int maxFireTicks;
-    public int fireTicks;
-    public boolean inWater; // Spigot - protected -> public // PAIL
-    public int noDamageTicks;
-    protected boolean justCreated;
-    protected boolean fireProof;
-    protected DataWatcher datawatcher;
-    private double ar;
-    private double as;
-    public boolean ad;
-    // PaperSpigot start - EAR: Fix bug with teleporting entities
-    public boolean isAddedToChunk() {
-        int chunkX = MathHelper.floor(locX / 16.0D);
-        int chunkY = MathHelper.floor(locY / 16.0D);
-        int chunkZ = MathHelper.floor(locZ / 16.0D);
-
-        return ad && getChunkX() == chunkX && getChunkY() == chunkY || getChunkZ() == chunkZ;
-    }
-    public int ae; public int getChunkX() { return ae; } // PAIL
-    public int af; public int getChunkY() { return af; } // PAIL
-    public int ag; public int getChunkZ() { return ag; } // PAIL
-    // PaperSpigot end
-    public boolean ah;
-    public boolean ai;
-    public int portalCooldown;
-    protected boolean ak;
-    protected int al;
-    public int dimension;
-    protected BlockPosition an;
-    protected Vec3D ao;
-    protected EnumDirection ap;
-    private boolean invulnerable;
-    protected UUID uniqueID;
-    private final CommandObjectiveExecutor au;
-    public boolean valid; // CraftBukkit
-    public org.bukkit.projectiles.ProjectileSource projectileSource; // CraftBukkit - For projectiles only
-    public boolean forceExplosionKnockback; // CraftBukkit - SPIGOT-949
-    public boolean inUnloadedChunk = false; // PaperSpigot - Remove entities in unloaded chunks
-    public boolean loadChunks = false; // PaperSpigot - Entities can load chunks they move through and keep them loaded
-
-    // Spigot start
-    public Timing tickTimer = SpigotTimings.getEntityTimings(this); // Spigot
-    public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
-    public final boolean defaultActivationState;
-    public long activatedTick = Integer.MIN_VALUE;
-    public boolean fromMobSpawner;
-    public void inactiveTick() { }
-    // Spigot end
-
-    public int getId() {
-        return this.id;
-    }
-
-    public void d(int i) {
-        this.id = i;
-    }
-
-    public void G() {
-        this.die();
-    }
-
-    public Entity(World world) {
-        this.id = Entity.entityCount++;
-        this.j = 1.0D;
-        this.boundingBox = Entity.a;
-        this.width = 0.6F;
-        this.length = 1.8F;
-        this.h = 1;
-        this.random = new Random();
-        this.maxFireTicks = 1;
-        this.justCreated = true;
-        this.uniqueID = MathHelper.a(this.random);
-        this.au = new CommandObjectiveExecutor();
-        this.world = world;
-        this.setPosition(0.0D, 0.0D, 0.0D);
-        if (world != null) {
-            this.dimension = world.worldProvider.getDimension();
-            // Spigot start
-            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
-        } else {
-            this.defaultActivationState = false;
-        }
-        // Spigot end
-
-        this.datawatcher = new DataWatcher(this);
-        this.datawatcher.a(0, Byte.valueOf((byte) 0));
-        this.datawatcher.a(1, Short.valueOf((short) 300));
-        this.datawatcher.a(3, Byte.valueOf((byte) 0));
-        this.datawatcher.a(2, "");
-        this.datawatcher.a(4, Byte.valueOf((byte) 0));
-        this.h();
-    }
-
-    protected abstract void h();
-
-    public DataWatcher getDataWatcher() {
-        return this.datawatcher;
-    }
-
-    public boolean equals(Object object) {
-        return object instanceof Entity ? ((Entity) object).id == this.id : false;
-    }
-
-    public int hashCode() {
-        return this.id;
-    }
-
-    public void die() {
-        this.dead = true;
-    }
-
-    public void setSize(float f, float f1) {
-        if (f != this.width || f1 != this.length) {
-            float f2 = this.width;
-
-            this.width = f;
-            this.length = f1;
-            this.a(new AxisAlignedBB(this.getBoundingBox().a, this.getBoundingBox().b, this.getBoundingBox().c, this.getBoundingBox().a + (double) this.width, this.getBoundingBox().b + (double) this.length, this.getBoundingBox().c + (double) this.width));
-            if (this.width > f2 && !this.justCreated && !this.world.isClientSide) {
-                this.move((double) (f2 - this.width), 0.0D, (double) (f2 - this.width));
-            }
-        }
-
-    }
-
-    protected void setYawPitch(float f, float f1) {
-        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
-        if (Float.isNaN(f)) {
-            f = 0;
-        }
-
-        if (f == Float.POSITIVE_INFINITY || f == Float.NEGATIVE_INFINITY) {
-            if (this instanceof EntityPlayer) {
-                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
-                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); //Spigot "Nope" -> Descriptive reason
-            }
-            f = 0;
-        }
-
-        // pitch was sometimes set to NaN, so we need to set it back to 0
-        if (Float.isNaN(f1)) {
-            f1 = 0;
-        }
-
-        if (f1 == Float.POSITIVE_INFINITY || f1 == Float.NEGATIVE_INFINITY) {
-            if (this instanceof EntityPlayer) {
-                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
-                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); //Spigot "Nope" -> Descriptive reason
-            }
-            f1 = 0;
-        }
-        // CraftBukkit end
-
-        this.yaw = f % 360.0F;
-        this.pitch = f1 % 360.0F;
-    }
-
-    public void setPosition(double d0, double d1, double d2) {
-        this.locX = d0;
-        this.locY = d1;
-        this.locZ = d2;
-        float f = this.width / 2.0F;
-        float f1 = this.length;
-
-        this.a(new AxisAlignedBB(d0 - (double) f, d1, d2 - (double) f, d0 + (double) f, d1 + (double) f1, d2 + (double) f));
-    }
-
-    public void t_() {
-        this.K();
-    }
-
-    /**
-     * PaperSpigot - Checks if the feature is enabled and the entity is above the nether world bedrock height
-     */
-    private boolean paperNetherCheck() {
-        return this.world.paperSpigotConfig.netherVoidTopDamage && this.world.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this.locY >= 128.0D;
-    }
-
-    public void K() {
-        this.world.methodProfiler.a("entityBaseTick");
-        if (this.vehicle != null && this.vehicle.dead) {
-            this.vehicle = null;
-        }
-
-        this.L = this.M;
-        this.lastX = this.locX;
-        this.lastY = this.locY;
-        this.lastZ = this.locZ;
-        this.lastPitch = this.pitch;
-        this.lastYaw = this.yaw;
-        if (!this.world.isClientSide && this.world instanceof WorldServer) {
-            this.world.methodProfiler.a("portal");
-            MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
-            int i = this.L();
-
-            if (this.ak) {
-                if (true || minecraftserver.getAllowNether()) { // CraftBukkit
-                    if (this.vehicle == null && this.al++ >= i) {
-                        this.al = i;
-                        this.portalCooldown = this.aq();
-                        byte b0;
-
-                        if (this.world.worldProvider.getDimension() == -1) {
-                            b0 = 0;
-                        } else {
-                            b0 = -1;
-                        }
-
-                        this.c(b0);
-                    }
-
-                    this.ak = false;
-                }
-            } else {
-                if (this.al > 0) {
-                    this.al -= 4;
-                }
-
-                if (this.al < 0) {
-                    this.al = 0;
-                }
-            }
-
-            if (this.portalCooldown > 0) {
-                --this.portalCooldown;
-            }
-
-            this.world.methodProfiler.b();
-        }
-
-        this.Y();
-        this.W();
-        if (this.world.isClientSide) {
-            this.fireTicks = 0;
-        } else if (this.fireTicks > 0) {
-            if (this.fireProof) {
-                this.fireTicks -= 4;
-                if (this.fireTicks < 0) {
-                    this.fireTicks = 0;
-                }
-            } else {
-                if (this.fireTicks % 20 == 0) {
-                    this.damageEntity(DamageSource.BURN, 1.0F);
-                }
-
-                --this.fireTicks;
-            }
-        }
-
-        if (this.ab()) {
-            this.burnFromLava();
-            this.fallDistance *= 0.5F;
-        }
-
-        if (this.locY < -64.0D || paperNetherCheck()) { // PaperSpigot - Configurable top-of-nether void damage
-            this.O();
-        }
-
-        if (!this.world.isClientSide) {
-            this.b(0, this.fireTicks > 0);
-        }
-
-        this.justCreated = false;
-        this.world.methodProfiler.b();
-    }
-
-    public int L() {
-        return 0;
-    }
-
-    protected void burnFromLava() {
-        if (!this.fireProof) {
-            this.damageEntity(DamageSource.LAVA, 4.0F);
-
-            // CraftBukkit start - Fallen in lava TODO: this event spams!
-            if (this instanceof EntityLiving) {
-                if (fireTicks <= 0) {
-                    // not on fire yet
-                    // TODO: shouldn't be sending null for the block
-                    org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
-                    org.bukkit.entity.Entity damagee = this.getBukkitEntity();
-                    EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
-                    this.world.getServer().getPluginManager().callEvent(combustEvent);
-
-                    if (!combustEvent.isCancelled()) {
-                        this.setOnFire(combustEvent.getDuration());
-                    }
-                } else {
-                    // This will be called every single tick the entity is in lava, so don't throw an event
-                    this.setOnFire(15);
-                }
-                return;
-            }
-            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
-            this.setOnFire(15);
-        }
-    }
-
-    public void setOnFire(int i) {
-        int j = i * 20;
-
-        j = EnchantmentProtection.a(this, j);
-        if (this.fireTicks < j) {
-            this.fireTicks = j;
-        }
-
-    }
-
-    public void extinguish() {
-        this.fireTicks = 0;
-    }
-
-    protected void O() {
-        this.die();
-    }
-
-    public boolean c(double d0, double d1, double d2) {
-        AxisAlignedBB axisalignedbb = this.getBoundingBox().c(d0, d1, d2);
-
-        return this.b(axisalignedbb);
-    }
-
-    private boolean b(AxisAlignedBB axisalignedbb) {
-        return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
-    }
-
-    /**
-     * PaperSpigot - Load surrounding chunks the entity is moving through
-     */
-    public void loadChunks() {
-        for (int cx = (int) locX >> 4; cx <= (int) (locX + motX) >> 4; ++cx) {
-            for (int cz = (int) locZ >> 4; cz <= (int) (locZ + motZ) >> 4; ++cz) {
-                ((ChunkProviderServer) world.chunkProvider).getChunkAt(cx, cz);
-            }
-        }
-    }
-
-
-    public void move(double d0, double d1, double d2) {
-        if (this.loadChunks) loadChunks(); // PaperSpigot - Load chunks
-        if (this.noclip) {
-            this.a(this.getBoundingBox().c(d0, d1, d2));
-            this.recalcPosition();
-        } else {
-            // CraftBukkit start - Don't do anything if we aren't moving
-            // We need to do this regardless of whether or not we are moving thanks to portals
-            try {
-                this.checkBlockCollisions();
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
-
-                this.appendEntityCrashDetails(crashreportsystemdetails);
-                throw new ReportedException(crashreport);
-            }
-            // Check if we're moving
-            if (d0 == 0 && d1 == 0 && d2 == 0 && this.vehicle == null && this.passenger == null) {
-                return;
-            }
-            // CraftBukkit end
-            this.world.methodProfiler.a("move");
-            double d3 = this.locX;
-            double d4 = this.locY;
-            double d5 = this.locZ;
-
-            if (this.H) {
-                this.H = false;
-                d0 *= 0.25D;
-                d1 *= 0.05000000074505806D;
-                d2 *= 0.25D;
-                this.motX = 0.0D;
-                this.motY = 0.0D;
-                this.motZ = 0.0D;
-            }
-
-            double d6 = d0;
-            double d7 = d1;
-            double d8 = d2;
-            boolean flag = this.onGround && this.isSneaking() && this instanceof EntityHuman;
-
-            if (flag) {
-                double d9;
-
-                for (d9 = 0.05D; d0 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, 0.0D)).isEmpty(); d6 = d0) {
-                    if (d0 < d9 && d0 >= -d9) {
-                        d0 = 0.0D;
-                    } else if (d0 > 0.0D) {
-                        d0 -= d9;
-                    } else {
-                        d0 += d9;
-                    }
-                }
-
-                for (; d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(0.0D, -1.0D, d2)).isEmpty(); d8 = d2) {
-                    if (d2 < d9 && d2 >= -d9) {
-                        d2 = 0.0D;
-                    } else if (d2 > 0.0D) {
-                        d2 -= d9;
-                    } else {
-                        d2 += d9;
-                    }
-                }
-
-                for (; d0 != 0.0D && d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, d2)).isEmpty(); d8 = d2) {
-                    if (d0 < d9 && d0 >= -d9) {
-                        d0 = 0.0D;
-                    } else if (d0 > 0.0D) {
-                        d0 -= d9;
-                    } else {
-                        d0 += d9;
-                    }
-
-                    d6 = d0;
-                    if (d2 < d9 && d2 >= -d9) {
-                        d2 = 0.0D;
-                    } else if (d2 > 0.0D) {
-                        d2 -= d9;
-                    } else {
-                        d2 += d9;
-                    }
-                }
-            }
-
-            List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
-            AxisAlignedBB axisalignedbb = this.getBoundingBox();
-
-            AxisAlignedBB axisalignedbb1;
-
-            for (Iterator iterator = list.iterator(); iterator.hasNext(); d1 = axisalignedbb1.b(this.getBoundingBox(), d1)) {
-                axisalignedbb1 = (AxisAlignedBB) iterator.next();
-            }
-
-            this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
-            boolean flag1 = this.onGround || d7 != d1 && d7 < 0.0D;
-
-            AxisAlignedBB axisalignedbb2;
-            Iterator iterator1;
-
-            for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
-                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
-            }
-
-            this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
-
-            for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
-                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
-            }
-
-            this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
-            if (this.S > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
-                double d10 = d0;
-                double d11 = d1;
-                double d12 = d2;
-                AxisAlignedBB axisalignedbb3 = this.getBoundingBox();
-
-                this.a(axisalignedbb);
-                d1 = (double) this.S;
-                List list1 = this.world.getCubes(this, this.getBoundingBox().a(d6, d1, d8));
-                AxisAlignedBB axisalignedbb4 = this.getBoundingBox();
-                AxisAlignedBB axisalignedbb5 = axisalignedbb4.a(d6, 0.0D, d8);
-                double d13 = d1;
-
-                AxisAlignedBB axisalignedbb6;
-
-                for (Iterator iterator2 = list1.iterator(); iterator2.hasNext(); d13 = axisalignedbb6.b(axisalignedbb5, d13)) {
-                    axisalignedbb6 = (AxisAlignedBB) iterator2.next();
-                }
-
-                axisalignedbb4 = axisalignedbb4.c(0.0D, d13, 0.0D);
-                double d14 = d6;
-
-                AxisAlignedBB axisalignedbb7;
-
-                for (Iterator iterator3 = list1.iterator(); iterator3.hasNext(); d14 = axisalignedbb7.a(axisalignedbb4, d14)) {
-                    axisalignedbb7 = (AxisAlignedBB) iterator3.next();
-                }
-
-                axisalignedbb4 = axisalignedbb4.c(d14, 0.0D, 0.0D);
-                double d15 = d8;
-
-                AxisAlignedBB axisalignedbb8;
-
-                for (Iterator iterator4 = list1.iterator(); iterator4.hasNext(); d15 = axisalignedbb8.c(axisalignedbb4, d15)) {
-                    axisalignedbb8 = (AxisAlignedBB) iterator4.next();
-                }
-
-                axisalignedbb4 = axisalignedbb4.c(0.0D, 0.0D, d15);
-                AxisAlignedBB axisalignedbb9 = this.getBoundingBox();
-                double d16 = d1;
-
-                AxisAlignedBB axisalignedbb10;
-
-                for (Iterator iterator5 = list1.iterator(); iterator5.hasNext(); d16 = axisalignedbb10.b(axisalignedbb9, d16)) {
-                    axisalignedbb10 = (AxisAlignedBB) iterator5.next();
-                }
-
-                axisalignedbb9 = axisalignedbb9.c(0.0D, d16, 0.0D);
-                double d17 = d6;
-
-                AxisAlignedBB axisalignedbb11;
-
-                for (Iterator iterator6 = list1.iterator(); iterator6.hasNext(); d17 = axisalignedbb11.a(axisalignedbb9, d17)) {
-                    axisalignedbb11 = (AxisAlignedBB) iterator6.next();
-                }
-
-                axisalignedbb9 = axisalignedbb9.c(d17, 0.0D, 0.0D);
-                double d18 = d8;
-
-                AxisAlignedBB axisalignedbb12;
-
-                for (Iterator iterator7 = list1.iterator(); iterator7.hasNext(); d18 = axisalignedbb12.c(axisalignedbb9, d18)) {
-                    axisalignedbb12 = (AxisAlignedBB) iterator7.next();
-                }
-
-                axisalignedbb9 = axisalignedbb9.c(0.0D, 0.0D, d18);
-                double d19 = d14 * d14 + d15 * d15;
-                double d20 = d17 * d17 + d18 * d18;
-
-                if (d19 > d20) {
-                    d0 = d14;
-                    d2 = d15;
-                    d1 = -d13;
-                    this.a(axisalignedbb4);
-                } else {
-                    d0 = d17;
-                    d2 = d18;
-                    d1 = -d16;
-                    this.a(axisalignedbb9);
-                }
-
-                AxisAlignedBB axisalignedbb13;
-
-                for (Iterator iterator8 = list1.iterator(); iterator8.hasNext(); d1 = axisalignedbb13.b(this.getBoundingBox(), d1)) {
-                    axisalignedbb13 = (AxisAlignedBB) iterator8.next();
-                }
-
-                this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
-                if (d10 * d10 + d12 * d12 >= d0 * d0 + d2 * d2) {
-                    d0 = d10;
-                    d1 = d11;
-                    d2 = d12;
-                    this.a(axisalignedbb3);
-                }
-            }
-
-            this.world.methodProfiler.b();
-            this.world.methodProfiler.a("rest");
-            this.recalcPosition();
-            this.positionChanged = d6 != d0 || d8 != d2;
-            this.E = d7 != d1;
-            this.onGround = this.E && d7 < 0.0D;
-            this.F = this.positionChanged || this.E;
-            int i = MathHelper.floor(this.locX);
-            int j = MathHelper.floor(this.locY - 0.20000000298023224D);
-            int k = MathHelper.floor(this.locZ);
-            BlockPosition blockposition = new BlockPosition(i, j, k);
-            Block block = this.world.getType(blockposition).getBlock();
-
-            if (block.getMaterial() == Material.AIR) {
-                Block block1 = this.world.getType(blockposition.down()).getBlock();
-
-                if (block1 instanceof BlockFence || block1 instanceof BlockCobbleWall || block1 instanceof BlockFenceGate) {
-                    block = block1;
-                    blockposition = blockposition.down();
-                }
-            }
-
-            this.a(d1, this.onGround, block, blockposition);
-            if (d6 != d0) {
-                this.motX = 0.0D;
-            }
-
-            if (d8 != d2) {
-                this.motZ = 0.0D;
-            }
-
-            if (d7 != d1) {
-                block.a(this.world, this);
-            }
-
-            // CraftBukkit start
-            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
-                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
-                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX), MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
-
-                if (d6 > d0) {
-                    bl = bl.getRelative(BlockFace.EAST);
-                } else if (d6 < d0) {
-                    bl = bl.getRelative(BlockFace.WEST);
-                } else if (d8 > d2) {
-                    bl = bl.getRelative(BlockFace.SOUTH);
-                } else if (d8 < d2) {
-                    bl = bl.getRelative(BlockFace.NORTH);
-                }
-
-                VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
-                world.getServer().getPluginManager().callEvent(event);
-            }
-            // CraftBukkit end
-
-            if (this.s_() && !flag && this.vehicle == null) {
-                double d21 = this.locX - d3;
-                double d22 = this.locY - d4;
-                double d23 = this.locZ - d5;
-
-                if (block != Blocks.LADDER) {
-                    d22 = 0.0D;
-                }
-
-                if (block != null && this.onGround) {
-                    // block.a(this.world, blockposition, this); // CraftBukkit moved down
-                }
-
-                this.M = (float) ((double) this.M + (double) MathHelper.sqrt(d21 * d21 + d23 * d23) * 0.6D);
-                this.N = (float) ((double) this.N + (double) MathHelper.sqrt(d21 * d21 + d22 * d22 + d23 * d23) * 0.6D);
-                if (this.N > (float) this.h && block.getMaterial() != Material.AIR) {
-                    this.h = (int) this.N + 1;
-                    if (this.V()) {
-                        float f = MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.35F;
-
-                        if (f > 1.0F) {
-                            f = 1.0F;
-                        }
-
-                        this.makeSound(this.P(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
-                    }
-
-                    this.a(blockposition, block);
-                    block.a(this.world, blockposition, this); // CraftBukkit moved from above
-                }
-            }
-
-            // CraftBukkit start - Move to the top of the method
-            /*
-            try {
-                this.checkBlockCollisions();
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
-
-                this.appendEntityCrashDetails(crashreportsystemdetails);
-                throw new ReportedException(crashreport);
-            }
-            */
-            // CraftBukkit end
-
-            boolean flag2 = this.U();
-
-            if (this.world.e(this.getBoundingBox().shrink(0.001D, 0.001D, 0.001D))) {
-                this.burn(1);
-                if (!flag2) {
-                    ++this.fireTicks;
-                    // CraftBukkit start - Not on fire yet
-                    if (this.fireTicks <= 0) { // Only throw events on the first combust, otherwise it spams
-                        EntityCombustEvent event = new EntityCombustEvent(getBukkitEntity(), 8);
-                        world.getServer().getPluginManager().callEvent(event);
-
-                        if (!event.isCancelled()) {
-                            setOnFire(event.getDuration());
-                        }
-                    } else {
-                        // CraftBukkit end
-                        this.setOnFire(8);
-                    }
-                }
-            } else if (this.fireTicks <= 0) {
-                this.fireTicks = -this.maxFireTicks;
-            }
-
-            if (flag2 && this.fireTicks > 0) {
-                this.makeSound("random.fizz", 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
-                this.fireTicks = -this.maxFireTicks;
-            }
-
-            this.world.methodProfiler.b();
-        }
-    }
-
-    private void recalcPosition() {
-        this.locX = (this.getBoundingBox().a + this.getBoundingBox().d) / 2.0D;
-        this.locY = this.getBoundingBox().b;
-        this.locZ = (this.getBoundingBox().c + this.getBoundingBox().f) / 2.0D;
-    }
-
-    protected String P() {
-        return "game.neutral.swim";
-    }
-
-    protected void checkBlockCollisions() {
-        BlockPosition blockposition = new BlockPosition(this.getBoundingBox().a + 0.001D, this.getBoundingBox().b + 0.001D, this.getBoundingBox().c + 0.001D);
-        BlockPosition blockposition1 = new BlockPosition(this.getBoundingBox().d - 0.001D, this.getBoundingBox().e - 0.001D, this.getBoundingBox().f - 0.001D);
-
-        if (this.world.areChunksLoadedBetween(blockposition, blockposition1)) {
-            for (int i = blockposition.getX(); i <= blockposition1.getX(); ++i) {
-                for (int j = blockposition.getY(); j <= blockposition1.getY(); ++j) {
-                    for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
-                        BlockPosition blockposition2 = new BlockPosition(i, j, k);
-                        IBlockData iblockdata = this.world.getType(blockposition2);
-
-                        try {
-                            iblockdata.getBlock().a(this.world, blockposition2, iblockdata, this);
-                        } catch (Throwable throwable) {
-                            CrashReport crashreport = CrashReport.a(throwable, "Colliding entity with block");
-                            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being collided with");
-
-                            CrashReportSystemDetails.a(crashreportsystemdetails, blockposition2, iblockdata);
-                            throw new ReportedException(crashreport);
-                        }
-                    }
-                }
-            }
-        }
-
-    }
-
-    protected void a(BlockPosition blockposition, Block block) {
-        Block.StepSound block_stepsound = block.stepSound;
-
-        if (this.world.getType(blockposition.up()).getBlock() == Blocks.SNOW_LAYER) {
-            block_stepsound = Blocks.SNOW_LAYER.stepSound;
-            this.makeSound(block_stepsound.getStepSound(), block_stepsound.getVolume1() * 0.15F, block_stepsound.getVolume2());
-        } else if (!block.getMaterial().isLiquid()) {
-            this.makeSound(block_stepsound.getStepSound(), block_stepsound.getVolume1() * 0.15F, block_stepsound.getVolume2());
-        }
-
-    }
-
-    public void makeSound(String s, float f, float f1) {
-        if (!this.R()) {
-            this.world.makeSound(this, s, f, f1);
-        }
-
-    }
-
-    public boolean R() {
-        return this.datawatcher.getByte(4) == 1;
-    }
-
-    public void b(boolean flag) {
-        this.datawatcher.watch(4, Byte.valueOf((byte) (flag ? 1 : 0)));
-    }
-
-    protected boolean s_() {
-        return true;
-    }
-
-    protected void a(double d0, boolean flag, Block block, BlockPosition blockposition) {
-        if (flag) {
-            if (this.fallDistance > 0.0F) {
-                if (block != null) {
-                    block.fallOn(this.world, blockposition, this, this.fallDistance);
-                } else {
-                    this.e(this.fallDistance, 1.0F);
-                }
-
-                this.fallDistance = 0.0F;
-            }
-        } else if (d0 < 0.0D) {
-            this.fallDistance = (float) ((double) this.fallDistance - d0);
-        }
-
-    }
-
-    public AxisAlignedBB S() {
-        return null;
-    }
-
-    protected void burn(float i) { // CraftBukkit - int -> float
-        if (!this.fireProof) {
-            this.damageEntity(DamageSource.FIRE, (float) i);
-        }
-
-    }
-
-    public final boolean isFireProof() {
-        return this.fireProof;
-    }
-
-    public void e(float f, float f1) {
-        if (this.passenger != null) {
-            this.passenger.e(f, f1);
-        }
-
-    }
-
-    public boolean U() {
-        return this.inWater || this.world.isRainingAt(new BlockPosition(this.locX, this.locY, this.locZ)) || this.world.isRainingAt(new BlockPosition(this.locX, this.locY + (double) this.length, this.locZ));
-    }
-
-    public boolean V() {
-        return this.inWater;
-    }
-
-    public boolean W() {
-        if (this.world.a(this.getBoundingBox().grow(0.0D, -0.4000000059604645D, 0.0D).shrink(0.001D, 0.001D, 0.001D), Material.WATER, this)) {
-            if (!this.inWater && !this.justCreated) {
-                this.X();
-            }
-
-            this.fallDistance = 0.0F;
-            this.inWater = true;
-            this.fireTicks = 0;
-        } else {
-            this.inWater = false;
-        }
-
-        return this.inWater;
-    }
-
-    protected void X() {
-        float f = MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.2F;
-
-        if (f > 1.0F) {
-            f = 1.0F;
-        }
-
-        this.makeSound(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
-        float f1 = (float) MathHelper.floor(this.getBoundingBox().b);
-
-        int i;
-        float f2;
-        float f3;
-
-        for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
-            f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.addParticle(EnumParticle.WATER_BUBBLE, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY - (double) (this.random.nextFloat() * 0.2F), this.motZ, new int[0]);
-        }
-
-        for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
-            f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.addParticle(EnumParticle.WATER_SPLASH, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY, this.motZ, new int[0]);
-        }
-
-    }
-
-    public void Y() {
-        if (this.isSprinting() && !this.V()) {
-            this.Z();
-        }
-
-    }
-
-    protected void Z() {
-        int i = MathHelper.floor(this.locX);
-        int j = MathHelper.floor(this.locY - 0.20000000298023224D);
-        int k = MathHelper.floor(this.locZ);
-        BlockPosition blockposition = new BlockPosition(i, j, k);
-        IBlockData iblockdata = this.world.getType(blockposition);
-        Block block = iblockdata.getBlock();
-
-        if (block.b() != -1) {
-            this.world.addParticle(EnumParticle.BLOCK_CRACK, this.locX + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, this.getBoundingBox().b + 0.1D, this.locZ + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, -this.motX * 4.0D, 1.5D, -this.motZ * 4.0D, new int[] { Block.getCombinedId(iblockdata)});
-        }
-
-    }
-
-    protected String aa() {
-        return "game.neutral.swim.splash";
-    }
-
-    public boolean a(Material material) {
-        double d0 = this.locY + (double) this.getHeadHeight();
-        BlockPosition blockposition = new BlockPosition(this.locX, d0, this.locZ);
-        IBlockData iblockdata = this.world.getType(blockposition);
-        Block block = iblockdata.getBlock();
-
-        if (block.getMaterial() == material) {
-            float f = BlockFluids.b(iblockdata.getBlock().toLegacyData(iblockdata)) - 0.11111111F;
-            float f1 = (float) (blockposition.getY() + 1) - f;
-            boolean flag = d0 < (double) f1;
-
-            return !flag && this instanceof EntityHuman ? false : flag;
-        } else {
-            return false;
-        }
-    }
-
-    public boolean ab() {
-        return this.world.a(this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
-    }
-
-    public void a(float f, float f1, float f2) {
-        float f3 = f * f + f1 * f1;
-
-        if (f3 >= 1.0E-4F) {
-            f3 = MathHelper.c(f3);
-            if (f3 < 1.0F) {
-                f3 = 1.0F;
-            }
-
-            f3 = f2 / f3;
-            f *= f3;
-            f1 *= f3;
-            float f4 = MathHelper.sin(this.yaw * 3.1415927F / 180.0F);
-            float f5 = MathHelper.cos(this.yaw * 3.1415927F / 180.0F);
-
-            this.motX += (double) (f * f5 - f1 * f4);
-            this.motZ += (double) (f1 * f5 + f * f4);
-        }
-    }
-
-    public float c(float f) {
-        BlockPosition blockposition = new BlockPosition(this.locX, this.locY + (double) this.getHeadHeight(), this.locZ);
-
-        return this.world.isLoaded(blockposition) ? this.world.o(blockposition) : 0.0F;
-    }
-
-    public void spawnIn(World world) {
-        // CraftBukkit start
-        if (world == null) {
-            die();
-            this.world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
-            return;
-        }
-        // CraftBukkit end
-        this.world = world;
-    }
-
-    public void setLocation(double d0, double d1, double d2, float f, float f1) {
-        this.lastX = this.locX = d0;
-        this.lastY = this.locY = d1;
-        this.lastZ = this.locZ = d2;
-        this.lastYaw = this.yaw = f;
-        this.lastPitch = this.pitch = f1;
-        double d3 = (double) (this.lastYaw - f);
-
-        if (d3 < -180.0D) {
-            this.lastYaw += 360.0F;
-        }
-
-        if (d3 >= 180.0D) {
-            this.lastYaw -= 360.0F;
-        }
-
-        this.setPosition(this.locX, this.locY, this.locZ);
-        this.setYawPitch(f, f1);
-    }
-
-    public void setPositionRotation(BlockPosition blockposition, float f, float f1) {
-        this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, f, f1);
-    }
-
-    public void setPositionRotation(double d0, double d1, double d2, float f, float f1) {
-        this.P = this.lastX = this.locX = d0;
-        this.Q = this.lastY = this.locY = d1;
-        this.R = this.lastZ = this.locZ = d2;
-        this.yaw = f;
-        this.pitch = f1;
-        this.setPosition(this.locX, this.locY, this.locZ);
-    }
-
-    public float g(Entity entity) {
-        float f = (float) (this.locX - entity.locX);
-        float f1 = (float) (this.locY - entity.locY);
-        float f2 = (float) (this.locZ - entity.locZ);
-
-        return MathHelper.c(f * f + f1 * f1 + f2 * f2);
-    }
-
-    public double e(double d0, double d1, double d2) {
-        double d3 = this.locX - d0;
-        double d4 = this.locY - d1;
-        double d5 = this.locZ - d2;
-
-        return d3 * d3 + d4 * d4 + d5 * d5;
-    }
-
-    public double b(BlockPosition blockposition) {
-        return blockposition.c(this.locX, this.locY, this.locZ);
-    }
-
-    public double c(BlockPosition blockposition) {
-        return blockposition.d(this.locX, this.locY, this.locZ);
-    }
-
-    public double f(double d0, double d1, double d2) {
-        double d3 = this.locX - d0;
-        double d4 = this.locY - d1;
-        double d5 = this.locZ - d2;
-
-        return (double) MathHelper.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
-    }
-
-    public double h(Entity entity) {
-        double d0 = this.locX - entity.locX;
-        double d1 = this.locY - entity.locY;
-        double d2 = this.locZ - entity.locZ;
-
-        return d0 * d0 + d1 * d1 + d2 * d2;
-    }
-
-    public void d(EntityHuman entityhuman) {}
-
-    int numCollisions = 0; // Spigot
-    public void collide(Entity entity) {
-        if (entity.passenger != this && entity.vehicle != this) {
-            if (!entity.noclip && !this.noclip) {
-                double d0 = entity.locX - this.locX;
-                double d1 = entity.locZ - this.locZ;
-                double d2 = MathHelper.a(d0, d1);
-
-                if (d2 >= 0.009999999776482582D) {
-                    d2 = (double) MathHelper.sqrt(d2);
-                    d0 /= d2;
-                    d1 /= d2;
-                    double d3 = 1.0D / d2;
-
-                    if (d3 > 1.0D) {
-                        d3 = 1.0D;
-                    }
-
-                    d0 *= d3;
-                    d1 *= d3;
-                    d0 *= 0.05000000074505806D;
-                    d1 *= 0.05000000074505806D;
-                    d0 *= (double) (1.0F - this.U);
-                    d1 *= (double) (1.0F - this.U);
-                    if (this.passenger == null) {
-                        this.g(-d0, 0.0D, -d1);
-                    }
-
-                    if (entity.passenger == null) {
-                        entity.g(d0, 0.0D, d1);
-                    }
-                }
-
-            }
-        }
-    }
-
-    public void g(double d0, double d1, double d2) {
-        this.motX += d0;
-        this.motY += d1;
-        this.motZ += d2;
-        this.ai = true;
-    }
-
-    protected void ac() {
-        this.velocityChanged = true;
-    }
-
-    public boolean damageEntity(DamageSource damagesource, float f) {
-        if (this.isInvulnerable(damagesource)) {
-            return false;
-        } else {
-            this.ac();
-            return false;
-        }
-    }
-
-    public Vec3D d(float f) {
-        if (f == 1.0F) {
-            return this.f(this.pitch, this.yaw);
-        } else {
-            float f1 = this.lastPitch + (this.pitch - this.lastPitch) * f;
-            float f2 = this.lastYaw + (this.yaw - this.lastYaw) * f;
-
-            return this.f(f1, f2);
-        }
-    }
-
-    protected final Vec3D f(float f, float f1) {
-        float f2 = MathHelper.cos(-f1 * 0.017453292F - 3.1415927F);
-        float f3 = MathHelper.sin(-f1 * 0.017453292F - 3.1415927F);
-        float f4 = -MathHelper.cos(-f * 0.017453292F);
-        float f5 = MathHelper.sin(-f * 0.017453292F);
-
-        return new Vec3D((double) (f3 * f4), (double) f5, (double) (f2 * f4));
-    }
-
-    public boolean ad() {
-        return false;
-    }
-
-    public boolean ae() {
-        return false;
-    }
-
-    public void b(Entity entity, int i) {}
-
-    public boolean c(NBTTagCompound nbttagcompound) {
-        String s = this.ag();
-
-        if (!this.dead && s != null) {
-            nbttagcompound.setString("id", s);
-            this.e(nbttagcompound);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public boolean d(NBTTagCompound nbttagcompound) {
-        String s = this.ag();
-
-        if (!this.dead && s != null && this.passenger == null) {
-            nbttagcompound.setString("id", s);
-            this.e(nbttagcompound);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public void e(NBTTagCompound nbttagcompound) {
-        try {
-            nbttagcompound.set("Pos", this.a(new double[] { this.locX, this.locY, this.locZ}));
-            nbttagcompound.set("Motion", this.a(new double[] { this.motX, this.motY, this.motZ}));
-
-            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
-            // TODO: make sure this is the best way to address this.
-            if (Float.isNaN(this.yaw)) {
-                this.yaw = 0;
-            }
-
-            if (Float.isNaN(this.pitch)) {
-                this.pitch = 0;
-            }
-            // CraftBukkit end
-
-            nbttagcompound.set("Rotation", this.a(new float[] { this.yaw, this.pitch}));
-            nbttagcompound.setFloat("FallDistance", this.fallDistance);
-            nbttagcompound.setShort("Fire", (short) this.fireTicks);
-            nbttagcompound.setShort("Air", (short) this.getAirTicks());
-            nbttagcompound.setBoolean("OnGround", this.onGround);
-            nbttagcompound.setInt("Dimension", this.dimension);
-            nbttagcompound.setBoolean("Invulnerable", this.invulnerable);
-            nbttagcompound.setInt("PortalCooldown", this.portalCooldown);
-            nbttagcompound.setLong("UUIDMost", this.getUniqueID().getMostSignificantBits());
-            nbttagcompound.setLong("UUIDLeast", this.getUniqueID().getLeastSignificantBits());
-            // CraftBukkit start
-            nbttagcompound.setLong("WorldUUIDLeast", this.world.getDataManager().getUUID().getLeastSignificantBits());
-            nbttagcompound.setLong("WorldUUIDMost", this.world.getDataManager().getUUID().getMostSignificantBits());
-            nbttagcompound.setInt("Bukkit.updateLevel", CURRENT_LEVEL);
-            nbttagcompound.setInt("Spigot.ticksLived", this.ticksLived);
-            // CraftBukkit end
-            if (this.getCustomName() != null && this.getCustomName().length() > 0) {
-                nbttagcompound.setString("CustomName", this.getCustomName());
-                nbttagcompound.setBoolean("CustomNameVisible", this.getCustomNameVisible());
-            }
-
-            this.au.b(nbttagcompound);
-            if (this.R()) {
-                nbttagcompound.setBoolean("Silent", this.R());
-            }
-
-            this.b(nbttagcompound);
-            if (this.vehicle != null) {
-                NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-
-                if (this.vehicle.c(nbttagcompound1)) {
-                    nbttagcompound.set("Riding", nbttagcompound1);
-                }
-            }
-
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Saving entity NBT");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being saved");
-
-            this.appendEntityCrashDetails(crashreportsystemdetails);
-            throw new ReportedException(crashreport);
-        }
-    }
-
-    public void f(NBTTagCompound nbttagcompound) {
-        try {
-            NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6);
-            NBTTagList nbttaglist1 = nbttagcompound.getList("Motion", 6);
-            NBTTagList nbttaglist2 = nbttagcompound.getList("Rotation", 5);
-
-            this.motX = nbttaglist1.d(0);
-            this.motY = nbttaglist1.d(1);
-            this.motZ = nbttaglist1.d(2);
-
-            /* CraftBukkit start - Moved section down
-            if (Math.abs(this.motX) > 10.0D) {
-                this.motX = 0.0D;
-            }
-
-            if (Math.abs(this.motY) > 10.0D) {
-                this.motY = 0.0D;
-            }
-
-            if (Math.abs(this.motZ) > 10.0D) {
-                this.motZ = 0.0D;
-            }
-            // CraftBukkit end */
-
-            this.lastX = this.P = this.locX = nbttaglist.d(0);
-            this.lastY = this.Q = this.locY = nbttaglist.d(1);
-            this.lastZ = this.R = this.locZ = nbttaglist.d(2);
-            this.lastYaw = this.yaw = nbttaglist2.e(0);
-            this.lastPitch = this.pitch = nbttaglist2.e(1);
-            this.f(this.yaw);
-            this.g(this.yaw);
-            this.fallDistance = nbttagcompound.getFloat("FallDistance");
-            this.fireTicks = nbttagcompound.getShort("Fire");
-            this.setAirTicks(nbttagcompound.getShort("Air"));
-            this.onGround = nbttagcompound.getBoolean("OnGround");
-            this.dimension = nbttagcompound.getInt("Dimension");
-            this.invulnerable = nbttagcompound.getBoolean("Invulnerable");
-            this.portalCooldown = nbttagcompound.getInt("PortalCooldown");
-            if (nbttagcompound.hasKeyOfType("UUIDMost", 4) && nbttagcompound.hasKeyOfType("UUIDLeast", 4)) {
-                this.uniqueID = new UUID(nbttagcompound.getLong("UUIDMost"), nbttagcompound.getLong("UUIDLeast"));
-            } else if (nbttagcompound.hasKeyOfType("UUID", 8)) {
-                this.uniqueID = UUID.fromString(nbttagcompound.getString("UUID"));
-            }
-
-            this.setPosition(this.locX, this.locY, this.locZ);
-            this.setYawPitch(this.yaw, this.pitch);
-            if (nbttagcompound.hasKeyOfType("CustomName", 8) && nbttagcompound.getString("CustomName").length() > 0) {
-                this.setCustomName(nbttagcompound.getString("CustomName"));
-            }
-
-            this.setCustomNameVisible(nbttagcompound.getBoolean("CustomNameVisible"));
-            this.au.a(nbttagcompound);
-            this.b(nbttagcompound.getBoolean("Silent"));
-            this.a(nbttagcompound);
-            if (this.af()) {
-                this.setPosition(this.locX, this.locY, this.locZ);
-            }
-
-            // CraftBukkit start
-            if (this instanceof EntityLiving) {
-                EntityLiving entity = (EntityLiving) this;
-
-                this.ticksLived = nbttagcompound.getInt("Spigot.ticksLived");
-
-                // Reset the persistence for tamed animals
-                if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) {
-                    EntityInsentient entityinsentient = (EntityInsentient) entity;
-                    entityinsentient.persistent = !entityinsentient.isTypeNotPersistent();
-                }
-            }
-            // CraftBukkit end
-
-            // CraftBukkit start - Exempt Vehicles from notch's sanity check
-            if (!(getBukkitEntity() instanceof Vehicle)) {
-                if (Math.abs(this.motX) > 10.0D) {
-                    this.motX = 0.0D;
-                }
-
-                if (Math.abs(this.motY) > 10.0D) {
-                    this.motY = 0.0D;
-                }
-
-                if (Math.abs(this.motZ) > 10.0D) {
-                    this.motZ = 0.0D;
-                }
-            }
-            // CraftBukkit end
-
-            // CraftBukkit start - Reset world
-            if (this instanceof EntityPlayer) {
-                Server server = Bukkit.getServer();
-                org.bukkit.World bworld = null;
-
-                // TODO: Remove World related checks, replaced with WorldUID
-                String worldName = nbttagcompound.getString("world");
-
-                if (nbttagcompound.hasKey("WorldUUIDMost") && nbttagcompound.hasKey("WorldUUIDLeast")) {
-                    UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast"));
-                    bworld = server.getWorld(uid);
-                } else {
-                    bworld = server.getWorld(worldName);
-                }
-
-                if (bworld == null) {
-                    EntityPlayer entityPlayer = (EntityPlayer) this;
-                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(entityPlayer.dimension).getWorld();
-                }
-
-                spawnIn(bworld == null? null : ((CraftWorld) bworld).getHandle());
-            }
-            // CraftBukkit end
 
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being loaded");
+public abstract class Entity implements ICommandListener, OptimizedRemoveUtil.Marker {
+
+	// CraftBukkit start
+	private static final int CURRENT_LEVEL = 2;
+
+	static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
+		return tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
+	}
+	// CraftBukikt end
+
+	private static final AxisAlignedBB a = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
+	private static int entityCount;
+
+	private int id;
+	public double j;
+	public boolean k;
+	public Entity passenger;
+	public Entity vehicle;
+	public boolean attachedToPlayer;
+	public World world;
+	public double lastX;
+	public double lastY;
+	public double lastZ;
+	public double locX;
+	public double locY;
+	public double locZ;
+	public double motX;
+	public double motY;
+	public double motZ;
+	public float yaw;
+	public float pitch;
+	public float lastYaw;
+	public float lastPitch;
+	private AxisAlignedBB boundingBox;
+	public boolean onGround;
+	public boolean positionChanged;
+	public boolean E;
+	public boolean F;
+	public boolean velocityChanged;
+	protected boolean H;
+	private boolean g;
+	public boolean dead;
+	public float width;
+	public float length;
+	public float L;
+	public float M;
+	public float N;
+	public float fallDistance;
+	private int h;
+	public double P;
+	public double Q;
+	public double R;
+	public float S;
+	public boolean noclip;
+	public float U;
+	protected Random random;
+	public int ticksLived;
+	public int maxFireTicks;
+	public int fireTicks;
+	public boolean inWater; // Spigot - protected -> public // PAIL
+	public int noDamageTicks;
+	protected boolean justCreated;
+	protected boolean fireProof;
+	protected DataWatcher datawatcher;
+	private double ar;
+	private double as;
+	public boolean ad;
+	private boolean needsRemoval = false;
+
+	// PaperSpigot start - EAR: Fix bug with teleporting entities
+	public boolean isAddedToChunk() {
+		int chunkX = MathHelper.floor(locX / 16.0D);
+		int chunkY = MathHelper.floor(locY / 16.0D);
+		int chunkZ = MathHelper.floor(locZ / 16.0D);
+
+		return ad && getChunkX() == chunkX && getChunkY() == chunkY || getChunkZ() == chunkZ;
+	}
+
+	public int ae;
+
+	public int getChunkX() {
+		return ae;
+	} // PAIL
+
+	public int af;
+
+	public int getChunkY() {
+		return af;
+	} // PAIL
+
+	public int ag;
+
+	public int getChunkZ() {
+		return ag;
+	} // PAIL
+
+	// PaperSpigot end
+	public boolean ah;
+	public boolean ai;
+	public int portalCooldown;
+	protected boolean ak;
+	protected int al;
+	public int dimension;
+	protected BlockPosition an;
+	protected Vec3D ao;
+	protected EnumDirection ap;
+	private boolean invulnerable;
+	protected UUID uniqueID;
+	private final CommandObjectiveExecutor au;
+	public boolean valid; // CraftBukkit
+	public org.bukkit.projectiles.ProjectileSource projectileSource; // CraftBukkit - For projectiles only
+	public boolean forceExplosionKnockback; // CraftBukkit - SPIGOT-949
+	public boolean inUnloadedChunk = false; // PaperSpigot - Remove entities in unloaded chunks
+	public boolean loadChunks = false; // PaperSpigot - Entities can load chunks they move through and keep them loaded
+
+	// Spigot start
+	public Timing tickTimer = SpigotTimings.getEntityTimings(this); // Spigot
+	public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+	public final boolean defaultActivationState;
+	public long activatedTick = Integer.MIN_VALUE;
+	public boolean fromMobSpawner;
+
+	public void inactiveTick() {
+	}
+	// Spigot end
+
+	public int getId() {
+		return this.id;
+	}
+
+	public void d(int i) {
+		this.id = i;
+	}
+
+	public void G() {
+		this.die();
+	}
+
+	public Entity(World world) {
+		this.id = Entity.entityCount++;
+		this.j = 1.0D;
+		this.boundingBox = Entity.a;
+		this.width = 0.6F;
+		this.length = 1.8F;
+		this.h = 1;
+		this.random = new Random();
+		this.maxFireTicks = 1;
+		this.justCreated = true;
+		this.uniqueID = MathHelper.a(this.random);
+		this.au = new CommandObjectiveExecutor();
+		this.world = world;
+
+		this.setPosition(0.0D, 0.0D, 0.0D);
+
+		if (world != null) {
+			this.dimension = world.worldProvider.getDimension();
+			// Spigot start
+			this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
+		} else {
+			this.defaultActivationState = false;
+		}
+		// Spigot end
+
+		this.datawatcher = new DataWatcher(this);
+		this.datawatcher.a(0, Byte.valueOf((byte) 0));
+		this.datawatcher.a(1, Short.valueOf((short) 300));
+		this.datawatcher.a(3, Byte.valueOf((byte) 0));
+		this.datawatcher.a(2, "");
+		this.datawatcher.a(4, Byte.valueOf((byte) 0));
+		this.h();
+	}
+
+	protected abstract void h();
+
+	public DataWatcher getDataWatcher() {
+		return this.datawatcher;
+	}
+
+	public boolean equals(Object object) {
+		return object instanceof Entity ? ((Entity) object).id == this.id : false;
+	}
+
+	public int hashCode() {
+		return this.id;
+	}
+
+	public void die() {
+		this.dead = true;
+	}
+
+	public void setSize(float f, float f1) {
+		if (f != this.width || f1 != this.length) {
+			float f2 = this.width;
+
+			this.width = f;
+			this.length = f1;
+
+			this.a(new AxisAlignedBB(this.getBoundingBox().a, this.getBoundingBox().b, this.getBoundingBox().c, this.getBoundingBox().a + (double) this.width, this.getBoundingBox().b + (double) this.length, this.getBoundingBox().c + (double) this.width));
+
+			if (this.width > f2 && !this.justCreated && !this.world.isClientSide) {
+				this.move((double) (f2 - this.width), 0.0D, (double) (f2 - this.width));
+			}
+		}
+
+	}
+
+	protected void setYawPitch(float f, float f1) {
+		// CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+		if (Float.isNaN(f)) {
+			f = 0;
+		}
+
+		if (f == Float.POSITIVE_INFINITY || f == Float.NEGATIVE_INFINITY) {
+			if (this instanceof EntityPlayer) {
+				this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+				((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+			}
+			f = 0;
+		}
+
+		// pitch was sometimes set to NaN, so we need to set it back to 0
+		if (Float.isNaN(f1)) {
+			f1 = 0;
+		}
+
+		if (f1 == Float.POSITIVE_INFINITY || f1 == Float.NEGATIVE_INFINITY) {
+			if (this instanceof EntityPlayer) {
+				this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+				((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+			}
+			f1 = 0;
+		}
+		// CraftBukkit end
+
+		this.yaw = f % 360.0F;
+		this.pitch = f1 % 360.0F;
+	}
+
+	public void setPosition(double d0, double d1, double d2) {
+		this.locX = d0;
+		this.locY = d1;
+		this.locZ = d2;
+		float f = this.width / 2.0F;
+		float f1 = this.length;
+
+		this.a(new AxisAlignedBB(d0 - (double) f, d1, d2 - (double) f, d0 + (double) f, d1 + (double) f1, d2 + (double) f));
+	}
+
+	public void t_() {
+		this.K();
+	}
+
+	/**
+	 * PaperSpigot - Checks if the feature is enabled and the entity is above the nether world bedrock height
+	 */
+	private boolean paperNetherCheck() {
+		return this.world.paperSpigotConfig.netherVoidTopDamage && this.world.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this.locY >= 128.0D;
+	}
+
+	public void K() {
+		this.world.methodProfiler.a("entityBaseTick");
+		if (this.vehicle != null && this.vehicle.dead) {
+			this.vehicle = null;
+		}
+
+		this.L = this.M;
+		this.lastX = this.locX;
+		this.lastY = this.locY;
+		this.lastZ = this.locZ;
+		this.lastPitch = this.pitch;
+		this.lastYaw = this.yaw;
+		if (!this.world.isClientSide && this.world instanceof WorldServer) {
+			this.world.methodProfiler.a("portal");
+			MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
+			int i = this.L();
+
+			if (this.ak) {
+				if (true || minecraftserver.getAllowNether()) { // CraftBukkit
+					if (this.vehicle == null && this.al++ >= i) {
+						this.al = i;
+						this.portalCooldown = this.aq();
+						byte b0;
+
+						if (this.world.worldProvider.getDimension() == -1) {
+							b0 = 0;
+						} else {
+							b0 = -1;
+						}
+
+						this.c(b0);
+					}
+
+					this.ak = false;
+				}
+			} else {
+				if (this.al > 0) {
+					this.al -= 4;
+				}
+
+				if (this.al < 0) {
+					this.al = 0;
+				}
+			}
+
+			if (this.portalCooldown > 0) {
+				--this.portalCooldown;
+			}
+
+			this.world.methodProfiler.b();
+		}
+
+		this.Y();
+		this.W();
+		if (this.world.isClientSide) {
+			this.fireTicks = 0;
+		} else if (this.fireTicks > 0) {
+			if (this.fireProof) {
+				this.fireTicks -= 4;
+				if (this.fireTicks < 0) {
+					this.fireTicks = 0;
+				}
+			} else {
+				if (this.fireTicks % DedicatedServer.TPS == 0) { // SpigotX - change default to TPS instead of 20
+					this.damageEntity(DamageSource.BURN, 1.0F);
+				}
+
+				--this.fireTicks;
+			}
+		}
+
+		if (this.ab()) {
+			this.burnFromLava();
+			this.fallDistance *= 0.5F;
+		}
+
+		if (this.locY < -64.0D || paperNetherCheck()) { // PaperSpigot - Configurable top-of-nether void damage
+			this.O();
+		}
+
+		if (!this.world.isClientSide) {
+			this.b(0, this.fireTicks > 0);
+		}
+
+		this.justCreated = false;
+		this.world.methodProfiler.b();
+	}
+
+	public int L() {
+		return 0;
+	}
+
+	protected void burnFromLava() {
+		if (!this.fireProof) {
+			this.damageEntity(DamageSource.LAVA, 4.0F);
+
+			// CraftBukkit start - Fallen in lava TODO: this event spams!
+			if (this instanceof EntityLiving) {
+				if (fireTicks <= 0) {
+					// not on fire yet
+					// TODO: shouldn't be sending null for the block
+					org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+					org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+					EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+					this.world.getServer().getPluginManager().callEvent(combustEvent);
+
+					if (!combustEvent.isCancelled()) {
+						this.setOnFire(combustEvent.getDuration());
+					}
+				} else {
+					// This will be called every single tick the entity is in lava, so don't throw an event
+					this.setOnFire(15);
+				}
+				return;
+			}
+			// CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
+			this.setOnFire(15);
+		}
+	}
+
+	public void setOnFire(int i) {
+		int j = i * 20;
+
+		j = EnchantmentProtection.a(this, j);
+
+		if (this.fireTicks < j) {
+			this.fireTicks = j;
+		}
+	}
+
+	public void extinguish() {
+		this.fireTicks = 0;
+	}
+
+	protected void O() {
+		this.die();
+	}
+
+	public boolean c(double d0, double d1, double d2) {
+		AxisAlignedBB axisalignedbb = this.getBoundingBox().c(d0, d1, d2);
+
+		return this.b(axisalignedbb);
+	}
+
+	private boolean b(AxisAlignedBB axisalignedbb) {
+		return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
+	}
+
+	/**
+	 * PaperSpigot - Load surrounding chunks the entity is moving through
+	 */
+	public void loadChunks() {
+		for (int cx = (int) locX >> 4; cx <= (int) (locX + motX) >> 4; ++cx) {
+			for (int cz = (int) locZ >> 4; cz <= (int) (locZ + motZ) >> 4; ++cz) {
+				((ChunkProviderServer) world.chunkProvider).getChunkAt(cx, cz);
+			}
+		}
+	}
+
+
+	public void move(double d0, double d1, double d2) {
+		if (this.loadChunks) loadChunks(); // PaperSpigot - Load chunks
+		if (this.noclip) {
+			this.a(this.getBoundingBox().c(d0, d1, d2));
+			this.recalcPosition();
+		} else {
+			// CraftBukkit start - Don't do anything if we aren't moving
+			// We need to do this regardless of whether or not we are moving thanks to portals
+			try {
+				this.checkBlockCollisions();
+			} catch (Throwable throwable) {
+				CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
+				CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
+
+				this.appendEntityCrashDetails(crashreportsystemdetails);
+				throw new ReportedException(crashreport);
+			}
+			// Check if we're moving
+			if (d0 == 0 && d1 == 0 && d2 == 0 && this.vehicle == null && this.passenger == null) {
+				return;
+			}
+			// CraftBukkit end
+			this.world.methodProfiler.a("move");
+			double d3 = this.locX;
+			double d4 = this.locY;
+			double d5 = this.locZ;
+
+			if (this.H) {
+				this.H = false;
+				d0 *= 0.25D;
+				d1 *= 0.05000000074505806D;
+				d2 *= 0.25D;
+				this.motX = 0.0D;
+				this.motY = 0.0D;
+				this.motZ = 0.0D;
+			}
+
+			double d6 = d0;
+			double d7 = d1;
+			double d8 = d2;
+			boolean flag = this.onGround && this.isSneaking() && this instanceof EntityHuman;
+
+			if (flag) {
+				double d9;
+
+				for (d9 = 0.05D; d0 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, 0.0D)).isEmpty(); d6 = d0) {
+					if (d0 < d9 && d0 >= -d9) {
+						d0 = 0.0D;
+					} else if (d0 > 0.0D) {
+						d0 -= d9;
+					} else {
+						d0 += d9;
+					}
+				}
+
+				for (; d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(0.0D, -1.0D, d2)).isEmpty(); d8 = d2) {
+					if (d2 < d9 && d2 >= -d9) {
+						d2 = 0.0D;
+					} else if (d2 > 0.0D) {
+						d2 -= d9;
+					} else {
+						d2 += d9;
+					}
+				}
+
+				for (; d0 != 0.0D && d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, d2)).isEmpty(); d8 = d2) {
+					if (d0 < d9 && d0 >= -d9) {
+						d0 = 0.0D;
+					} else if (d0 > 0.0D) {
+						d0 -= d9;
+					} else {
+						d0 += d9;
+					}
+
+					d6 = d0;
+					if (d2 < d9 && d2 >= -d9) {
+						d2 = 0.0D;
+					} else if (d2 > 0.0D) {
+						d2 -= d9;
+					} else {
+						d2 += d9;
+					}
+				}
+			}
+
+			List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
+			AxisAlignedBB axisalignedbb = this.getBoundingBox();
+
+			AxisAlignedBB axisalignedbb1;
+
+			for (Iterator iterator = list.iterator(); iterator.hasNext(); d1 = axisalignedbb1.b(this.getBoundingBox(), d1)) {
+				axisalignedbb1 = (AxisAlignedBB) iterator.next();
+			}
+
+			this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+			boolean flag1 = this.onGround || d7 != d1 && d7 < 0.0D;
+
+			AxisAlignedBB axisalignedbb2;
+			Iterator iterator1;
+
+			for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
+				axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+			}
+
+			this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
+
+			for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
+				axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+			}
+
+			this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+			if (this.S > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
+				double d10 = d0;
+				double d11 = d1;
+				double d12 = d2;
+				AxisAlignedBB axisalignedbb3 = this.getBoundingBox();
+
+				this.a(axisalignedbb);
+				d1 = (double) this.S;
+				List list1 = this.world.getCubes(this, this.getBoundingBox().a(d6, d1, d8));
+				AxisAlignedBB axisalignedbb4 = this.getBoundingBox();
+				AxisAlignedBB axisalignedbb5 = axisalignedbb4.a(d6, 0.0D, d8);
+				double d13 = d1;
+
+				AxisAlignedBB axisalignedbb6;
+
+				for (Iterator iterator2 = list1.iterator(); iterator2.hasNext(); d13 = axisalignedbb6.b(axisalignedbb5, d13)) {
+					axisalignedbb6 = (AxisAlignedBB) iterator2.next();
+				}
+
+				axisalignedbb4 = axisalignedbb4.c(0.0D, d13, 0.0D);
+				double d14 = d6;
+
+				AxisAlignedBB axisalignedbb7;
+
+				for (Iterator iterator3 = list1.iterator(); iterator3.hasNext(); d14 = axisalignedbb7.a(axisalignedbb4, d14)) {
+					axisalignedbb7 = (AxisAlignedBB) iterator3.next();
+				}
+
+				axisalignedbb4 = axisalignedbb4.c(d14, 0.0D, 0.0D);
+				double d15 = d8;
+
+				AxisAlignedBB axisalignedbb8;
+
+				for (Iterator iterator4 = list1.iterator(); iterator4.hasNext(); d15 = axisalignedbb8.c(axisalignedbb4, d15)) {
+					axisalignedbb8 = (AxisAlignedBB) iterator4.next();
+				}
+
+				axisalignedbb4 = axisalignedbb4.c(0.0D, 0.0D, d15);
+				AxisAlignedBB axisalignedbb9 = this.getBoundingBox();
+				double d16 = d1;
+
+				AxisAlignedBB axisalignedbb10;
+
+				for (Iterator iterator5 = list1.iterator(); iterator5.hasNext(); d16 = axisalignedbb10.b(axisalignedbb9, d16)) {
+					axisalignedbb10 = (AxisAlignedBB) iterator5.next();
+				}
+
+				axisalignedbb9 = axisalignedbb9.c(0.0D, d16, 0.0D);
+				double d17 = d6;
+
+				AxisAlignedBB axisalignedbb11;
+
+				for (Iterator iterator6 = list1.iterator(); iterator6.hasNext(); d17 = axisalignedbb11.a(axisalignedbb9, d17)) {
+					axisalignedbb11 = (AxisAlignedBB) iterator6.next();
+				}
+
+				axisalignedbb9 = axisalignedbb9.c(d17, 0.0D, 0.0D);
+				double d18 = d8;
+
+				AxisAlignedBB axisalignedbb12;
+
+				for (Iterator iterator7 = list1.iterator(); iterator7.hasNext(); d18 = axisalignedbb12.c(axisalignedbb9, d18)) {
+					axisalignedbb12 = (AxisAlignedBB) iterator7.next();
+				}
+
+				axisalignedbb9 = axisalignedbb9.c(0.0D, 0.0D, d18);
+				double d19 = d14 * d14 + d15 * d15;
+				double d20 = d17 * d17 + d18 * d18;
+
+				if (d19 > d20) {
+					d0 = d14;
+					d2 = d15;
+					d1 = -d13;
+					this.a(axisalignedbb4);
+				} else {
+					d0 = d17;
+					d2 = d18;
+					d1 = -d16;
+					this.a(axisalignedbb9);
+				}
+
+				AxisAlignedBB axisalignedbb13;
+
+				for (Iterator iterator8 = list1.iterator(); iterator8.hasNext(); d1 = axisalignedbb13.b(this.getBoundingBox(), d1)) {
+					axisalignedbb13 = (AxisAlignedBB) iterator8.next();
+				}
+
+				this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+				if (d10 * d10 + d12 * d12 >= d0 * d0 + d2 * d2) {
+					d0 = d10;
+					d1 = d11;
+					d2 = d12;
+					this.a(axisalignedbb3);
+				}
+			}
+
+			this.world.methodProfiler.b();
+			this.world.methodProfiler.a("rest");
+			this.recalcPosition();
+			this.positionChanged = d6 != d0 || d8 != d2;
+			this.E = d7 != d1;
+			this.onGround = this.E && d7 < 0.0D;
+			this.F = this.positionChanged || this.E;
+			int i = MathHelper.floor(this.locX);
+			int j = MathHelper.floor(this.locY - 0.20000000298023224D);
+			int k = MathHelper.floor(this.locZ);
+			BlockPosition blockposition = new BlockPosition(i, j, k);
+			Block block = this.world.getType(blockposition).getBlock();
+
+			if (block.getMaterial() == Material.AIR) {
+				Block block1 = this.world.getType(blockposition.down()).getBlock();
+
+				if (block1 instanceof BlockFence || block1 instanceof BlockCobbleWall || block1 instanceof BlockFenceGate) {
+					block = block1;
+					blockposition = blockposition.down();
+				}
+			}
+
+			this.a(d1, this.onGround, block, blockposition);
+			if (d6 != d0) {
+				this.motX = 0.0D;
+			}
+
+			if (d8 != d2) {
+				this.motZ = 0.0D;
+			}
+
+			if (d7 != d1) {
+				block.a(this.world, this);
+			}
+
+			// CraftBukkit start
+			if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+				Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+				org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX), MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
+
+				if (d6 > d0) {
+					bl = bl.getRelative(BlockFace.EAST);
+				} else if (d6 < d0) {
+					bl = bl.getRelative(BlockFace.WEST);
+				} else if (d8 > d2) {
+					bl = bl.getRelative(BlockFace.SOUTH);
+				} else if (d8 < d2) {
+					bl = bl.getRelative(BlockFace.NORTH);
+				}
+
+				VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+				world.getServer().getPluginManager().callEvent(event);
+			}
+
+			if (this.s_() && !flag && this.vehicle == null) {
+				double d21 = this.locX - d3;
+				double d22 = this.locY - d4;
+				double d23 = this.locZ - d5;
+
+				if (block != Blocks.LADDER) {
+					d22 = 0.0D;
+				}
+
+				this.M = (float) ((double) this.M + MathHelper.sqrt(d21 * d21 + d23 * d23) * 0.6D);
+				this.N = (float) ((double) this.N + MathHelper.sqrt(d21 * d21 + d22 * d22 + d23 * d23) * 0.6D);
+
+				if (this.N > (float) this.h && block.getMaterial() != Material.AIR) {
+					this.h = (int) this.N + 1;
+					if (this.V()) {
+						float f = (float) MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.35F;
+
+						if (f > 1.0F) {
+							f = 1.0F;
+						}
+
+						this.makeSound(this.P(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+					}
+
+					this.a(blockposition, block);
+					block.a(this.world, blockposition, this);
+				}
+			}
+
+			boolean flag2 = this.U();
+
+			if (this.world.e(this.getBoundingBox().shrink(0.001D, 0.001D, 0.001D))) {
+				this.burn(1);
+
+				if (!flag2) {
+					++this.fireTicks;
+
+					if (this.fireTicks <= 0) {
+						EntityCombustEvent event = new EntityCombustEvent(getBukkitEntity(), 8);
+
+						world.getServer().getPluginManager().callEvent(event);
+
+						if (!event.isCancelled()) {
+							setOnFire(event.getDuration());
+						}
+					} else {
+						this.setOnFire(8);
+					}
+				}
+			} else if (this.fireTicks <= 0) {
+				this.fireTicks = -this.maxFireTicks;
+			}
+
+			if (flag2 && this.fireTicks > 0) {
+				this.makeSound("random.fizz", 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+				this.fireTicks = -this.maxFireTicks;
+			}
+
+			this.world.methodProfiler.b();
+		}
+	}
+
+	private void recalcPosition() {
+		this.locX = (this.getBoundingBox().a + this.getBoundingBox().d) / 2.0D;
+		this.locY = this.getBoundingBox().b;
+		this.locZ = (this.getBoundingBox().c + this.getBoundingBox().f) / 2.0D;
+	}
+
+	protected String P() {
+		return "game.neutral.swim";
+	}
+
+	protected void checkBlockCollisions() {
+		BlockPosition blockPosition = new BlockPosition(this.getBoundingBox().a + 0.001D, this.getBoundingBox().b + 0.001D, this.getBoundingBox().c + 0.001D);
+		BlockPosition blockPosition2 = new BlockPosition(this.getBoundingBox().d - 0.001D, this.getBoundingBox().e - 0.001D, this.getBoundingBox().f - 0.001D);
+
+		if (this.world.areChunksLoadedBetween(blockPosition, blockPosition2)) {
+			for (int i = blockPosition.getX(); i <= blockPosition2.getX(); ++i) {
+				for (int j = blockPosition.getY(); j <= blockPosition2.getY(); ++j) {
+					for (int k = blockPosition.getZ(); k <= blockPosition2.getZ(); ++k) {
+						BlockPosition innerBlockPosition = new BlockPosition(i, j, k);
+						IBlockData blockData = this.world.getType(innerBlockPosition);
+
+						try {
+							blockData.getBlock().a(this.world, innerBlockPosition, blockData, this);
+						} catch (Throwable throwable) {
+							CrashReport crashreport = CrashReport.a(throwable, "Colliding entity with block");
+							CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being collided with");
+
+							CrashReportSystemDetails.a(crashreportsystemdetails, innerBlockPosition, blockData);
+							throw new ReportedException(crashreport);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	protected void a(BlockPosition blockposition, Block block) {
+		Block.StepSound stepSound = block.stepSound;
+
+		if (this.world.getType(blockposition.up()).getBlock() == Blocks.SNOW_LAYER) {
+			stepSound = Blocks.SNOW_LAYER.stepSound;
+			this.makeSound(stepSound.getStepSound(), stepSound.getVolume1() * 0.15F, stepSound.getVolume2());
+		} else if (!block.getMaterial().isLiquid()) {
+			this.makeSound(stepSound.getStepSound(), stepSound.getVolume1() * 0.15F, stepSound.getVolume2());
+		}
+	}
+
+	public void makeSound(String s, float f, float f1) {
+		if (!this.R()) {
+			this.world.makeSound(this, s, f, f1);
+		}
+	}
+
+	public boolean R() {
+		return this.datawatcher.getByte(4) == 1;
+	}
+
+	public void b(boolean flag) {
+		this.datawatcher.watch(4, Byte.valueOf((byte) (flag ? 1 : 0)));
+	}
+
+	protected boolean s_() {
+		return true;
+	}
+
+	protected void a(double d0, boolean flag, Block block, BlockPosition blockposition) {
+		if (flag) {
+			if (this.fallDistance > 0.0F) {
+				if (block != null) {
+					block.fallOn(this.world, blockposition, this, this.fallDistance);
+				} else {
+					this.e(this.fallDistance, 1.0F);
+				}
+
+				this.fallDistance = 0.0F;
+			}
+		} else if (d0 < 0.0D) {
+			this.fallDistance = (float) ((double) this.fallDistance - d0);
+		}
+
+	}
+
+	public AxisAlignedBB S() {
+		return null;
+	}
+
+	protected void burn(float i) {
+		if (!this.fireProof) {
+			this.damageEntity(DamageSource.FIRE, i);
+		}
+	}
+
+	public final boolean isFireProof() {
+		return this.fireProof;
+	}
+
+	public void e(float f, float f1) {
+		if (this.passenger != null) {
+			this.passenger.e(f, f1);
+		}
+
+	}
+
+	public boolean U() {
+		return this.inWater || this.world.isRainingAt(new BlockPosition(this.locX, this.locY, this.locZ)) || this.world.isRainingAt(new BlockPosition(this.locX, this.locY + (double) this.length, this.locZ));
+	}
+
+	public boolean V() {
+		return this.inWater;
+	}
+
+	public boolean W() {
+		if (this.world.a(this.getBoundingBox().grow(0.0D, -0.4000000059604645D, 0.0D).shrink(0.001D, 0.001D, 0.001D), Material.WATER, this)) {
+			if (!this.inWater && !this.justCreated) {
+				this.X();
+			}
+
+			this.fallDistance = 0.0F;
+			this.inWater = true;
+			this.fireTicks = 0;
+		} else {
+			this.inWater = false;
+		}
+
+		return this.inWater;
+	}
+
+	protected void X() {
+		float f = (float) MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.2F;
+
+		if (f > 1.0F) {
+			f = 1.0F;
+		}
+
+		this.makeSound(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+
+		float f1 = (float) MathHelper.floor(this.getBoundingBox().b);
+		int i;
+		float f2;
+		float f3;
+
+		for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
+			f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
+			f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
+			this.world.addParticle(EnumParticle.WATER_BUBBLE, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY - (double) (this.random.nextFloat() * 0.2F), this.motZ, new int[0]);
+		}
+
+		for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
+			f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
+			f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
+			this.world.addParticle(EnumParticle.WATER_SPLASH, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY, this.motZ, new int[0]);
+		}
+	}
+
+	public void Y() {
+		if (this.isSprinting() && !this.V()) {
+			this.Z();
+		}
+	}
+
+	protected void Z() {
+		int i = MathHelper.floor(this.locX);
+		int j = MathHelper.floor(this.locY - 0.20000000298023224D);
+		int k = MathHelper.floor(this.locZ);
+		BlockPosition blockposition = new BlockPosition(i, j, k);
+		IBlockData iblockdata = this.world.getType(blockposition);
+		Block block = iblockdata.getBlock();
+
+		if (block.b() != -1) {
+			this.world.addParticle(EnumParticle.BLOCK_CRACK, this.locX + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, this.getBoundingBox().b + 0.1D, this.locZ + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, -this.motX * 4.0D, 1.5D, -this.motZ * 4.0D, new int[]{Block.getCombinedId(iblockdata)});
+		}
+	}
+
+	protected String aa() {
+		return "game.neutral.swim.splash";
+	}
+
+	public boolean a(Material material) {
+		double d0 = this.locY + (double) this.getHeadHeight();
+		BlockPosition blockposition = new BlockPosition(this.locX, d0, this.locZ);
+		IBlockData iblockdata = this.world.getType(blockposition);
+		Block block = iblockdata.getBlock();
+
+		if (block.getMaterial() == material) {
+			float f = BlockFluids.b(iblockdata.getBlock().toLegacyData(iblockdata)) - 0.11111111F;
+			float f1 = (float) (blockposition.getY() + 1) - f;
+			boolean flag = d0 < (double) f1;
+
+			return !flag && this instanceof EntityHuman ? false : flag;
+		} else {
+			return false;
+		}
+	}
+
+	public boolean ab() {
+		return this.world.a(this.getBoundingBox().grow(-0.10000000149011612D, -0.4000000059604645D, -0.10000000149011612D), Material.LAVA);
+	}
+
+	public void a(float f, float f1, float f2) {
+		float f3 = f * f + f1 * f1;
+
+		if (f3 >= 1.0E-4F) {
+			f3 = MathHelper.c(f3);
+			if (f3 < 1.0F) {
+				f3 = 1.0F;
+			}
+
+			f3 = f2 / f3;
+			f *= f3;
+			f1 *= f3;
+			float f4 = (float) MathHelper.sin(this.yaw * 3.1415927F / 180.0F);
+			float f5 = MathHelper.cos(this.yaw * 3.1415927F / 180.0F);
+
+			this.motX += (double) (f * f5 - f1 * f4);
+			this.motZ += (double) (f1 * f5 + f * f4);
+		}
+	}
+
+	public float c(float f) {
+		BlockPosition blockposition = new BlockPosition(this.locX, this.locY + (double) this.getHeadHeight(), this.locZ);
+
+		return this.world.isLoaded(blockposition) ? this.world.o(blockposition) : 0.0F;
+	}
+
+	public void spawnIn(World world) {
+		if (world == null) {
+			die();
+			this.world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
+			return;
+		}
+
+		this.world = world;
+	}
+
+	public void setLocation(double d0, double d1, double d2, float f, float f1) {
+		this.lastX = this.locX = d0;
+		this.lastY = this.locY = d1;
+		this.lastZ = this.locZ = d2;
+		this.lastYaw = this.yaw = f;
+		this.lastPitch = this.pitch = f1;
+		double d3 = (double) (this.lastYaw - f);
+
+		if (d3 < -180.0D) {
+			this.lastYaw += 360.0F;
+		}
+
+		if (d3 >= 180.0D) {
+			this.lastYaw -= 360.0F;
+		}
+
+		this.setPosition(this.locX, this.locY, this.locZ);
+		this.setYawPitch(f, f1);
+	}
+
+	public void setPositionRotation(BlockPosition blockposition, float f, float f1) {
+		this.setPositionRotation((double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, f, f1);
+	}
+
+	public void setPositionRotation(double d0, double d1, double d2, float f, float f1) {
+		this.P = this.lastX = this.locX = d0;
+		this.Q = this.lastY = this.locY = d1;
+		this.R = this.lastZ = this.locZ = d2;
+		this.yaw = f;
+		this.pitch = f1;
+		this.setPosition(this.locX, this.locY, this.locZ);
+	}
+
+	public float g(Entity entity) {
+		float f = (float) (this.locX - entity.locX);
+		float f1 = (float) (this.locY - entity.locY);
+		float f2 = (float) (this.locZ - entity.locZ);
+
+		return MathHelper.c(f * f + f1 * f1 + f2 * f2);
+	}
+
+	public double e(double d0, double d1, double d2) {
+		double d3 = this.locX - d0;
+		double d4 = this.locY - d1;
+		double d5 = this.locZ - d2;
+
+		return d3 * d3 + d4 * d4 + d5 * d5;
+	}
+
+	public double b(BlockPosition blockposition) {
+		return blockposition.c(this.locX, this.locY, this.locZ);
+	}
+
+	public double c(BlockPosition blockposition) {
+		return blockposition.d(this.locX, this.locY, this.locZ);
+	}
+
+	public double f(double d0, double d1, double d2) {
+		double d3 = this.locX - d0;
+		double d4 = this.locY - d1;
+		double d5 = this.locZ - d2;
+
+		return MathHelper.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
+	}
+
+	public double h(Entity entity) {
+		double d0 = this.locX - entity.locX;
+		double d1 = this.locY - entity.locY;
+		double d2 = this.locZ - entity.locZ;
+
+		return d0 * d0 + d1 * d1 + d2 * d2;
+	}
+
+	public void d(EntityHuman entityhuman) {
+	}
+
+	int numCollisions = 0;
+
+	public void collide(Entity entity) {
+		if (entity.passenger != this && entity.vehicle != this) {
+			if (!entity.noclip && !this.noclip) {
+				double d0 = entity.locX - this.locX;
+				double d1 = entity.locZ - this.locZ;
+				double d2 = MathHelper.a(d0, d1);
+
+				if (d2 >= 0.009999999776482582D) {
+					d2 = MathHelper.sqrt(d2);
+					d0 /= d2;
+					d1 /= d2;
+					double d3 = 1.0D / d2;
+
+					if (d3 > 1.0D) {
+						d3 = 1.0D;
+					}
+
+					d0 *= d3;
+					d1 *= d3;
+					d0 *= 0.05000000074505806D;
+					d1 *= 0.05000000074505806D;
+					d0 *= (double) (1.0F - this.U);
+					d1 *= (double) (1.0F - this.U);
+
+					if (this.passenger == null) {
+						this.g(-d0, 0.0D, -d1);
+					}
+
+					if (entity.passenger == null) {
+						entity.g(d0, 0.0D, d1);
+					}
+				}
+
+			}
+		}
+	}
+
+	public void g(double d0, double d1, double d2) {
+		this.motX += d0;
+		this.motY += d1;
+		this.motZ += d2;
+		this.ai = true;
+	}
+
+	protected void ac() {
+		this.velocityChanged = true;
+	}
+
+	public boolean damageEntity(DamageSource damagesource, float f) {
+		if (this.isInvulnerable(damagesource)) {
+			return false;
+		} else {
+			this.ac();
+			return false;
+		}
+	}
+
+	public Vec3D d(float f) {
+		if (f == 1.0F) {
+			return this.f(this.pitch, this.yaw);
+		} else {
+			float f1 = this.lastPitch + (this.pitch - this.lastPitch) * f;
+			float f2 = this.lastYaw + (this.yaw - this.lastYaw) * f;
+
+			return this.f(f1, f2);
+		}
+	}
+
+	protected final Vec3D f(float f, float f1) {
+		float f2 = MathHelper.cos(-f1 * 0.017453292F - 3.1415927F);
+		float f3 = (float) MathHelper.sin(-f1 * 0.017453292F - 3.1415927F);
+		float f4 = -MathHelper.cos(-f * 0.017453292F);
+		float f5 = (float) MathHelper.sin(-f * 0.017453292F);
+
+		return new Vec3D((double) (f3 * f4), (double) f5, (double) (f2 * f4));
+	}
+
+	public boolean ad() {
+		return false;
+	}
+
+	public boolean ae() {
+		return false;
+	}
+
+	public void b(Entity entity, int i) {
+	}
+
+	public boolean c(NBTTagCompound nbttagcompound) {
+		String s = this.ag();
+
+		if (!this.dead && s != null) {
+			nbttagcompound.setString("id", s);
+			this.e(nbttagcompound);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public boolean d(NBTTagCompound nbttagcompound) {
+		String s = this.ag();
+
+		if (!this.dead && s != null && this.passenger == null) {
+			nbttagcompound.setString("id", s);
+			this.e(nbttagcompound);
+			return true;
+		} else {
+			return false;
+		}
+	}
+
+	public void e(NBTTagCompound nbttagcompound) {
+		try {
+			nbttagcompound.set("Pos", this.a(new double[]{this.locX, this.locY, this.locZ}));
+			nbttagcompound.set("Motion", this.a(new double[]{this.motX, this.motY, this.motZ}));
+
+			if (Float.isNaN(this.yaw)) {
+				this.yaw = 0;
+			}
+
+			if (Float.isNaN(this.pitch)) {
+				this.pitch = 0;
+			}
+
+			nbttagcompound.set("Rotation", this.a(this.yaw, this.pitch));
+			nbttagcompound.setFloat("FallDistance", this.fallDistance);
+			nbttagcompound.setShort("Fire", (short) this.fireTicks);
+			nbttagcompound.setShort("Air", (short) this.getAirTicks());
+			nbttagcompound.setBoolean("OnGround", this.onGround);
+			nbttagcompound.setInt("Dimension", this.dimension);
+			nbttagcompound.setBoolean("Invulnerable", this.invulnerable);
+			nbttagcompound.setInt("PortalCooldown", this.portalCooldown);
+			nbttagcompound.setLong("UUIDMost", this.getUniqueID().getMostSignificantBits());
+			nbttagcompound.setLong("UUIDLeast", this.getUniqueID().getLeastSignificantBits());
+			nbttagcompound.setLong("WorldUUIDLeast", this.world.getDataManager().getUUID().getLeastSignificantBits());
+			nbttagcompound.setLong("WorldUUIDMost", this.world.getDataManager().getUUID().getMostSignificantBits());
+			nbttagcompound.setInt("Bukkit.updateLevel", CURRENT_LEVEL);
+			nbttagcompound.setInt("Spigot.ticksLived", this.ticksLived);
+
+			if (this.getCustomName() != null && this.getCustomName().length() > 0) {
+				nbttagcompound.setString("CustomName", this.getCustomName());
+				nbttagcompound.setBoolean("CustomNameVisible", this.getCustomNameVisible());
+			}
+
+			this.au.b(nbttagcompound);
+			if (this.R()) {
+				nbttagcompound.setBoolean("Silent", this.R());
+			}
+
+			this.b(nbttagcompound);
+			if (this.vehicle != null) {
+				NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+				if (this.vehicle.c(nbttagcompound1)) {
+					nbttagcompound.set("Riding", nbttagcompound1);
+				}
+			}
+
+		} catch (Throwable throwable) {
+			CrashReport crashreport = CrashReport.a(throwable, "Saving entity NBT");
+			CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being saved");
+
+			this.appendEntityCrashDetails(crashreportsystemdetails);
+			throw new ReportedException(crashreport);
+		}
+	}
+
+	public void f(NBTTagCompound nbttagcompound) {
+		try {
+			NBTTagList nbttaglist = nbttagcompound.getList("Pos", 6);
+			NBTTagList nbttaglist1 = nbttagcompound.getList("Motion", 6);
+			NBTTagList nbttaglist2 = nbttagcompound.getList("Rotation", 5);
+
+			this.motX = nbttaglist1.d(0);
+			this.motY = nbttaglist1.d(1);
+			this.motZ = nbttaglist1.d(2);
+			this.lastX = this.P = this.locX = nbttaglist.d(0);
+			this.lastY = this.Q = this.locY = nbttaglist.d(1);
+			this.lastZ = this.R = this.locZ = nbttaglist.d(2);
+			this.lastYaw = this.yaw = nbttaglist2.e(0);
+			this.lastPitch = this.pitch = nbttaglist2.e(1);
+
+			this.f(this.yaw);
+			this.g(this.yaw);
+
+			this.fallDistance = nbttagcompound.getFloat("FallDistance");
+			this.fireTicks = nbttagcompound.getShort("Fire");
+			this.setAirTicks(nbttagcompound.getShort("Air"));
+			this.onGround = nbttagcompound.getBoolean("OnGround");
+			this.dimension = nbttagcompound.getInt("Dimension");
+			this.invulnerable = nbttagcompound.getBoolean("Invulnerable");
+			this.portalCooldown = nbttagcompound.getInt("PortalCooldown");
+
+			if (nbttagcompound.hasKeyOfType("UUIDMost", 4) && nbttagcompound.hasKeyOfType("UUIDLeast", 4)) {
+				this.uniqueID = new UUID(nbttagcompound.getLong("UUIDMost"), nbttagcompound.getLong("UUIDLeast"));
+			} else if (nbttagcompound.hasKeyOfType("UUID", 8)) {
+				this.uniqueID = UUID.fromString(nbttagcompound.getString("UUID"));
+			}
+
+			this.setPosition(this.locX, this.locY, this.locZ);
+			this.setYawPitch(this.yaw, this.pitch);
+
+			if (nbttagcompound.hasKeyOfType("CustomName", 8) && nbttagcompound.getString("CustomName").length() > 0) {
+				this.setCustomName(nbttagcompound.getString("CustomName"));
+			}
+
+			this.setCustomNameVisible(nbttagcompound.getBoolean("CustomNameVisible"));
+			this.au.a(nbttagcompound);
+			this.b(nbttagcompound.getBoolean("Silent"));
+			this.a(nbttagcompound);
+
+			if (this.af()) {
+				this.setPosition(this.locX, this.locY, this.locZ);
+			}
+
+			if (this instanceof EntityLiving) {
+				EntityLiving entity = (EntityLiving) this;
+
+				this.ticksLived = nbttagcompound.getInt("Spigot.ticksLived");
+
+				if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) {
+					EntityInsentient entityinsentient = (EntityInsentient) entity;
+					entityinsentient.persistent = !entityinsentient.isTypeNotPersistent();
+				}
+			}
+
+			if (!(getBukkitEntity() instanceof Vehicle)) {
+				if (Math.abs(this.motX) > 10.0D) {
+					this.motX = 0.0D;
+				}
+
+				if (Math.abs(this.motY) > 10.0D) {
+					this.motY = 0.0D;
+				}
+
+				if (Math.abs(this.motZ) > 10.0D) {
+					this.motZ = 0.0D;
+				}
+			}
+
+			if (this instanceof EntityPlayer) {
+				Server server = Bukkit.getServer();
+				org.bukkit.World bworld = null;
+
+				// TODO: Remove World related checks, replaced with WorldUID
+				String worldName = nbttagcompound.getString("world");
+
+				if (nbttagcompound.hasKey("WorldUUIDMost") && nbttagcompound.hasKey("WorldUUIDLeast")) {
+					UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast"));
+					bworld = server.getWorld(uid);
+				} else {
+					bworld = server.getWorld(worldName);
+				}
+
+				if (bworld == null) {
+					EntityPlayer entityPlayer = (EntityPlayer) this;
+					bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(entityPlayer.dimension).getWorld();
+				}
+
+				spawnIn(bworld == null ? null : ((CraftWorld) bworld).getHandle());
+			}
+		} catch (Throwable throwable) {
+			CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT");
+			CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being loaded");
+
+			this.appendEntityCrashDetails(crashreportsystemdetails);
+			throw new ReportedException(crashreport);
+		}
+	}
+
+	protected boolean af() {
+		return true;
+	}
+
+	protected final String ag() {
+		return EntityTypes.b(this);
+	}
+
+	protected abstract void a(NBTTagCompound nbttagcompound);
+
+	protected abstract void b(NBTTagCompound nbttagcompound);
+
+	public void ah() {
+	}
+
+	protected NBTTagList a(double... adouble) {
+		NBTTagList nbttaglist = new NBTTagList();
+		double[] adouble1 = adouble;
+		int i = adouble.length;
+
+		for (int j = 0; j < i; ++j) {
+			double d0 = adouble1[j];
+
+			nbttaglist.add(new NBTTagDouble(d0));
+		}
+
+		return nbttaglist;
+	}
+
+	protected NBTTagList a(float... afloat) {
+		NBTTagList nbttaglist = new NBTTagList();
+		float[] afloat1 = afloat;
+		int i = afloat.length;
+
+		for (int j = 0; j < i; ++j) {
+			float f = afloat1[j];
+
+			nbttaglist.add(new NBTTagFloat(f));
+		}
+
+		return nbttaglist;
+	}
+
+	public EntityItem a(Item item, int i) {
+		return this.a(item, i, 0.0F);
+	}
+
+	public EntityItem a(Item item, int i, float f) {
+		return this.a(new ItemStack(item, i, 0), f);
+	}
+
+	public EntityItem a(ItemStack itemstack, float f) {
+		if (itemstack.count != 0 && itemstack.getItem() != null) {
+			if (this instanceof EntityLiving && ((EntityLiving) this).drops != null) {
+				((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack));
+				return null;
+			}
+
+			EntityItem entityitem = new EntityItem(this.world, this.locX, this.locY + (double) f, this.locZ, itemstack);
+
+			entityitem.p();
+			this.world.addEntity(entityitem);
+
+			return entityitem;
+		} else {
+			return null;
+		}
+	}
+
+	public boolean isAlive() {
+		return !this.dead;
+	}
+
+	public boolean inBlock() {
+		if (this.noclip) {
+			return false;
+		} else {
+			BlockPosition.MutableBlockPosition mutableBlockPosition = new BlockPosition.MutableBlockPosition(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
+
+			for (int i = 0; i < 8; ++i) {
+				int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
+				int k = MathHelper.floor(this.locX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
+				int l = MathHelper.floor(this.locZ + (double) (((float) ((i >> 2) % 2) - 0.5F) * this.width * 0.8F));
+
+				if (mutableBlockPosition.getX() != k || mutableBlockPosition.getY() != j || mutableBlockPosition.getZ() != l) {
+					mutableBlockPosition.c(k, j, l);
+					if (this.world.getType(mutableBlockPosition).getBlock().w()) {
+						return true;
+					}
+				}
+			}
+
+			return false;
+		}
+	}
+
+	public boolean e(EntityHuman entityhuman) {
+		return false;
+	}
+
+	public AxisAlignedBB j(Entity entity) {
+		return null;
+	}
+
+	public void ak() {
+		if (this.vehicle.dead) {
+			this.vehicle = null;
+		} else {
+			this.motX = 0.0D;
+			this.motY = 0.0D;
+			this.motZ = 0.0D;
+			this.t_();
+			if (this.vehicle != null) {
+				this.vehicle.al();
+				this.as += (double) (this.vehicle.yaw - this.vehicle.lastYaw);
+
+				for (this.ar += (double) (this.vehicle.pitch - this.vehicle.lastPitch); this.as >= 180.0D; this.as -= 360.0D) {
+					;
+				}
+
+				while (this.as < -180.0D) {
+					this.as += 360.0D;
+				}
+
+				while (this.ar >= 180.0D) {
+					this.ar -= 360.0D;
+				}
+
+				while (this.ar < -180.0D) {
+					this.ar += 360.0D;
+				}
+
+				double d0 = this.as * 0.5D;
+				double d1 = this.ar * 0.5D;
+				float f = 10.0F;
+
+				if (d0 > (double) f) {
+					d0 = (double) f;
+				}
+
+				if (d0 < (double) (-f)) {
+					d0 = (double) (-f);
+				}
+
+				if (d1 > (double) f) {
+					d1 = (double) f;
+				}
+
+				if (d1 < (double) (-f)) {
+					d1 = (double) (-f);
+				}
+
+				this.as -= d0;
+				this.ar -= d1;
+			}
+		}
+	}
+
+	public void al() {
+		if (this.passenger != null) {
+			this.passenger.setPosition(this.locX, this.locY + this.an() + this.passenger.am(), this.locZ);
+		}
+	}
+
+	public double am() {
+		return 0.0D;
+	}
+
+	public double an() {
+		return (double) this.length * 0.75D;
+	}
+
+	protected CraftEntity bukkitEntity;
+
+	public CraftEntity getBukkitEntity() {
+		if (bukkitEntity == null) {
+			bukkitEntity = CraftEntity.getEntity(world.getServer(), this);
+		}
+		return bukkitEntity;
+	}
+
+	public void mount(Entity entity) {
+		Entity originalVehicle = this.vehicle;
+		Entity originalPassenger = this.vehicle == null ? null : this.vehicle.passenger;
+		PluginManager pluginManager = Bukkit.getPluginManager();
+
+		getBukkitEntity();
+
+		this.ar = 0.0D;
+		this.as = 0.0D;
+
+		if (entity == null) {
+			if (this.vehicle != null) {
+				if ((this.bukkitEntity instanceof LivingEntity) && (this.vehicle.getBukkitEntity() instanceof Vehicle)) {
+					VehicleExitEvent event = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
+
+					pluginManager.callEvent(event);
+
+					if (event.isCancelled() || vehicle != originalVehicle) {
+						return;
+					}
+				}
+
+				EntityDismountEvent dismountEvent = new EntityDismountEvent(this.getBukkitEntity(), this.vehicle.getBukkitEntity());
+
+				pluginManager.callEvent(dismountEvent);
+
+				if (dismountEvent.isCancelled()) {
+					return;
+				}
+
+				this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
 
-            this.appendEntityCrashDetails(crashreportsystemdetails);
-            throw new ReportedException(crashreport);
-        }
-    }
+				this.vehicle.passenger = null;
+			}
 
-    protected boolean af() {
-        return true;
-    }
+			this.vehicle = null;
+		} else {
+			if ((this.bukkitEntity instanceof LivingEntity) && (entity.getBukkitEntity() instanceof Vehicle) && entity.world.isChunkLoaded((int) entity.locX >> 4, (int) entity.locZ >> 4, true)) {
+				VehicleExitEvent exitEvent = null;
 
-    protected final String ag() {
-        return EntityTypes.b(this);
-    }
+				if (this.vehicle != null && this.vehicle.getBukkitEntity() instanceof Vehicle) {
+					exitEvent = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
 
-    protected abstract void a(NBTTagCompound nbttagcompound);
+					pluginManager.callEvent(exitEvent);
 
-    protected abstract void b(NBTTagCompound nbttagcompound);
+					if (exitEvent.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
+						return;
+					}
+				}
 
-    public void ah() {}
+				VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.bukkitEntity);
 
-    protected NBTTagList a(double... adouble) {
-        NBTTagList nbttaglist = new NBTTagList();
-        double[] adouble1 = adouble;
-        int i = adouble.length;
+				pluginManager.callEvent(event);
 
-        for (int j = 0; j < i; ++j) {
-            double d0 = adouble1[j];
+				if (event.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
+					if (exitEvent != null && this.vehicle == originalVehicle && this.vehicle != null && this.vehicle.passenger == originalPassenger) {
+						this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
+						this.vehicle.passenger = null;
+						this.vehicle = null;
+					}
 
-            nbttaglist.add(new NBTTagDouble(d0));
-        }
+					return;
+				}
+			}
 
-        return nbttaglist;
-    }
+			if (entity.world.isChunkLoaded((int) entity.locX >> 4, (int) entity.locZ >> 4, true)) {
+				org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent(this.getBukkitEntity(), entity.getBukkitEntity());
 
-    protected NBTTagList a(float... afloat) {
-        NBTTagList nbttaglist = new NBTTagList();
-        float[] afloat1 = afloat;
-        int i = afloat.length;
+				pluginManager.callEvent(event);
 
-        for (int j = 0; j < i; ++j) {
-            float f = afloat1[j];
+				if (event.isCancelled()) {
+					return;
+				}
+			}
 
-            nbttaglist.add(new NBTTagFloat(f));
-        }
-
-        return nbttaglist;
-    }
-
-    public EntityItem a(Item item, int i) {
-        return this.a(item, i, 0.0F);
-    }
-
-    public EntityItem a(Item item, int i, float f) {
-        return this.a(new ItemStack(item, i, 0), f);
-    }
-
-    public EntityItem a(ItemStack itemstack, float f) {
-        if (itemstack.count != 0 && itemstack.getItem() != null) {
-            // CraftBukkit start - Capture drops for death event
-            if (this instanceof EntityLiving && ((EntityLiving) this).drops != null) {
-                ((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack));
-                return null;
-            }
-            // CraftBukkit end
-            EntityItem entityitem = new EntityItem(this.world, this.locX, this.locY + (double) f, this.locZ, itemstack);
-
-            entityitem.p();
-            this.world.addEntity(entityitem);
-            return entityitem;
-        } else {
-            return null;
-        }
-    }
-
-    public boolean isAlive() {
-        return !this.dead;
-    }
-
-    public boolean inBlock() {
-        if (this.noclip) {
-            return false;
-        } else {
-            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE);
-
-            for (int i = 0; i < 8; ++i) {
-                int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
-                int k = MathHelper.floor(this.locX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
-                int l = MathHelper.floor(this.locZ + (double) (((float) ((i >> 2) % 2) - 0.5F) * this.width * 0.8F));
-
-                if (blockposition_mutableblockposition.getX() != k || blockposition_mutableblockposition.getY() != j || blockposition_mutableblockposition.getZ() != l) {
-                    blockposition_mutableblockposition.c(k, j, l);
-                    if (this.world.getType(blockposition_mutableblockposition).getBlock().w()) {
-                        return true;
-                    }
-                }
-            }
-
-            return false;
-        }
-    }
-
-    public boolean e(EntityHuman entityhuman) {
-        return false;
-    }
-
-    public AxisAlignedBB j(Entity entity) {
-        return null;
-    }
-
-    public void ak() {
-        if (this.vehicle.dead) {
-            this.vehicle = null;
-        } else {
-            this.motX = 0.0D;
-            this.motY = 0.0D;
-            this.motZ = 0.0D;
-            this.t_();
-            if (this.vehicle != null) {
-                this.vehicle.al();
-                this.as += (double) (this.vehicle.yaw - this.vehicle.lastYaw);
-
-                for (this.ar += (double) (this.vehicle.pitch - this.vehicle.lastPitch); this.as >= 180.0D; this.as -= 360.0D) {
-                    ;
-                }
+			if (this.vehicle != null) {
+				this.vehicle.passenger = null;
+			}
 
-                while (this.as < -180.0D) {
-                    this.as += 360.0D;
-                }
+			if (entity != null) {
+				for (Entity entity1 = entity.vehicle; entity1 != null; entity1 = entity1.vehicle) {
+					if (entity1 == this) {
+						return;
+					}
+				}
+			}
 
-                while (this.ar >= 180.0D) {
-                    this.ar -= 360.0D;
-                }
+			this.vehicle = entity;
+			entity.passenger = this;
+		}
+	}
 
-                while (this.ar < -180.0D) {
-                    this.ar += 360.0D;
-                }
+	public float ao() {
+		return 0.1F;
+	}
 
-                double d0 = this.as * 0.5D;
-                double d1 = this.ar * 0.5D;
-                float f = 10.0F;
+	public Vec3D ap() {
+		return null;
+	}
 
-                if (d0 > (double) f) {
-                    d0 = (double) f;
-                }
+	public void d(BlockPosition blockposition) {
+		if (this.portalCooldown > 0) {
+			this.portalCooldown = this.aq();
+		} else {
+			if (!this.world.isClientSide && !blockposition.equals(this.an)) {
+				this.an = blockposition;
+				ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = Blocks.PORTAL.f(this.world, blockposition);
+				double d0 = shapedetector_shapedetectorcollection.b().k() == EnumDirection.EnumAxis.X ? (double) shapedetector_shapedetectorcollection.a().getZ() : (double) shapedetector_shapedetectorcollection.a().getX();
+				double d1 = shapedetector_shapedetectorcollection.b().k() == EnumDirection.EnumAxis.X ? this.locZ : this.locX;
 
-                if (d0 < (double) (-f)) {
-                    d0 = (double) (-f);
-                }
+				d1 = Math.abs(MathHelper.c(d1 - (double) (shapedetector_shapedetectorcollection.b().e().c() == EnumDirection.EnumAxisDirection.NEGATIVE ? 1 : 0), d0, d0 - (double) shapedetector_shapedetectorcollection.d()));
+				double d2 = MathHelper.c(this.locY - 1.0D, (double) shapedetector_shapedetectorcollection.a().getY(), (double) (shapedetector_shapedetectorcollection.a().getY() - shapedetector_shapedetectorcollection.e()));
 
-                if (d1 > (double) f) {
-                    d1 = (double) f;
-                }
+				this.ao = new Vec3D(d1, d2, 0.0D);
+				this.ap = shapedetector_shapedetectorcollection.b();
+			}
 
-                if (d1 < (double) (-f)) {
-                    d1 = (double) (-f);
-                }
+			this.ak = true;
+		}
+	}
 
-                this.as -= d0;
-                this.ar -= d1;
-            }
-        }
-    }
-
-    public void al() {
-        if (this.passenger != null) {
-            this.passenger.setPosition(this.locX, this.locY + this.an() + this.passenger.am(), this.locZ);
-        }
-    }
-
-    public double am() {
-        return 0.0D;
-    }
-
-    public double an() {
-        return (double) this.length * 0.75D;
-    }
-
-    // CraftBukkit start
-    protected CraftEntity bukkitEntity;
-
-    public CraftEntity getBukkitEntity() {
-        if (bukkitEntity == null) {
-            bukkitEntity = CraftEntity.getEntity(world.getServer(), this);
-        }
-        return bukkitEntity;
-    }
-
-    public void mount(Entity entity) {
-        Entity originalVehicle = this.vehicle;
-        Entity originalPassenger = this.vehicle == null ? null : this.vehicle.passenger;
-        PluginManager pluginManager = Bukkit.getPluginManager();
-        getBukkitEntity(); // make sure bukkitEntity is initialised
-        // CraftBukkit end
-        this.ar = 0.0D;
-        this.as = 0.0D;
-        if (entity == null) {
-            if (this.vehicle != null) {
-                // CraftBukkit start
-                if ((this.bukkitEntity instanceof LivingEntity) && (this.vehicle.getBukkitEntity() instanceof Vehicle)) {
-                    VehicleExitEvent event = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
-                    pluginManager.callEvent(event);
-
-                    if (event.isCancelled() || vehicle != originalVehicle) {
-                        return;
-                    }
-                }
-                // CraftBukkit end
-                // PaperSpigot start - make EntityDismountEvent cancellable
-                EntityDismountEvent dismountEvent = new EntityDismountEvent(this.getBukkitEntity(), this.vehicle.getBukkitEntity()); // Spigot
-                pluginManager.callEvent(dismountEvent);
-                if (dismountEvent.isCancelled()) return;
-                // PaperSpigot end
-                this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
-                this.vehicle.passenger = null;
-            }
+	public int aq() {
+		return 300;
+	}
 
-            this.vehicle = null;
-        } else {
-            // CraftBukkit start
-            if ((this.bukkitEntity instanceof LivingEntity) && (entity.getBukkitEntity() instanceof Vehicle) && entity.world.isChunkLoaded((int) entity.locX >> 4, (int) entity.locZ >> 4, true)) {
-                // It's possible to move from one vehicle to another.  We need to check if they're already in a vehicle, and fire an exit event if they are.
-                VehicleExitEvent exitEvent = null;
-                if (this.vehicle != null && this.vehicle.getBukkitEntity() instanceof Vehicle) {
-                    exitEvent = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
-                    pluginManager.callEvent(exitEvent);
-
-                    if (exitEvent.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
-                        return;
-                    }
-                }
+	public ItemStack[] getEquipment() {
+		return null;
+	}
 
-                VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.bukkitEntity);
-                pluginManager.callEvent(event);
-
-                // If a plugin messes with the vehicle or the vehicle's passenger
-                if (event.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
-                    // If we only cancelled the enterevent then we need to put the player in a decent position.
-                    if (exitEvent != null && this.vehicle == originalVehicle && this.vehicle != null && this.vehicle.passenger == originalPassenger) {
-                        this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
-                        this.vehicle.passenger = null;
-                        this.vehicle = null;
-                    }
-                    return;
-                }
-            }
-            // CraftBukkit end
-            // Spigot Start
-            if ( entity.world.isChunkLoaded( (int) entity.locX >> 4, (int) entity.locZ >> 4, true ) )
-            {
-                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent( this.getBukkitEntity(), entity.getBukkitEntity() );
-                pluginManager.callEvent( event );
-                if ( event.isCancelled() )
-                {
-                    return;
-                }
-            }
-            // Spigot End
+	public void setEquipment(int i, ItemStack itemstack) {
+	}
 
-            if (this.vehicle != null) {
-                this.vehicle.passenger = null;
-            }
+	public boolean isBurning() {
+		boolean flag = this.world != null && this.world.isClientSide;
 
-            if (entity != null) {
-                for (Entity entity1 = entity.vehicle; entity1 != null; entity1 = entity1.vehicle) {
-                    if (entity1 == this) {
-                        return;
-                    }
-                }
-            }
+		return !this.fireProof && (this.fireTicks > 0 || flag && this.g(0));
+	}
 
-            this.vehicle = entity;
-            entity.passenger = this;
-        }
-    }
-
-    public float ao() {
-        return 0.1F;
-    }
-
-    public Vec3D ap() {
-        return null;
-    }
-
-    public void d(BlockPosition blockposition) {
-        if (this.portalCooldown > 0) {
-            this.portalCooldown = this.aq();
-        } else {
-            if (!this.world.isClientSide && !blockposition.equals(this.an)) {
-                this.an = blockposition;
-                ShapeDetector.ShapeDetectorCollection shapedetector_shapedetectorcollection = Blocks.PORTAL.f(this.world, blockposition);
-                double d0 = shapedetector_shapedetectorcollection.b().k() == EnumDirection.EnumAxis.X ? (double) shapedetector_shapedetectorcollection.a().getZ() : (double) shapedetector_shapedetectorcollection.a().getX();
-                double d1 = shapedetector_shapedetectorcollection.b().k() == EnumDirection.EnumAxis.X ? this.locZ : this.locX;
-
-                d1 = Math.abs(MathHelper.c(d1 - (double) (shapedetector_shapedetectorcollection.b().e().c() == EnumDirection.EnumAxisDirection.NEGATIVE ? 1 : 0), d0, d0 - (double) shapedetector_shapedetectorcollection.d()));
-                double d2 = MathHelper.c(this.locY - 1.0D, (double) shapedetector_shapedetectorcollection.a().getY(), (double) (shapedetector_shapedetectorcollection.a().getY() - shapedetector_shapedetectorcollection.e()));
-
-                this.ao = new Vec3D(d1, d2, 0.0D);
-                this.ap = shapedetector_shapedetectorcollection.b();
-            }
+	public boolean au() {
+		return this.vehicle != null;
+	}
 
-            this.ak = true;
-        }
-    }
+	public boolean isSneaking() {
+		return this.g(1);
+	}
 
-    public int aq() {
-        return 300;
-    }
+	public void setSneaking(boolean flag) {
+		this.b(1, flag);
+	}
 
-    public ItemStack[] getEquipment() {
-        return null;
-    }
+	public boolean isSprinting() {
+		return this.g(3);
+	}
+
+	public void setSprinting(boolean flag) {
+		this.b(3, flag);
+	}
+
+	public boolean isInvisible() {
+		return this.g(5);
+	}
+
+	public void setInvisible(boolean flag) {
+		this.b(5, flag);
+	}
+
+	public void f(boolean flag) {
+		this.b(4, flag);
+	}
+
+	protected boolean g(int i) {
+		return (this.datawatcher.getByte(0) & 1 << i) != 0;
+	}
+
+	protected void b(int i, boolean flag) {
+		byte b0 = this.datawatcher.getByte(0);
+
+		if (flag) {
+			this.datawatcher.watch(0, Byte.valueOf((byte) (b0 | 1 << i)));
+		} else {
+			this.datawatcher.watch(0, Byte.valueOf((byte) (b0 & ~(1 << i))));
+		}
+	}
+
+	public int getAirTicks() {
+		return this.datawatcher.getShort(1);
+	}
+
+	public void setAirTicks(int i) {
+		this.datawatcher.watch(1, Short.valueOf((short) i));
+	}
+
+	public void onLightningStrike(EntityLightning entitylightning) {
+		// CraftBukkit start
+		final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+		final org.bukkit.entity.Entity stormBukkitEntity = entitylightning.getBukkitEntity();
+		final PluginManager pluginManager = Bukkit.getPluginManager();
+
+		if (thisBukkitEntity instanceof Hanging) {
+			HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
+			PaintingBreakByEntityEvent paintingEvent = null;
+
+			if (thisBukkitEntity instanceof Painting) {
+				paintingEvent = new PaintingBreakByEntityEvent((Painting) thisBukkitEntity, stormBukkitEntity);
+			}
 
-    public void setEquipment(int i, ItemStack itemstack) {}
+			pluginManager.callEvent(hangingEvent);
 
-    public boolean isBurning() {
-        boolean flag = this.world != null && this.world.isClientSide;
+			if (paintingEvent != null) {
+				paintingEvent.setCancelled(hangingEvent.isCancelled());
+				pluginManager.callEvent(paintingEvent);
+			}
 
-        return !this.fireProof && (this.fireTicks > 0 || flag && this.g(0));
-    }
+			if (hangingEvent.isCancelled() || (paintingEvent != null && paintingEvent.isCancelled())) {
+				return;
+			}
+		}
+
+		if (this.fireProof) {
+			return;
+		}
+
+		CraftEventFactory.entityDamage = entitylightning;
+
+		if (!this.damageEntity(DamageSource.LIGHTNING, 5.0F)) {
+			CraftEventFactory.entityDamage = null;
+			return;
+		}
 
-    public boolean au() {
-        return this.vehicle != null;
-    }
-
-    public boolean isSneaking() {
-        return this.g(1);
-    }
-
-    public void setSneaking(boolean flag) {
-        this.b(1, flag);
-    }
-
-    public boolean isSprinting() {
-        return this.g(3);
-    }
-
-    public void setSprinting(boolean flag) {
-        this.b(3, flag);
-    }
-
-    public boolean isInvisible() {
-        return this.g(5);
-    }
-
-    public void setInvisible(boolean flag) {
-        this.b(5, flag);
-    }
-
-    public void f(boolean flag) {
-        this.b(4, flag);
-    }
-
-    protected boolean g(int i) {
-        return (this.datawatcher.getByte(0) & 1 << i) != 0;
-    }
-
-    protected void b(int i, boolean flag) {
-        byte b0 = this.datawatcher.getByte(0);
-
-        if (flag) {
-            this.datawatcher.watch(0, Byte.valueOf((byte) (b0 | 1 << i)));
-        } else {
-            this.datawatcher.watch(0, Byte.valueOf((byte) (b0 & ~(1 << i))));
-        }
-
-    }
-
-    public int getAirTicks() {
-        return this.datawatcher.getShort(1);
-    }
-
-    public void setAirTicks(int i) {
-        this.datawatcher.watch(1, Short.valueOf((short) i));
-    }
-
-    public void onLightningStrike(EntityLightning entitylightning) {
-        // CraftBukkit start
-        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
-        final org.bukkit.entity.Entity stormBukkitEntity = entitylightning.getBukkitEntity();
-        final PluginManager pluginManager = Bukkit.getPluginManager();
-
-        if (thisBukkitEntity instanceof Hanging) {
-            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
-            PaintingBreakByEntityEvent paintingEvent = null;
-
-            if (thisBukkitEntity instanceof Painting) {
-                paintingEvent = new PaintingBreakByEntityEvent((Painting) thisBukkitEntity, stormBukkitEntity);
-            }
-
-            pluginManager.callEvent(hangingEvent);
-
-            if (paintingEvent != null) {
-                paintingEvent.setCancelled(hangingEvent.isCancelled());
-                pluginManager.callEvent(paintingEvent);
-            }
-
-            if (hangingEvent.isCancelled() || (paintingEvent != null && paintingEvent.isCancelled())) {
-                return;
-            }
-        }
-
-        if (this.fireProof) {
-            return;
-        }
-        CraftEventFactory.entityDamage = entitylightning;
-        if (!this.damageEntity(DamageSource.LIGHTNING, 5.0F)) {
-            CraftEventFactory.entityDamage = null;
-            return;
-        }
-        // CraftBukkit end
-        ++this.fireTicks;
-        if (this.fireTicks == 0) {
-            // CraftBukkit start - Call a combust event when lightning strikes
-            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
-            pluginManager.callEvent(entityCombustEvent);
-            if (!entityCombustEvent.isCancelled()) {
-                this.setOnFire(entityCombustEvent.getDuration());
-            }
-            // CraftBukkit end
-        }
-
-    }
-
-    public void a(EntityLiving entityliving) {}
-
-    protected boolean j(double d0, double d1, double d2) {
-        BlockPosition blockposition = new BlockPosition(d0, d1, d2);
-        double d3 = d0 - (double) blockposition.getX();
-        double d4 = d1 - (double) blockposition.getY();
-        double d5 = d2 - (double) blockposition.getZ();
-        List list = this.world.a(this.getBoundingBox());
-
-        if (list.isEmpty() && !this.world.u(blockposition)) {
-            return false;
-        } else {
-            byte b0 = 3;
-            double d6 = 9999.0D;
-
-            if (!this.world.u(blockposition.west()) && d3 < d6) {
-                d6 = d3;
-                b0 = 0;
-            }
-
-            if (!this.world.u(blockposition.east()) && 1.0D - d3 < d6) {
-                d6 = 1.0D - d3;
-                b0 = 1;
-            }
-
-            if (!this.world.u(blockposition.up()) && 1.0D - d4 < d6) {
-                d6 = 1.0D - d4;
-                b0 = 3;
-            }
-
-            if (!this.world.u(blockposition.north()) && d5 < d6) {
-                d6 = d5;
-                b0 = 4;
-            }
-
-            if (!this.world.u(blockposition.south()) && 1.0D - d5 < d6) {
-                d6 = 1.0D - d5;
-                b0 = 5;
-            }
-
-            float f = this.random.nextFloat() * 0.2F + 0.1F;
-
-            if (b0 == 0) {
-                this.motX = (double) (-f);
-            }
-
-            if (b0 == 1) {
-                this.motX = (double) f;
-            }
-
-            if (b0 == 3) {
-                this.motY = (double) f;
-            }
-
-            if (b0 == 4) {
-                this.motZ = (double) (-f);
-            }
-
-            if (b0 == 5) {
-                this.motZ = (double) f;
-            }
-
-            return true;
-        }
-    }
-
-    public void aA() {
-        this.H = true;
-        this.fallDistance = 0.0F;
-    }
-
-    public String getName() {
-        if (this.hasCustomName()) {
-            return this.getCustomName();
-        } else {
-            String s = EntityTypes.b(this);
-
-            if (s == null) {
-                s = "generic";
-            }
-
-            return LocaleI18n.get("entity." + s + ".name");
-        }
-    }
-
-    public Entity[] aB() {
-        return null;
-    }
-
-    public boolean k(Entity entity) {
-        return this == entity;
-    }
-
-    public float getHeadRotation() {
-        return 0.0F;
-    }
-
-    public void f(float f) {}
-
-    public void g(float f) {}
-
-    public boolean aD() {
-        return true;
-    }
-
-    public boolean l(Entity entity) {
-        return false;
-    }
-
-    public String toString() {
-        return String.format("%s[\'%s\'/%d, l=\'%s\', x=%.2f, y=%.2f, z=%.2f]", new Object[] { this.getClass().getSimpleName(), this.getName(), Integer.valueOf(this.id), this.world == null ? "~NULL~" : this.world.getWorldData().getName(), Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)});
-    }
-
-    public boolean isInvulnerable(DamageSource damagesource) {
-        return this.invulnerable && damagesource != DamageSource.OUT_OF_WORLD && !damagesource.u();
-    }
-
-    public void m(Entity entity) {
-        this.setPositionRotation(entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
-    }
-
-    public void n(Entity entity) {
-        NBTTagCompound nbttagcompound = new NBTTagCompound();
-
-        entity.e(nbttagcompound);
-        this.f(nbttagcompound);
-        this.portalCooldown = entity.portalCooldown;
-        this.an = entity.an;
-        this.ao = entity.ao;
-        this.ap = entity.ap;
-    }
-
-    public void c(int i) {
-        if (!this.world.isClientSide && !this.dead) {
-            this.world.methodProfiler.a("changeDimension");
-            MinecraftServer minecraftserver = MinecraftServer.getServer();
-            // CraftBukkit start - Move logic into new function "teleportToLocation"
-            // int j = this.dimension;
-            // WorldServer worldserver = minecraftserver.getWorldServer(j);
-            // WorldServer worldserver1 = minecraftserver.getWorldServer(i);
-            WorldServer exitWorld = null;
-            if (this.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // Plugins must specify exit from custom Bukkit worlds
-                // Only target existing worlds (compensate for allow-nether/allow-end as false)
-                for (WorldServer world : minecraftserver.worlds) {
-                    if (world.dimension == i) {
-                        exitWorld = world;
-                    }
-                }
-            }
-
-            Location enter = this.getBukkitEntity().getLocation();
-            Location exit = exitWorld != null ? minecraftserver.getPlayerList().calculateTarget(enter, minecraftserver.getWorldServer(i)) : null;
-            boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
-
-            TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getTravelAgent() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
-            EntityPortalEvent event = new EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
-            event.useTravelAgent(useTravelAgent);
-            event.getEntity().getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isAlive()) {
-                return;
-            }
-            exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
-            this.teleportTo(exit, true);
-        }
-    }
-
-    public void teleportTo(Location exit, boolean portal) {
-        if (true) {
-            WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
-            WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
-            int i = worldserver1.dimension;
-            // CraftBukkit end
-
-            this.dimension = i;
+		++this.fireTicks;
+
+		if (this.fireTicks == 0) {
+			EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+
+			pluginManager.callEvent(entityCombustEvent);
+
+			if (!entityCombustEvent.isCancelled()) {
+				this.setOnFire(entityCombustEvent.getDuration());
+			}
+		}
+
+	}
+
+	public void a(EntityLiving entityliving) {
+	}
+
+	protected boolean j(double d0, double d1, double d2) {
+		BlockPosition blockposition = new BlockPosition(d0, d1, d2);
+		double d3 = d0 - (double) blockposition.getX();
+		double d4 = d1 - (double) blockposition.getY();
+		double d5 = d2 - (double) blockposition.getZ();
+		List list = this.world.a(this.getBoundingBox());
+
+		if (list.isEmpty() && !this.world.u(blockposition)) {
+			return false;
+		} else {
+			byte b0 = 3;
+			double d6 = 9999.0D;
+
+			if (!this.world.u(blockposition.west()) && d3 < d6) {
+				d6 = d3;
+				b0 = 0;
+			}
+
+			if (!this.world.u(blockposition.east()) && 1.0D - d3 < d6) {
+				d6 = 1.0D - d3;
+				b0 = 1;
+			}
+
+			if (!this.world.u(blockposition.up()) && 1.0D - d4 < d6) {
+				d6 = 1.0D - d4;
+				b0 = 3;
+			}
+
+			if (!this.world.u(blockposition.north()) && d5 < d6) {
+				d6 = d5;
+				b0 = 4;
+			}
+
+			if (!this.world.u(blockposition.south()) && 1.0D - d5 < d6) {
+				d6 = 1.0D - d5;
+				b0 = 5;
+			}
+
+			float f = this.random.nextFloat() * 0.2F + 0.1F;
+
+			if (b0 == 0) {
+				this.motX = (double) (-f);
+			}
+
+			if (b0 == 1) {
+				this.motX = (double) f;
+			}
+
+			if (b0 == 3) {
+				this.motY = (double) f;
+			}
+
+			if (b0 == 4) {
+				this.motZ = (double) (-f);
+			}
+
+			if (b0 == 5) {
+				this.motZ = (double) f;
+			}
+
+			return true;
+		}
+	}
+
+	public void aA() {
+		this.H = true;
+		this.fallDistance = 0.0F;
+	}
+
+	public String getName() {
+		if (this.hasCustomName()) {
+			return this.getCustomName();
+		} else {
+			String s = EntityTypes.b(this);
+
+			if (s == null) {
+				s = "generic";
+			}
+
+			return LocaleI18n.get("entity." + s + ".name");
+		}
+	}
+
+	public Entity[] aB() {
+		return null;
+	}
+
+	public boolean k(Entity entity) {
+		return this == entity;
+	}
+
+	public float getHeadRotation() {
+		return 0.0F;
+	}
+
+	public void f(float f) {
+	}
+
+	public void g(float f) {
+	}
+
+	public boolean aD() {
+		return true;
+	}
+
+	public boolean l(Entity entity) {
+		return false;
+	}
+
+	public String toString() {
+		return String.format("%s[\'%s\'/%d, l=\'%s\', x=%.2f, y=%.2f, z=%.2f]", new Object[]{this.getClass().getSimpleName(), this.getName(), Integer.valueOf(this.id), this.world == null ? "~NULL~" : this.world.getWorldData().getName(), Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)});
+	}
+
+	public boolean isInvulnerable(DamageSource damagesource) {
+		return this.invulnerable && damagesource != DamageSource.OUT_OF_WORLD && !damagesource.u();
+	}
+
+	public void m(Entity entity) {
+		this.setPositionRotation(entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
+	}
+
+	public void n(Entity entity) {
+		NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+		entity.e(nbttagcompound);
+		this.f(nbttagcompound);
+		this.portalCooldown = entity.portalCooldown;
+		this.an = entity.an;
+		this.ao = entity.ao;
+		this.ap = entity.ap;
+	}
+
+	public void c(int i) {
+		if (!this.world.isClientSide && !this.dead) {
+			this.world.methodProfiler.a("changeDimension");
+			MinecraftServer minecraftserver = MinecraftServer.getServer();
+			// CraftBukkit start - Move logic into new function "teleportToLocation"
+			// int j = this.dimension;
+			// WorldServer worldserver = minecraftserver.getWorldServer(j);
+			// WorldServer worldserver1 = minecraftserver.getWorldServer(i);
+			WorldServer exitWorld = null;
+			if (this.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // Plugins must specify exit from custom Bukkit worlds
+				// Only target existing worlds (compensate for allow-nether/allow-end as false)
+				for (WorldServer world : minecraftserver.worlds) {
+					if (world.dimension == i) {
+						exitWorld = world;
+					}
+				}
+			}
+
+			Location enter = this.getBukkitEntity().getLocation();
+			Location exit = exitWorld != null ? minecraftserver.getPlayerList().calculateTarget(enter, minecraftserver.getWorldServer(i)) : null;
+			boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
+
+			TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getTravelAgent() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+			EntityPortalEvent event = new EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
+			event.useTravelAgent(useTravelAgent);
+			event.getEntity().getServer().getPluginManager().callEvent(event);
+			if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isAlive()) {
+				return;
+			}
+			exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+			this.teleportTo(exit, true);
+		}
+	}
+
+	public void teleportTo(Location exit, boolean portal) {
+		if (true) {
+			WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
+			WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+			int i = worldserver1.dimension;
+			// CraftBukkit end
+
+			this.dimension = i;
             /* CraftBukkit start - TODO: Check if we need this
             if (j == 1 && i == 1) {
                 worldserver1 = minecraftserver.getWorldServer(0);
@@ -1977,21 +1966,21 @@ public abstract class Entity implements ICommandListener {
             }
             // CraftBukkit end */
 
-            this.world.kill(this);
-            this.dead = false;
-            this.world.methodProfiler.a("reposition");
-            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
-            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
-            boolean before = worldserver1.chunkProviderServer.forceChunkLoad;
-            worldserver1.chunkProviderServer.forceChunkLoad = true;
-            worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
-            worldserver1.chunkProviderServer.forceChunkLoad = before;
-            // CraftBukkit end
-            this.world.methodProfiler.c("reloading");
-            Entity entity = EntityTypes.createEntityByName(EntityTypes.b(this), worldserver1);
-
-            if (entity != null) {
-                entity.n(this);
+			this.world.kill(this);
+			this.dead = false;
+			this.world.methodProfiler.a("reposition");
+			// CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
+			// minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
+			boolean before = worldserver1.chunkProviderServer.forceChunkLoad;
+			worldserver1.chunkProviderServer.forceChunkLoad = true;
+			worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
+			worldserver1.chunkProviderServer.forceChunkLoad = before;
+			// CraftBukkit end
+			this.world.methodProfiler.c("reloading");
+			Entity entity = EntityTypes.createEntityByName(EntityTypes.b(this), worldserver1);
+
+			if (entity != null) {
+				entity.n(this);
                 /* CraftBukkit start - We need to do this...
                 if (j == 1 && i == 1) {
                     BlockPosition blockposition = this.world.r(worldserver1.getSpawn());
@@ -2000,258 +1989,284 @@ public abstract class Entity implements ICommandListener {
                 }
                 // CraftBukkit end */
 
-                worldserver1.addEntity(entity);
-                // CraftBukkit start - Forward the CraftEntity to the new entity
-                this.getBukkitEntity().setHandle(entity);
-                entity.bukkitEntity = this.getBukkitEntity();
-
-                if (this instanceof EntityInsentient) {
-                    ((EntityInsentient)this).unleash(true, false); // Unleash to prevent duping of leads.
-                }
-                // CraftBukkit end
-            }
-
-            this.dead = true;
-            this.world.methodProfiler.b();
-            worldserver.j();
-            worldserver1.j();
-            this.world.methodProfiler.b();
-        }
-    }
-
-    public float a(Explosion explosion, World world, BlockPosition blockposition, IBlockData iblockdata) {
-        return iblockdata.getBlock().a(this);
-    }
-
-    public boolean a(Explosion explosion, World world, BlockPosition blockposition, IBlockData iblockdata, float f) {
-        return true;
-    }
-
-    public int aE() {
-        return 3;
-    }
-
-    public Vec3D aG() {
-        return this.ao;
-    }
-
-    public EnumDirection aH() {
-        return this.ap;
-    }
-
-    public boolean aI() {
-        return false;
-    }
-
-    public void appendEntityCrashDetails(CrashReportSystemDetails crashreportsystemdetails) {
-        crashreportsystemdetails.a("Entity Type", new Callable() {
-            public String a() throws Exception {
-                return EntityTypes.b(Entity.this) + " (" + Entity.this.getClass().getCanonicalName() + ")";
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        crashreportsystemdetails.a("Entity ID", (Object) Integer.valueOf(this.id));
-        crashreportsystemdetails.a("Entity Name", new Callable() {
-            public String a() throws Exception {
-                return Entity.this.getName();
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        crashreportsystemdetails.a("Entity\'s Exact location", (Object) String.format("%.2f, %.2f, %.2f", new Object[] { Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)}));
-        crashreportsystemdetails.a("Entity\'s Block location", (Object) CrashReportSystemDetails.a((double) MathHelper.floor(this.locX), (double) MathHelper.floor(this.locY), (double) MathHelper.floor(this.locZ)));
-        crashreportsystemdetails.a("Entity\'s Momentum", (Object) String.format("%.2f, %.2f, %.2f", new Object[] { Double.valueOf(this.motX), Double.valueOf(this.motY), Double.valueOf(this.motZ)}));
-        crashreportsystemdetails.a("Entity\'s Rider", new Callable() {
-            public String a() throws Exception {
-                return Entity.this.passenger.toString();
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        crashreportsystemdetails.a("Entity\'s Vehicle", new Callable() {
-            public String a() throws Exception {
-                return Entity.this.vehicle.toString();
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-    }
-
-    public UUID getUniqueID() {
-        return this.uniqueID;
-    }
-
-    public boolean aL() {
-        return true;
-    }
-
-    public IChatBaseComponent getScoreboardDisplayName() {
-        ChatComponentText chatcomponenttext = new ChatComponentText(this.getName());
-
-        chatcomponenttext.getChatModifier().setChatHoverable(this.aQ());
-        chatcomponenttext.getChatModifier().setInsertion(this.getUniqueID().toString());
-        return chatcomponenttext;
-    }
-
-    public void setCustomName(String s) {
-        // CraftBukkit start - Add a sane limit for name length
-        if (s.length() > 256) {
-            s = s.substring(0, 256);
-        }
-        // CraftBukkit end
-        this.datawatcher.watch(2, s);
-    }
-
-    public String getCustomName() {
-        return this.datawatcher.getString(2);
-    }
-
-    public boolean hasCustomName() {
-        return this.datawatcher.getString(2).length() > 0;
-    }
-
-    public void setCustomNameVisible(boolean flag) {
-        this.datawatcher.watch(3, Byte.valueOf((byte) (flag ? 1 : 0)));
-    }
-
-    public boolean getCustomNameVisible() {
-        return this.datawatcher.getByte(3) == 1;
-    }
-
-    public void enderTeleportTo(double d0, double d1, double d2) {
-        this.setPositionRotation(d0, d1, d2, this.yaw, this.pitch);
-    }
-
-    public void i(int i) {}
-
-    public EnumDirection getDirection() {
-        return EnumDirection.fromType2(MathHelper.floor((double) (this.yaw * 4.0F / 360.0F) + 0.5D) & 3);
-    }
-
-    protected ChatHoverable aQ() {
-        NBTTagCompound nbttagcompound = new NBTTagCompound();
-        String s = EntityTypes.b(this);
-
-        nbttagcompound.setString("id", this.getUniqueID().toString());
-        if (s != null) {
-            nbttagcompound.setString("type", s);
-        }
-
-        nbttagcompound.setString("name", this.getName());
-        return new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_ENTITY, new ChatComponentText(nbttagcompound.toString()));
-    }
-
-    public boolean a(EntityPlayer entityplayer) {
-        return true;
-    }
-
-    public AxisAlignedBB getBoundingBox() {
-        return this.boundingBox;
-    }
-
-    public void a(AxisAlignedBB axisalignedbb) {
-        // CraftBukkit start - block invalid bounding boxes
-        double a = axisalignedbb.a,
-                b = axisalignedbb.b,
-                c = axisalignedbb.c,
-                d = axisalignedbb.d,
-                e = axisalignedbb.e,
-                f = axisalignedbb.f;
-        double len = axisalignedbb.d - axisalignedbb.a;
-        if (len < 0) d = a;
-        if (len > 64) d = a + 64.0;
-
-        len = axisalignedbb.e - axisalignedbb.b;
-        if (len < 0) e = b;
-        if (len > 64) e = b + 64.0;
-
-        len = axisalignedbb.f - axisalignedbb.c;
-        if (len < 0) f = c;
-        if (len > 64) f = c + 64.0;
-        this.boundingBox = new AxisAlignedBB(a, b, c, d, e, f);
-        // CraftBukkit end
-    }
-
-    public float getHeadHeight() {
-        return this.length * 0.85F;
-    }
-
-    public boolean aT() {
-        return this.g;
-    }
-
-    public void h(boolean flag) {
-        this.g = flag;
-    }
-
-    public boolean d(int i, ItemStack itemstack) {
-        return false;
-    }
-
-    public void sendMessage(IChatBaseComponent ichatbasecomponent) {}
-
-    public boolean a(int i, String s) {
-        return true;
-    }
-
-    public BlockPosition getChunkCoordinates() {
-        return new BlockPosition(this.locX, this.locY + 0.5D, this.locZ);
-    }
-
-    public Vec3D d() {
-        return new Vec3D(this.locX, this.locY, this.locZ);
-    }
-
-    public World getWorld() {
-        return this.world;
-    }
-
-    public Entity f() {
-        return this;
-    }
-
-    public boolean getSendCommandFeedback() {
-        return false;
-    }
-
-    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {
-        this.au.a(this, commandobjectiveexecutor_enumcommandresult, i);
-    }
-
-    public CommandObjectiveExecutor aU() {
-        return this.au;
-    }
-
-    public void o(Entity entity) {
-        this.au.a(entity.aU());
-    }
-
-    public NBTTagCompound getNBTTag() {
-        return null;
-    }
-
-    public boolean a(EntityHuman entityhuman, Vec3D vec3d) {
-        return false;
-    }
-
-    public boolean aW() {
-        return false;
-    }
-
-    protected void a(EntityLiving entityliving, Entity entity) {
-        if (entity instanceof EntityLiving) {
-            EnchantmentManager.a((EntityLiving) entity, (Entity) entityliving);
-        }
-
-        EnchantmentManager.b(entityliving, entity);
-    }
+				worldserver1.addEntity(entity);
+				// CraftBukkit start - Forward the CraftEntity to the new entity
+				this.getBukkitEntity().setHandle(entity);
+				entity.bukkitEntity = this.getBukkitEntity();
+
+				if (this instanceof EntityInsentient) {
+					((EntityInsentient) this).unleash(true, false); // Unleash to prevent duping of leads.
+				}
+				// CraftBukkit end
+			}
+
+			this.dead = true;
+			this.world.methodProfiler.b();
+			worldserver.j();
+			worldserver1.j();
+			this.world.methodProfiler.b();
+		}
+	}
+
+	public float a(Explosion explosion, World world, BlockPosition blockposition, IBlockData iblockdata) {
+		return iblockdata.getBlock().a(this);
+	}
+
+	public boolean a(Explosion explosion, World world, BlockPosition blockposition, IBlockData iblockdata, float f) {
+		return true;
+	}
+
+	public int aE() {
+		return 3;
+	}
+
+	public Vec3D aG() {
+		return this.ao;
+	}
+
+	public EnumDirection aH() {
+		return this.ap;
+	}
+
+	public boolean aI() {
+		return false;
+	}
+
+	public void appendEntityCrashDetails(CrashReportSystemDetails crashreportsystemdetails) {
+		crashreportsystemdetails.a("Entity Type", new Callable() {
+			public String a() throws Exception {
+				return EntityTypes.b(Entity.this) + " (" + Entity.this.getClass().getCanonicalName() + ")";
+			}
+
+			public Object call() throws Exception {
+				return this.a();
+			}
+		});
+		crashreportsystemdetails.a("Entity ID", (Object) Integer.valueOf(this.id));
+		crashreportsystemdetails.a("Entity Name", new Callable() {
+			public String a() throws Exception {
+				return Entity.this.getName();
+			}
+
+			public Object call() throws Exception {
+				return this.a();
+			}
+		});
+		crashreportsystemdetails.a("Entity\'s Exact location", (Object) String.format("%.2f, %.2f, %.2f", new Object[]{Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)}));
+		crashreportsystemdetails.a("Entity\'s Block location", (Object) CrashReportSystemDetails.a((double) MathHelper.floor(this.locX), (double) MathHelper.floor(this.locY), (double) MathHelper.floor(this.locZ)));
+		crashreportsystemdetails.a("Entity\'s Momentum", (Object) String.format("%.2f, %.2f, %.2f", new Object[]{Double.valueOf(this.motX), Double.valueOf(this.motY), Double.valueOf(this.motZ)}));
+		crashreportsystemdetails.a("Entity\'s Rider", new Callable() {
+			public String a() throws Exception {
+				return Entity.this.passenger.toString();
+			}
+
+			public Object call() throws Exception {
+				return this.a();
+			}
+		});
+		crashreportsystemdetails.a("Entity\'s Vehicle", new Callable() {
+			public String a() throws Exception {
+				return Entity.this.vehicle.toString();
+			}
+
+			public Object call() throws Exception {
+				return this.a();
+			}
+		});
+	}
+
+	public UUID getUniqueID() {
+		return this.uniqueID;
+	}
+
+	public boolean aL() {
+		return true;
+	}
+
+	public IChatBaseComponent getScoreboardDisplayName() {
+		ChatComponentText chatcomponenttext = new ChatComponentText(this.getName());
+
+		chatcomponenttext.getChatModifier().setChatHoverable(this.aQ());
+		chatcomponenttext.getChatModifier().setInsertion(this.getUniqueID().toString());
+		return chatcomponenttext;
+	}
+
+	public void setCustomName(String s) {
+		// CraftBukkit start - Add a sane limit for name length
+		if (s.length() > 256) {
+			s = s.substring(0, 256);
+		}
+		// CraftBukkit end
+		this.datawatcher.watch(2, s);
+	}
+
+	public String getCustomName() {
+		return this.datawatcher.getString(2);
+	}
+
+	public boolean hasCustomName() {
+		return this.datawatcher.getString(2).length() > 0;
+	}
+
+	public void setCustomNameVisible(boolean flag) {
+		this.datawatcher.watch(3, Byte.valueOf((byte) (flag ? 1 : 0)));
+	}
+
+	public boolean getCustomNameVisible() {
+		return this.datawatcher.getByte(3) == 1;
+	}
+
+	public void enderTeleportTo(double d0, double d1, double d2) {
+		this.setPositionRotation(d0, d1, d2, this.yaw, this.pitch);
+	}
+
+	public void i(int i) {
+	}
+
+	public EnumDirection getDirection() {
+		return EnumDirection.fromType2(MathHelper.floor((double) (this.yaw * 4.0F / 360.0F) + 0.5D) & 3);
+	}
+
+	protected ChatHoverable aQ() {
+		NBTTagCompound nbttagcompound = new NBTTagCompound();
+		String s = EntityTypes.b(this);
+
+		nbttagcompound.setString("id", this.getUniqueID().toString());
+		if (s != null) {
+			nbttagcompound.setString("type", s);
+		}
+
+		nbttagcompound.setString("name", this.getName());
+		return new ChatHoverable(ChatHoverable.EnumHoverAction.SHOW_ENTITY, new ChatComponentText(nbttagcompound.toString()));
+	}
+
+	public boolean a(EntityPlayer entityplayer) {
+		return true;
+	}
+
+	public AxisAlignedBB getBoundingBox() {
+		return this.boundingBox;
+	}
+
+	public void a(AxisAlignedBB axisalignedbb) {
+		// CraftBukkit start - block invalid bounding boxes
+		double a = axisalignedbb.a,
+				b = axisalignedbb.b,
+				c = axisalignedbb.c,
+				d = axisalignedbb.d,
+				e = axisalignedbb.e,
+				f = axisalignedbb.f;
+		double len = axisalignedbb.d - axisalignedbb.a;
+		if (len < 0) d = a;
+		if (len > 64) d = a + 64.0;
+
+		len = axisalignedbb.e - axisalignedbb.b;
+		if (len < 0) e = b;
+		if (len > 64) e = b + 64.0;
+
+		len = axisalignedbb.f - axisalignedbb.c;
+		if (len < 0) f = c;
+		if (len > 64) f = c + 64.0;
+		this.boundingBox = new AxisAlignedBB(a, b, c, d, e, f);
+		// CraftBukkit end
+	}
+
+	public float getHeadHeight() {
+		return this.length * 0.85F;
+	}
+
+	public boolean aT() {
+		return this.g;
+	}
+
+	public void h(boolean flag) {
+		this.g = flag;
+	}
+
+	public boolean d(int i, ItemStack itemstack) {
+		return false;
+	}
+
+	public void sendMessage(IChatBaseComponent ichatbasecomponent) {
+	}
+
+	public boolean a(int i, String s) {
+		return true;
+	}
+
+	public BlockPosition getChunkCoordinates() {
+		return new BlockPosition(this.locX, this.locY + 0.5D, this.locZ);
+	}
+
+	public Vec3D d() {
+		return new Vec3D(this.locX, this.locY, this.locZ);
+	}
+
+	public World getWorld() {
+		return this.world;
+	}
+
+	public Entity f() {
+		return this;
+	}
+
+	public boolean getSendCommandFeedback() {
+		return false;
+	}
+
+	public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {
+		this.au.a(this, commandobjectiveexecutor_enumcommandresult, i);
+	}
+
+	public CommandObjectiveExecutor aU() {
+		return this.au;
+	}
+
+	public void o(Entity entity) {
+		this.au.a(entity.aU());
+	}
+
+	public NBTTagCompound getNBTTag() {
+		return null;
+	}
+
+	public boolean a(EntityHuman entityhuman, Vec3D vec3d) {
+		return false;
+	}
+
+	public boolean aW() {
+		return false;
+	}
+
+	public double getX() {
+		return locX;
+	}
+
+	public double getY() {
+		return locY;
+	}
+
+	public double getZ() {
+		return locZ;
+	}
+
+	protected void a(EntityLiving entityliving, Entity entity) {
+		if (entity instanceof EntityLiving) {
+			EnchantmentManager.a((EntityLiving) entity, (Entity) entityliving);
+		}
+
+		EnchantmentManager.b(entityliving, entity);
+	}
+
+	// TacoSpigot start
+	@Override
+	public boolean isNeedRemoval() {
+		return this.needsRemoval;
+	}
+
+	@Override
+	public void markRemoval() {
+		this.needsRemoval = true;
+	}
+	// TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/EntityArrow.java b/src/main/java/net/minecraft/server/EntityArrow.java
index eac0363c..074b4f43 100644
--- a/src/main/java/net/minecraft/server/EntityArrow.java
+++ b/src/main/java/net/minecraft/server/EntityArrow.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import java.util.List;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.player.PlayerPickupItemEvent;
@@ -103,7 +104,7 @@ public class EntityArrow extends Entity implements IProjectile {
     }
 
     public void shoot(double d0, double d1, double d2, float f, float f1) {
-        float f2 = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+        float f2 = (float) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
 
         d0 /= (double) f2;
         d1 /= (double) f2;
@@ -117,7 +118,7 @@ public class EntityArrow extends Entity implements IProjectile {
         this.motX = d0;
         this.motY = d1;
         this.motZ = d2;
-        float f3 = MathHelper.sqrt(d0 * d0 + d2 * d2);
+        float f3 = (float) MathHelper.sqrt(d0 * d0 + d2 * d2);
 
         this.lastYaw = this.yaw = (float) (MathHelper.b(d0, d2) * 180.0D / 3.1415927410125732D);
         this.lastPitch = this.pitch = (float) (MathHelper.b(d1, (double) f3) * 180.0D / 3.1415927410125732D);
@@ -127,7 +128,7 @@ public class EntityArrow extends Entity implements IProjectile {
     public void t_() {
         super.t_();
         if (this.lastPitch == 0.0F && this.lastYaw == 0.0F) {
-            float f = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+            float f = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
             this.lastYaw = this.yaw = (float) (MathHelper.b(this.motX, this.motZ) * 180.0D / 3.1415927410125732D);
             this.lastPitch = this.pitch = (float) (MathHelper.b(this.motY, (double) f) * 180.0D / 3.1415927410125732D);
@@ -231,7 +232,7 @@ public class EntityArrow extends Entity implements IProjectile {
             if (movingobjectposition != null) {
                 org.bukkit.craftbukkit.event.CraftEventFactory.callProjectileHitEvent(this); // CraftBukkit - Call event
                 if (movingobjectposition.entity != null) {
-                    f2 = MathHelper.sqrt(this.motX * this.motX + this.motY * this.motY + this.motZ * this.motZ);
+                    f2 = (float) MathHelper.sqrt(this.motX * this.motX + this.motY * this.motY + this.motZ * this.motZ);
                     int k = MathHelper.f((double) f2 * this.damage);
 
                     if (this.isCritical()) {
@@ -266,7 +267,7 @@ public class EntityArrow extends Entity implements IProjectile {
                             }
 
                             if (this.knockbackStrength > 0) {
-                                f3 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+                                f3 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
                                 if (f3 > 0.0F) {
                                     movingobjectposition.entity.g(this.motX * (double) this.knockbackStrength * 0.6000000238418579D / (double) f3, 0.1D, this.motZ * (double) this.knockbackStrength * 0.6000000238418579D / (double) f3);
                                 }
@@ -307,11 +308,11 @@ public class EntityArrow extends Entity implements IProjectile {
                     this.motX = (double) ((float) (movingobjectposition.pos.a - this.locX));
                     this.motY = (double) ((float) (movingobjectposition.pos.b - this.locY));
                     this.motZ = (double) ((float) (movingobjectposition.pos.c - this.locZ));
-                    f1 = MathHelper.sqrt(this.motX * this.motX + this.motY * this.motY + this.motZ * this.motZ);
+                    f1 = (float) MathHelper.sqrt(this.motX * this.motX + this.motY * this.motY + this.motZ * this.motZ);
                     this.locX -= this.motX / (double) f1 * 0.05000000074505806D;
                     this.locY -= this.motY / (double) f1 * 0.05000000074505806D;
                     this.locZ -= this.motZ / (double) f1 * 0.05000000074505806D;
-                    this.makeSound("random.bowhit", 1.0F, 1.2F / (this.random.nextFloat() * 0.2F + 0.9F));
+                    // this.makeSound("random.bowhit", 1.0F, 1.2F / (this.random.nextFloat() * 0.2F + 0.9F));
                     this.inGround = true;
                     this.shake = 7;
                     this.setCritical(false);
@@ -330,7 +331,7 @@ public class EntityArrow extends Entity implements IProjectile {
             this.locX += this.motX;
             this.locY += this.motY;
             this.locZ += this.motZ;
-            f2 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+            f2 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
             this.yaw = (float) (MathHelper.b(this.motX, this.motZ) * 180.0D / 3.1415927410125732D);
 
             for (this.pitch = (float) (MathHelper.b(this.motY, (double) f2) * 180.0D / 3.1415927410125732D); this.pitch - this.lastPitch < -180.0F; this.lastPitch -= 360.0F) {
diff --git a/src/main/java/net/minecraft/server/EntityChicken.java b/src/main/java/net/minecraft/server/EntityChicken.java
index 0d279987..6707a49d 100644
--- a/src/main/java/net/minecraft/server/EntityChicken.java
+++ b/src/main/java/net/minecraft/server/EntityChicken.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 public class EntityChicken extends EntityAnimal {
 
     public float bm;
@@ -133,7 +135,7 @@ public class EntityChicken extends EntityAnimal {
 
     public void al() {
         super.al();
-        float f = MathHelper.sin(this.aI * 3.1415927F / 180.0F);
+        float f = (float) MathHelper.sin(this.aI * 3.1415927F / 180.0F);
         float f1 = MathHelper.cos(this.aI * 3.1415927F / 180.0F);
         float f2 = 0.1F;
         float f3 = 0.0F;
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index d246ae74..d8f36868 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -6,6 +6,7 @@ import java.util.Iterator;
 import java.util.List;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.BlockStateListPopulator;
@@ -102,7 +103,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
             this.world.addParticle(EnumParticle.EXPLOSION_LARGE, this.locX + (double) f, this.locY + 2.0D + (double) f1, this.locZ + (double) f2, 0.0D, 0.0D, 0.0D, new int[0]);
         } else {
             this.n();
-            f = 0.2F / (MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ) * 10.0F + 1.0F);
+            f = 0.2F / (float) (MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ) * 10.0F + 1.0F);
             f *= (float) Math.pow(2.0D, this.motY);
             if (this.bx) {
                 this.bv += f * 0.5F;
@@ -201,7 +202,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
                     }
 
                     this.bb *= 0.8F;
-                    float f5 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ) * 1.0F + 1.0F;
+                    float f5 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ) * 1.0F + 1.0F;
                     double d10 = Math.sqrt(this.motX * this.motX + this.motZ * this.motZ) * 1.0D + 1.0D;
 
                     if (d10 > 40.0D) {
@@ -242,9 +243,9 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
                 this.bt.width = 4.0F;
                 f1 = (float) (this.b(5, 1.0F)[1] - this.b(10, 1.0F)[1]) * 10.0F / 180.0F * 3.1415927F;
                 f2 = MathHelper.cos(f1);
-                float f9 = -MathHelper.sin(f1);
+                float f9 = (float) -MathHelper.sin(f1);
                 float f10 = this.yaw * 3.1415927F / 180.0F;
-                float f11 = MathHelper.sin(f10);
+                float f11 = (float) MathHelper.sin(f10);
                 float f12 = MathHelper.cos(f10);
 
                 this.bo.t_();
@@ -262,7 +263,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
                 double[] adouble = this.b(5, 1.0F);
                 double[] adouble1 = this.b(0, 1.0F);
 
-                f3 = MathHelper.sin(this.yaw * 3.1415927F / 180.0F - this.bb * 0.01F);
+                f3 = (float) MathHelper.sin(this.yaw * 3.1415927F / 180.0F - this.bb * 0.01F);
                 float f13 = MathHelper.cos(this.yaw * 3.1415927F / 180.0F - this.bb * 0.01F);
 
                 this.bn.t_();
@@ -285,7 +286,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
 
                     double[] adouble2 = this.b(12 + j * 2, 1.0F);
                     float f14 = this.yaw * 3.1415927F / 180.0F + this.b(adouble2[0] - adouble[0]) * 3.1415927F / 180.0F * 1.0F;
-                    float f15 = MathHelper.sin(f14);
+                    float f15 = (float) MathHelper.sin(f14);
                     float f16 = MathHelper.cos(f14);
                     float f17 = 1.5F;
                     float f18 = (float) (j + 1) * 2.0F;
@@ -514,7 +515,7 @@ public class EntityEnderDragon extends EntityInsentient implements IComplex, IMo
         }
 
         float f1 = this.yaw * 3.1415927F / 180.0F;
-        float f2 = MathHelper.sin(f1);
+        float f2 = (float) MathHelper.sin(f1);
         float f3 = MathHelper.cos(f1);
 
         this.a = this.locX + (double) (f2 * 5.0F) + (double) ((this.random.nextFloat() - 0.5F) * 2.0F);
diff --git a/src/main/java/net/minecraft/server/EntityEnderPearl.java b/src/main/java/net/minecraft/server/EntityEnderPearl.java
index 319c0bc6..79ee7aef 100644
--- a/src/main/java/net/minecraft/server/EntityEnderPearl.java
+++ b/src/main/java/net/minecraft/server/EntityEnderPearl.java
@@ -50,6 +50,9 @@ public class EntityEnderPearl extends EntityProjectile {
                     // CraftBukkit start - Fire PlayerTeleportEvent
                     org.bukkit.craftbukkit.entity.CraftPlayer player = entityplayer.getBukkitEntity();
                     org.bukkit.Location location = getBukkitEntity().getLocation();
+                    location.setX(location.getBlockX() + 0.5D);
+                    location.setY(location.getBlockY() + 0.5D);
+                    location.setZ(location.getBlockZ() + 0.5D);
                     location.setPitch(player.getLocation().getPitch());
                     location.setYaw(player.getLocation().getYaw());
 
diff --git a/src/main/java/net/minecraft/server/EntityFallingBlock.java b/src/main/java/net/minecraft/server/EntityFallingBlock.java
index 36c384eb..2860c199 100644
--- a/src/main/java/net/minecraft/server/EntityFallingBlock.java
+++ b/src/main/java/net/minecraft/server/EntityFallingBlock.java
@@ -4,6 +4,7 @@ import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.Iterator;
 
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class EntityFallingBlock extends Entity {
@@ -75,7 +76,6 @@ public class EntityFallingBlock extends Entity {
                 blockposition = new BlockPosition(this);
                 if (this.world.getType(blockposition).getBlock() == block && !CraftEventFactory.callEntityChangeBlockEvent(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), Blocks.AIR, 0).isCancelled()) {
                     this.world.setAir(blockposition);
-                    world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
                 } else if (!this.world.isClientSide) {
                     this.die();
                     return;
@@ -113,12 +113,11 @@ public class EntityFallingBlock extends Entity {
                     if (this.world.getType(blockposition).getBlock() != Blocks.PISTON_EXTENSION) {
                         this.die();
                         if (!this.e) {
-                            if (this.world.a(block, blockposition, true, EnumDirection.UP, (Entity) null, (ItemStack) null) && !BlockFalling.canFall(this.world, blockposition.down()) /* mimic the false conditions of setTypeIdAndData */ && blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256 && this.world.getType(blockposition) != this.block) {
+                            if (this.world.a(block, blockposition, true, EnumDirection.UP, null, null) && !BlockFalling.canFall(this.world, blockposition.down()) /* mimic the false conditions of setTypeIdAndData */ && blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000 && blockposition.getY() >= 0 && blockposition.getY() < 256 && this.world.getType(blockposition) != this.block) {
                                 if (CraftEventFactory.callEntityChangeBlockEvent(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), this.block.getBlock(), this.block.getBlock().toLegacyData(this.block)).isCancelled()) {
                                     return;
                                 }
                                 this.world.setTypeAndData(blockposition, this.block, 3);
-                                world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
                                 // CraftBukkit end
                                 if (block instanceof BlockFalling) {
                                     ((BlockFalling) block).a_(this.world, blockposition);
diff --git a/src/main/java/net/minecraft/server/EntityFireball.java b/src/main/java/net/minecraft/server/EntityFireball.java
index 125f74df..98c8d653 100644
--- a/src/main/java/net/minecraft/server/EntityFireball.java
+++ b/src/main/java/net/minecraft/server/EntityFireball.java
@@ -2,6 +2,7 @@ package net.minecraft.server;
 
 import java.util.List;
 
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public abstract class EntityFireball extends Entity {
@@ -56,7 +57,7 @@ public abstract class EntityFireball extends Entity {
         d0 += this.random.nextGaussian() * 0.4D;
         d1 += this.random.nextGaussian() * 0.4D;
         d2 += this.random.nextGaussian() * 0.4D;
-        double d3 = (double) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+        double d3 = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
 
         this.dirX = d0 / d3 * 0.1D;
         this.dirY = d1 / d3 * 0.1D;
@@ -139,7 +140,7 @@ public abstract class EntityFireball extends Entity {
             this.locX += this.motX;
             this.locY += this.motY;
             this.locZ += this.motZ;
-            float f1 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+            float f1 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
             this.yaw = (float) (MathHelper.b(this.motZ, this.motX) * 180.0D / 3.1415927410125732D) + 90.0F;
 
diff --git a/src/main/java/net/minecraft/server/EntityFireworks.java b/src/main/java/net/minecraft/server/EntityFireworks.java
index d7be6c26..c4246338 100644
--- a/src/main/java/net/minecraft/server/EntityFireworks.java
+++ b/src/main/java/net/minecraft/server/EntityFireworks.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 public class EntityFireworks extends Entity {
 
     private int ticksFlown;
@@ -55,7 +57,7 @@ public class EntityFireworks extends Entity {
         this.motZ *= 1.15D;
         this.motY += 0.04D;
         this.move(this.motX, this.motY, this.motZ);
-        float f = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+        float f = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
         this.yaw = (float) (MathHelper.b(this.motX, this.motZ) * 180.0D / 3.1415927410125732D);
 
diff --git a/src/main/java/net/minecraft/server/EntityFishingHook.java b/src/main/java/net/minecraft/server/EntityFishingHook.java
index df6ce0db..3683d99c 100644
--- a/src/main/java/net/minecraft/server/EntityFishingHook.java
+++ b/src/main/java/net/minecraft/server/EntityFishingHook.java
@@ -4,6 +4,7 @@ import java.util.Arrays;
 import java.util.List;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.entity.Player;
 import org.bukkit.entity.Fish;
 import org.bukkit.event.player.PlayerFishEvent;
@@ -67,7 +68,7 @@ public class EntityFishingHook extends Entity {
     protected void h() {}
 
     public void c(double d0, double d1, double d2, float f, float f1) {
-        float f2 = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+        float f2 = (float) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
 
         d0 /= (double) f2;
         d1 /= (double) f2;
@@ -81,7 +82,7 @@ public class EntityFishingHook extends Entity {
         this.motX = d0;
         this.motY = d1;
         this.motZ = d2;
-        float f3 = MathHelper.sqrt(d0 * d0 + d2 * d2);
+        float f3 = (float) MathHelper.sqrt(d0 * d0 + d2 * d2);
 
         this.lastYaw = this.yaw = (float) (MathHelper.b(d0, d2) * 180.0D / 3.1415927410125732D);
         this.lastPitch = this.pitch = (float) (MathHelper.b(d1, (double) f3) * 180.0D / 3.1415927410125732D);
@@ -208,7 +209,7 @@ public class EntityFishingHook extends Entity {
 
             if (!this.as) {
                 this.move(this.motX, this.motY, this.motZ);
-                float f1 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+                float f1 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
                 this.yaw = (float) (MathHelper.b(this.motX, this.motZ) * 180.0D / 3.1415927410125732D);
 
@@ -293,7 +294,7 @@ public class EntityFishingHook extends Entity {
                             } else {
                                 this.ay = (float) ((double) this.ay + this.random.nextGaussian() * 4.0D);
                                 f3 = this.ay * 0.017453292F;
-                                f5 = MathHelper.sin(f3);
+                                f5 = (float) MathHelper.sin(f3);
                                 f4 = MathHelper.cos(f3);
                                 d8 = this.locX + (double) (f5 * (float) this.ax * 0.1F);
                                 d12 = (double) ((float) MathHelper.floor(this.getBoundingBox().b) + 1.0F);
diff --git a/src/main/java/net/minecraft/server/EntityGhast.java b/src/main/java/net/minecraft/server/EntityGhast.java
index 51608e9d..72e72dae 100644
--- a/src/main/java/net/minecraft/server/EntityGhast.java
+++ b/src/main/java/net/minecraft/server/EntityGhast.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 import java.util.Random;
 
 public class EntityGhast extends EntityFlying implements IMonster {
diff --git a/src/main/java/net/minecraft/server/EntityHorse.java b/src/main/java/net/minecraft/server/EntityHorse.java
index 53aaa654..18abb8b9 100644
--- a/src/main/java/net/minecraft/server/EntityHorse.java
+++ b/src/main/java/net/minecraft/server/EntityHorse.java
@@ -4,6 +4,7 @@ import com.google.common.base.Predicate;
 import java.util.Iterator;
 import java.util.List;
 
+import net.jafama.FastMath;
 import org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason; // CraftBukkit
 
 public class EntityHorse extends EntityAnimal implements IInventoryListener {
@@ -924,7 +925,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
                 this.m(true);
                 this.ai = true;
                 if (f1 > 0.0F) {
-                    float f2 = MathHelper.sin(this.yaw * 3.1415927F / 180.0F);
+                    float f2 = (float) MathHelper.sin(this.yaw * 3.1415927F / 180.0F);
                     float f3 = MathHelper.cos(this.yaw * 3.1415927F / 180.0F);
 
                     this.motX += (double) (-0.4F * f2 * this.br);
@@ -950,7 +951,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
             this.aA = this.aB;
             double d0 = this.locX - this.lastX;
             double d1 = this.locZ - this.lastZ;
-            float f4 = MathHelper.sqrt(d0 * d0 + d1 * d1) * 4.0F;
+            float f4 = (float) MathHelper.sqrt(d0 * d0 + d1 * d1) * 4.0F;
 
             if (f4 > 1.0F) {
                 f4 = 1.0F;
@@ -1237,7 +1238,7 @@ public class EntityHorse extends EntityAnimal implements IInventoryListener {
     public void al() {
         super.al();
         if (this.bK > 0.0F) {
-            float f = MathHelper.sin(this.aI * 3.1415927F / 180.0F);
+            float f = (float) MathHelper.sin(this.aI * 3.1415927F / 180.0F);
             float f1 = MathHelper.cos(this.aI * 3.1415927F / 180.0F);
             float f2 = 0.7F * this.bK;
             float f3 = 0.15F * this.bK;
diff --git a/src/main/java/net/minecraft/server/EntityHuman.java b/src/main/java/net/minecraft/server/EntityHuman.java
index 0ad4edb8..6b55be7b 100644
--- a/src/main/java/net/minecraft/server/EntityHuman.java
+++ b/src/main/java/net/minecraft/server/EntityHuman.java
@@ -2,13 +2,17 @@ package net.minecraft.server;
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
+import org.potionspigot.PotionSpigot;
 import com.mojang.authlib.GameProfile;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.UUID;
 
 // CraftBukkit start
+import org.potionspigot.knockback.KnockbackProfile;
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.craftbukkit.entity.CraftItem;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -19,7 +23,6 @@ import org.bukkit.event.player.PlayerBedLeaveEvent;
 import org.bukkit.event.player.PlayerDropItemEvent;
 import org.bukkit.event.player.PlayerItemConsumeEvent;
 import org.bukkit.event.player.PlayerVelocityEvent;
-import org.bukkit.util.Vector;
 // CraftBukkit end
 
 public abstract class EntityHuman extends EntityLiving {
@@ -228,7 +231,6 @@ public abstract class EntityHuman extends EntityLiving {
             }
         }
 
-        int i = 29999999;
         double d4 = MathHelper.a(this.locX, -2.9999999E7D, 2.9999999E7D);
         double d5 = MathHelper.a(this.locZ, -2.9999999E7D, 2.9999999E7D);
 
@@ -276,9 +278,9 @@ public abstract class EntityHuman extends EntityLiving {
                 vec3d1 = vec3d1.b(-this.yaw * 3.1415927F / 180.0F);
                 vec3d1 = vec3d1.add(this.locX, this.locY + (double) this.getHeadHeight(), this.locZ);
                 if (itemstack.usesData()) {
-                    this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[] { Item.getId(itemstack.getItem()), itemstack.getData()});
+                    this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[]{Item.getId(itemstack.getItem()), itemstack.getData()});
                 } else {
-                    this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[] { Item.getId(itemstack.getItem())});
+                    this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[]{Item.getId(itemstack.getItem())});
                 }
             }
 
@@ -320,7 +322,7 @@ public abstract class EntityHuman extends EntityLiving {
                 return;
             }
             // CraftBukkit end
-            
+
             ItemStack itemstack = this.g.b(this.world, this);
 
             if (itemstack != this.g || itemstack != null && itemstack.count != i) {
@@ -345,7 +347,7 @@ public abstract class EntityHuman extends EntityLiving {
 
     public void ak() {
         if (!this.world.isClientSide && this.isSneaking()) {
-            this.mount((Entity) null);
+            this.mount(null);
             this.setSneaking(false);
         } else {
             double d0 = this.locX;
@@ -355,9 +357,11 @@ public abstract class EntityHuman extends EntityLiving {
             float f1 = this.pitch;
 
             super.ak();
+
             this.bn = this.bo;
             this.bo = 0.0F;
             this.l(this.locX - d0, this.locY - d1, this.locZ - d2);
+
             if (this.vehicle instanceof EntityPig) {
                 this.pitch = f1;
                 this.yaw = f;
@@ -404,8 +408,8 @@ public abstract class EntityHuman extends EntityLiving {
         }
 
         this.k((float) attributeinstance.getValue());
-        float f = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
-        float f1 = (float) ( org.bukkit.craftbukkit.TrigMath.atan(-this.motY * 0.20000000298023224D) * 15.0D); // CraftBukkit
+        float f = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+        float f1 = (float) (FastMath.atan(-this.motY * 0.20000000298023224D) * 15.0D); // CraftBukkit
 
         if (f > 0.1F) {
             f = 0.1F;
@@ -433,13 +437,13 @@ public abstract class EntityHuman extends EntityLiving {
             List list = this.world.getEntities(this, axisalignedbb);
 
             if (this.ae()) { // Spigot: Add this.ae() condition (second !this.isDead near bottom of EntityLiving)
-            for (int i = 0; i < list.size(); ++i) {
-                Entity entity = (Entity) list.get(i);
+                for (int i = 0; i < list.size(); ++i) {
+                    Entity entity = (Entity) list.get(i);
 
-                if (!entity.dead) {
-                    this.d(entity);
+                    if (!entity.dead) {
+                        this.d(entity);
+                    }
                 }
-            }
             } // Spigot 
         }
 
@@ -478,7 +482,7 @@ public abstract class EntityHuman extends EntityLiving {
 
         if (damagesource != null) {
             this.motX = (double) (-MathHelper.cos((this.aw + this.yaw) * 3.1415927F / 180.0F) * 0.1F);
-            this.motZ = (double) (-MathHelper.sin((this.aw + this.yaw) * 3.1415927F / 180.0F) * 0.1F);
+            this.motZ = (-MathHelper.sin((this.aw + this.yaw) * 3.1415927F / 180.0F) * 0.1F);
         } else {
             this.motX = this.motZ = 0.0D;
         }
@@ -567,6 +571,7 @@ public abstract class EntityHuman extends EntityLiving {
         } else {
             double d0 = this.locY - 0.30000001192092896D + (double) this.getHeadHeight();
             EntityItem entityitem = new EntityItem(this.world, this.locX, d0, this.locZ, itemstack);
+            entityitem.owner = this;
 
             entityitem.a(40);
             if (flag1) {
@@ -579,7 +584,7 @@ public abstract class EntityHuman extends EntityLiving {
             if (flag) {
                 f = this.random.nextFloat() * 0.5F;
                 f1 = this.random.nextFloat() * 3.1415927F * 2.0F;
-                entityitem.motX = (double) (-MathHelper.sin(f1) * f);
+                entityitem.motX = (-MathHelper.sin(f1) * f);
                 entityitem.motZ = (double) (MathHelper.cos(f1) * f);
                 entityitem.motY = 0.20000000298023224D;
             } else {
@@ -651,21 +656,21 @@ public abstract class EntityHuman extends EntityLiving {
             float f1 = 1.0F;
 
             switch (this.getEffect(MobEffectList.SLOWER_DIG).getAmplifier()) {
-            case 0:
-                f1 = 0.3F;
-                break;
+                case 0:
+                    f1 = 0.3F;
+                    break;
 
-            case 1:
-                f1 = 0.09F;
-                break;
+                case 1:
+                    f1 = 0.09F;
+                    break;
 
-            case 2:
-                f1 = 0.0027F;
-                break;
+                case 2:
+                    f1 = 0.0027F;
+                    break;
 
-            case 3:
-            default:
-                f1 = 8.1E-4F;
+                case 3:
+                default:
+                    f1 = 8.1E-4F;
             }
 
             f *= f1;
@@ -886,19 +891,26 @@ public abstract class EntityHuman extends EntityLiving {
         return false; // CraftBukkit
     }
 
-    public void openSign(TileEntitySign tileentitysign) {}
+    public void openSign(TileEntitySign tileentitysign) {
+    }
 
-    public void a(CommandBlockListenerAbstract commandblocklistenerabstract) {}
+    public void a(CommandBlockListenerAbstract commandblocklistenerabstract) {
+    }
 
-    public void openTrade(IMerchant imerchant) {}
+    public void openTrade(IMerchant imerchant) {
+    }
 
-    public void openContainer(IInventory iinventory) {}
+    public void openContainer(IInventory iinventory) {
+    }
 
-    public void openHorseInventory(EntityHorse entityhorse, IInventory iinventory) {}
+    public void openHorseInventory(EntityHorse entityhorse, IInventory iinventory) {
+    }
 
-    public void openTileEntity(ITileEntityContainer itileentitycontainer) {}
+    public void openTileEntity(ITileEntityContainer itileentitycontainer) {
+    }
 
-    public void openBook(ItemStack itemstack) {}
+    public void openBook(ItemStack itemstack) {
+    }
 
     public boolean u(Entity entity) {
         if (this.isSpectator()) {
@@ -955,149 +967,152 @@ public abstract class EntityHuman extends EntityLiving {
     }
 
     public void attack(Entity entity) {
-        if (entity.aD()) {
-            if (!entity.l(this)) {
-                float f = (float) this.getAttributeInstance(GenericAttributes.ATTACK_DAMAGE).getValue();
-                byte b0 = 0;
-                float f1 = 0.0F;
-
-                if (entity instanceof EntityLiving) {
-                    f1 = EnchantmentManager.a(this.bA(), ((EntityLiving) entity).getMonsterType());
-                } else {
-                    f1 = EnchantmentManager.a(this.bA(), EnumMonsterType.UNDEFINED);
-                }
+        if (entity.aD() && !entity.l(this)) {
+            float f = (float) this.getAttributeInstance(GenericAttributes.ATTACK_DAMAGE).getValue();
+            byte b0 = 0;
+            float f1;
+
+            if (entity instanceof EntityLiving) {
+                f1 = EnchantmentManager.a(this.bA(), ((EntityLiving) entity).getMonsterType());
+            } else {
+                f1 = EnchantmentManager.a(this.bA(), EnumMonsterType.UNDEFINED);
+            }
 
-                int i = b0 + EnchantmentManager.a((EntityLiving) this);
+            int i = b0 + EnchantmentManager.a(this);
 
-                if (this.isSprinting()) {
-                    ++i;
+            if (this.isSprinting()) {
+                ++i;
+            }
+
+            if (f > 0.0F || f1 > 0.0F) {
+                boolean flag = !world.paperSpigotConfig.disablePlayerCrits && this.fallDistance > 0.0F && !this.onGround && !this.k_() && !this.V() && !this.hasEffect(MobEffectList.BLINDNESS) && this.vehicle == null && entity instanceof EntityLiving; // PaperSpigot
+
+                if (flag && f > 0.0F) {
+                    f *= 1.5F;
                 }
 
-                if (f > 0.0F || f1 > 0.0F) {
-                    boolean flag = !world.paperSpigotConfig.disablePlayerCrits && this.fallDistance > 0.0F && !this.onGround && !this.k_() && !this.V() && !this.hasEffect(MobEffectList.BLINDNESS) && this.vehicle == null && entity instanceof EntityLiving; // PaperSpigot
+                f += f1;
+                boolean flag1 = false;
+                int j = EnchantmentManager.getFireAspectEnchantmentLevel(this);
 
-                    if (flag && f > 0.0F) {
-                        f *= 1.5F;
+                if (entity instanceof EntityLiving && j > 0 && !entity.isBurning()) {
+                    // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                    EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), 1);
+                    org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+
+                    if (!combustEvent.isCancelled()) {
+                        flag1 = true;
+                        entity.setOnFire(combustEvent.getDuration());
                     }
+                    // CraftBukkit end
+                }
 
-                    f += f1;
-                    boolean flag1 = false;
-                    int j = EnchantmentManager.getFireAspectEnchantmentLevel(this);
+                // Kohi start
+                // Save the victim's velocity before they are potentially knocked back
+                double victimMotX = entity.motX;
+                double victimMotY = entity.motY;
+                double victimMotZ = entity.motZ;
+                // Kohi end
 
-                    if (entity instanceof EntityLiving && j > 0 && !entity.isBurning()) {
-                        // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
-                        EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), 1);
-                        org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
+                boolean damaged = entity.damageEntity(DamageSource.playerAttack(this), f);
 
-                        if (!combustEvent.isCancelled()) {
-                            flag1 = true;
-                            entity.setOnFire(combustEvent.getDuration());
-                        }
-                        // CraftBukkit end
-                    }
+                if (damaged) {
+                    if (i > 0) {
+                        KnockbackProfile profile = this.getKnockbackProfile() == null ? PotionSpigot.INSTANCE.getConfig().getCurrentKb() : this.getKnockbackProfile();
 
-                    double d0 = entity.motX;
-                    double d1 = entity.motY;
-                    double d2 = entity.motZ;
-                    boolean flag2 = entity.damageEntity(DamageSource.playerAttack(this), f);
-
-                    if (flag2) {
-                        if (i > 0) {
-                            entity.g((double) (-MathHelper.sin(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F), 0.1D, (double) (MathHelper.cos(this.yaw * 3.1415927F / 180.0F) * (float) i * 0.5F));
-                            this.motX *= 0.6D;
-                            this.motZ *= 0.6D;
-                            this.setSprinting(false);
-                        }
+                        entity.g(
+                                (-MathHelper.sin(this.yaw * 3.1415927F / 180.0F) * (float) i * profile.getExtraHorizontal()), profile.getExtraVertical(),
+                                (MathHelper.cos(this.yaw * 3.1415927F / 180.0F) * (float) i * profile.getExtraHorizontal())
+                        );
 
-                        if (entity instanceof EntityPlayer && entity.velocityChanged) {
-                            // CraftBukkit start - Add Velocity Event
-                            boolean cancelled = false;
-                            Player player = (Player) entity.getBukkitEntity();
-                            org.bukkit.util.Vector velocity = new Vector( d0, d1, d2 );
+                        this.motX *= 0.6D;
+                        this.motZ *= 0.6D;
+                        this.setSprinting(false);
+                    }
 
-                            PlayerVelocityEvent event = new PlayerVelocityEvent(player, velocity.clone());
-                            world.getServer().getPluginManager().callEvent(event);
+                    // Kohi start
+                    if (entity instanceof EntityPlayer && entity.velocityChanged) {
+                        EntityPlayer attackedPlayer = (EntityPlayer) entity;
+                        PlayerVelocityEvent event = new PlayerVelocityEvent(attackedPlayer.getBukkitEntity(), attackedPlayer.getBukkitEntity().getVelocity());
 
-                            if (event.isCancelled()) {
-                                cancelled = true;
-                            } else if (!velocity.equals(event.getVelocity())) {
-                                player.setVelocity(event.getVelocity());
-                            }
+                        this.world.getServer().getPluginManager().callEvent(event);
 
-                            if (!cancelled) {
-                                ( (EntityPlayer) entity ).playerConnection.sendPacket( new PacketPlayOutEntityVelocity( entity ) );
-                                entity.velocityChanged = false;
-                                entity.motX = d0;
-                                entity.motY = d1;
-                                entity.motZ = d2;
-                            }
-                            // CraftBukkit end
+                        if (!event.isCancelled()) {
+                            attackedPlayer.getBukkitEntity().setVelocityDirect(event.getVelocity());
+                            attackedPlayer.playerConnection.sendPacket(new PacketPlayOutEntityVelocity(attackedPlayer));
                         }
 
-                        if (flag) {
-                            this.b(entity);
-                        }
+                        attackedPlayer.velocityChanged = false;
+                        attackedPlayer.motX = victimMotX;
+                        attackedPlayer.motY = victimMotY;
+                        attackedPlayer.motZ = victimMotZ;
+                    }
+                    // Kohi end
 
-                        if (f1 > 0.0F) {
-                            this.c(entity);
-                        }
+                    if (flag) {
+                        this.b(entity);
+                    }
 
-                        if (f >= 18.0F) {
-                            this.b((Statistic) AchievementList.F);
-                        }
+                    if (f1 > 0.0F) {
+                        this.c(entity);
+                    }
 
-                        this.p(entity);
-                        if (entity instanceof EntityLiving) {
-                            EnchantmentManager.a((EntityLiving) entity, (Entity) this);
-                        }
+                    if (f >= 18.0F) {
+                        this.b(AchievementList.F);
+                    }
 
-                        EnchantmentManager.b(this, entity);
-                        ItemStack itemstack = this.bZ();
-                        Object object = entity;
+                    this.p(entity);
+                    if (entity instanceof EntityLiving) {
+                        EnchantmentManager.a((EntityLiving) entity, this);
+                    }
 
-                        if (entity instanceof EntityComplexPart) {
-                            IComplex icomplex = ((EntityComplexPart) entity).owner;
+                    EnchantmentManager.b(this, entity);
+                    ItemStack itemstack = this.bZ();
+                    Object object = entity;
 
-                            if (icomplex instanceof EntityLiving) {
-                                object = (EntityLiving) icomplex;
-                            }
+                    if (entity instanceof EntityComplexPart) {
+                        IComplex icomplex = ((EntityComplexPart) entity).owner;
+
+                        if (icomplex instanceof EntityLiving) {
+                            object = icomplex;
                         }
+                    }
 
-                        if (itemstack != null && object instanceof EntityLiving) {
-                            itemstack.a((EntityLiving) object, this);
-                            // CraftBukkit - bypass infinite items; <= 0 -> == 0
-                            if (itemstack.count == 0) {
-                                this.ca();
-                            }
+                    if (itemstack != null && object instanceof EntityLiving) {
+                        itemstack.a((EntityLiving) object, this);
+                        // CraftBukkit - bypass infinite items; <= 0 -> == 0
+                        if (itemstack.count == 0) {
+                            this.ca();
                         }
+                    }
+
+                    if (entity instanceof EntityLiving) {
+                        this.a(StatisticList.w, Math.round(f * 10.0F));
+                        if (j > 0) {
+                            // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
+                            EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), j * 4);
+                            org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
 
-                        if (entity instanceof EntityLiving) {
-                            this.a(StatisticList.w, Math.round(f * 10.0F));
-                            if (j > 0) {
-                                // CraftBukkit start - Call a combust event when somebody hits with a fire enchanted item
-                                EntityCombustByEntityEvent combustEvent = new EntityCombustByEntityEvent(this.getBukkitEntity(), entity.getBukkitEntity(), j * 4);
-                                org.bukkit.Bukkit.getPluginManager().callEvent(combustEvent);
-
-                                if (!combustEvent.isCancelled()) {
-                                    entity.setOnFire(combustEvent.getDuration());
-                                }
-                                // CraftBukkit end
+                            if (!combustEvent.isCancelled()) {
+                                entity.setOnFire(combustEvent.getDuration());
                             }
+                            // CraftBukkit end
                         }
-
-                        this.applyExhaustion(world.spigotConfig.combatExhaustion); // Spigot - Change to use configurable value
-                    } else if (flag1) {
-                        entity.extinguish();
                     }
-                }
 
+                    this.applyExhaustion(world.spigotConfig.combatExhaustion); // Spigot - Change to use configurable value
+                } else if (flag1) {
+                    entity.extinguish();
+                }
             }
         }
     }
 
-    public void b(Entity entity) {}
+    public void b(Entity entity) {
+    }
 
-    public void c(Entity entity) {}
+    public void c(Entity entity) {
+    }
 
     public void die() {
         super.die();
@@ -1162,26 +1177,27 @@ public abstract class EntityHuman extends EntityLiving {
         // CraftBukkit end
 
         this.setSize(0.2F, 0.2F);
+
         if (this.world.isLoaded(blockposition)) {
-            EnumDirection enumdirection = (EnumDirection) this.world.getType(blockposition).get(BlockDirectional.FACING);
+            EnumDirection enumdirection = this.world.getType(blockposition).get(BlockDirectional.FACING);
             float f = 0.5F;
             float f1 = 0.5F;
 
             switch (EntityHuman.SyntheticClass_1.a[enumdirection.ordinal()]) {
-            case 1:
-                f1 = 0.9F;
-                break;
+                case 1:
+                    f1 = 0.9F;
+                    break;
 
-            case 2:
-                f1 = 0.1F;
-                break;
+                case 2:
+                    f1 = 0.1F;
+                    break;
 
-            case 3:
-                f = 0.1F;
-                break;
+                case 3:
+                    f = 0.1F;
+                    break;
 
-            case 4:
-                f = 0.9F;
+                case 4:
+                    f = 0.9F;
             }
 
             this.a(enumdirection);
@@ -1194,6 +1210,7 @@ public abstract class EntityHuman extends EntityLiving {
         this.sleepTicks = 0;
         this.bx = blockposition;
         this.motX = this.motZ = this.motY = 0.0D;
+
         if (!this.world.isClientSide) {
             this.world.everyoneSleeping();
         }
@@ -1205,20 +1222,20 @@ public abstract class EntityHuman extends EntityLiving {
         this.by = 0.0F;
         this.bz = 0.0F;
         switch (EntityHuman.SyntheticClass_1.a[enumdirection.ordinal()]) {
-        case 1:
-            this.bz = -1.8F;
-            break;
+            case 1:
+                this.bz = -1.8F;
+                break;
 
-        case 2:
-            this.bz = 1.8F;
-            break;
+            case 2:
+                this.bz = 1.8F;
+                break;
 
-        case 3:
-            this.by = 1.8F;
-            break;
+            case 3:
+                this.by = 1.8F;
+                break;
 
-        case 4:
-            this.by = -1.8F;
+            case 4:
+                this.by = -1.8F;
         }
 
     }
@@ -1307,7 +1324,8 @@ public abstract class EntityHuman extends EntityLiving {
         return this.sleeping && this.sleepTicks >= 100;
     }
 
-    public void b(IChatBaseComponent ichatbasecomponent) {}
+    public void b(IChatBaseComponent ichatbasecomponent) {
+    }
 
     public BlockPosition getBed() {
         return this.c;
@@ -1334,9 +1352,11 @@ public abstract class EntityHuman extends EntityLiving {
         this.a(statistic, 1);
     }
 
-    public void a(Statistic statistic, int i) {}
+    public void a(Statistic statistic, int i) {
+    }
 
-    public void a(Statistic statistic) {}
+    public void a(Statistic statistic) {
+    }
 
     public void bF() {
         super.bF();
@@ -1378,13 +1398,13 @@ public abstract class EntityHuman extends EntityLiving {
             int i;
 
             if (this.a(Material.WATER)) {
-                i = Math.round(MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 100.0F);
+                i = (int) Math.round(MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 100.0F);
                 if (i > 0) {
                     this.a(StatisticList.p, i);
                     this.applyExhaustion(world.paperSpigotConfig.playerSwimmingExhaustion * (float) i * 0.01F); // PaperSpigot - Configurable swimming exhaustion
                 }
             } else if (this.V()) {
-                i = Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
+                i = (int) Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
                 if (i > 0) {
                     this.a(StatisticList.l, i);
                     this.applyExhaustion(world.paperSpigotConfig.playerSwimmingExhaustion * (float) i * 0.01F); // PaperSpigot - Configurable swimming (diving) exhaustion
@@ -1394,7 +1414,7 @@ public abstract class EntityHuman extends EntityLiving {
                     this.a(StatisticList.n, (int) Math.round(d1 * 100.0D));
                 }
             } else if (this.onGround) {
-                i = Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
+                i = (int) Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
                 if (i > 0) {
                     this.a(StatisticList.i, i);
                     if (this.isSprinting()) {
@@ -1409,7 +1429,7 @@ public abstract class EntityHuman extends EntityLiving {
                     }
                 }
             } else {
-                i = Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
+                i = (int) Math.round(MathHelper.sqrt(d0 * d0 + d2 * d2) * 100.0F);
                 if (i > 25) {
                     this.a(StatisticList.o, i);
                 }
@@ -1420,7 +1440,7 @@ public abstract class EntityHuman extends EntityLiving {
 
     private void l(double d0, double d1, double d2) {
         if (this.vehicle != null) {
-            int i = Math.round(MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 100.0F);
+            int i = (int) Math.round(MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2) * 100.0F);
 
             if (i > 0) {
                 if (this.vehicle instanceof EntityMinecartAbstract) {
@@ -1632,9 +1652,11 @@ public abstract class EntityHuman extends EntityLiving {
         return !this.abilities.isFlying;
     }
 
-    public void updateAbilities() {}
+    public void updateAbilities() {
+    }
 
-    public void a(WorldSettings.EnumGamemode worldsettings_enumgamemode) {}
+    public void a(WorldSettings.EnumGamemode worldsettings_enumgamemode) {
+    }
 
     public String getName() {
         return this.bH.getName();
@@ -1808,7 +1830,8 @@ public abstract class EntityHuman extends EntityLiving {
 
         OK, NOT_POSSIBLE_HERE, NOT_POSSIBLE_NOW, TOO_FAR_AWAY, OTHER_PROBLEM, NOT_SAFE;
 
-        private EnumBedResult() {}
+        private EnumBedResult() {
+        }
     }
 
     public static enum EnumChatVisibility {
diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index b82b9847..9dad33a8 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
 import java.util.Iterator;
 import java.util.List;
 import java.util.UUID;
@@ -285,7 +286,7 @@ public abstract class EntityInsentient extends EntityLiving {
 
     public void a(NBTTagCompound nbttagcompound) {
         super.a(nbttagcompound);
-        
+
         // CraftBukkit start - If looting or persistence is false only use it if it was set after we started using it
         if (nbttagcompound.hasKeyOfType("CanPickUpLoot", 1)) {
             boolean data = nbttagcompound.getBoolean("CanPickUpLoot");
@@ -470,30 +471,34 @@ public abstract class EntityInsentient extends EntityLiving {
             return;
         }
         // Spigot End
-        this.world.methodProfiler.a("sensing");
-        this.bk.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("targetSelector");
-        this.targetSelector.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("goalSelector");
-        this.goalSelector.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("navigation");
-        this.navigation.k();
-        this.world.methodProfiler.b();
+        if(PotionSpigot.INSTANCE.getConfig().isMobAIEnabled()) {
+            this.world.methodProfiler.a("sensing");
+            this.bk.a();
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("targetSelector");
+            this.targetSelector.a();
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("goalSelector");
+            this.goalSelector.a();
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("navigation");
+            this.navigation.k();
+            this.world.methodProfiler.b();
+        }
         this.world.methodProfiler.a("mob tick");
         this.E();
         this.world.methodProfiler.b();
-        this.world.methodProfiler.a("controls");
-        this.world.methodProfiler.a("move");
-        this.moveController.c();
-        this.world.methodProfiler.c("look");
-        this.lookController.a();
-        this.world.methodProfiler.c("jump");
-        this.g.b();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.b();
+        if(PotionSpigot.INSTANCE.getConfig().isMobAIEnabled()) {
+            this.world.methodProfiler.a("controls");
+            this.world.methodProfiler.a("move");
+            this.moveController.c();
+            this.world.methodProfiler.c("look");
+            this.lookController.a();
+            this.world.methodProfiler.c("jump");
+            this.g.b();
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.b();
+        }
     }
 
     protected void E() {}
diff --git a/src/main/java/net/minecraft/server/EntityItem.java b/src/main/java/net/minecraft/server/EntityItem.java
index 1f8b1c72..9f79dc6a 100644
--- a/src/main/java/net/minecraft/server/EntityItem.java
+++ b/src/main/java/net/minecraft/server/EntityItem.java
@@ -8,13 +8,14 @@ import org.bukkit.event.player.PlayerPickupItemEvent; // CraftBukkit
 public class EntityItem extends Entity {
 
     private static final Logger b = LogManager.getLogger();
-    private int age;
+    public int age;
     public int pickupDelay;
     private int e;
     private String f;
     private String g;
     public float a;
     private int lastTick = MinecraftServer.currentTick; // CraftBukkit
+    public Entity owner; // Paper
 
     public EntityItem(World world, double d0, double d1, double d2) {
         super(world);
@@ -300,6 +301,11 @@ public class EntityItem extends Entity {
 
     public void d(EntityHuman entityhuman) {
         if (!this.world.isClientSide) {
+            /*
+            if (!((EntityPlayer) entityhuman).getBukkitEntity().canSeeEntity(this.getBukkitEntity())){
+                return;
+            }
+            */
             ItemStack itemstack = this.getItemStack();
             int i = itemstack.count;
 
diff --git a/src/main/java/net/minecraft/server/EntityLiving.java b/src/main/java/net/minecraft/server/EntityLiving.java
index c8b4e292..2f8d8244 100644
--- a/src/main/java/net/minecraft/server/EntityLiving.java
+++ b/src/main/java/net/minecraft/server/EntityLiving.java
@@ -1,8 +1,16 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.event.potion.PotionEffectAddEvent;
+import org.potionspigot.event.potion.PotionEffectExpireEvent;
+import org.potionspigot.event.potion.PotionEffectExtendEvent;
+import org.potionspigot.event.potion.PotionEffectRemoveEvent;
+import org.potionspigot.knockback.KnockbackProfile;
+import org.potionspigot.util.CraftPotionUtil;
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
 import com.google.common.collect.Maps;
+
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -12,8 +20,10 @@ import java.util.UUID;
 
 // CraftBukkit start
 import java.util.ArrayList;
+
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
@@ -23,8 +33,6 @@ import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.vehicle.VehicleExitEvent;
 // CraftBukkit end
 
-import co.aikar.timings.SpigotTimings; // Spigot
-
 // PaperSpigot start
 import org.bukkit.Bukkit;
 import org.spigotmc.event.entity.EntityDismountEvent;
@@ -34,6 +42,19 @@ public abstract class EntityLiving extends Entity {
 
     private static final UUID a = UUID.fromString("662A6B8D-DA3E-4C1C-8813-96EA6097278D");
     private static final AttributeModifier b = (new AttributeModifier(EntityLiving.a, "Sprinting speed boost", 0.30000001192092896D, 2)).a(false);
+
+    // SpigotX start
+    private KnockbackProfile knockbackProfile;
+
+    public KnockbackProfile getKnockbackProfile() {
+        return knockbackProfile;
+    }
+
+    public void setKnockbackProfile(KnockbackProfile profile) {
+        this.knockbackProfile = profile;
+    }
+    // SpigotX end
+
     private AttributeMapBase c;
     public CombatTracker combatTracker = new CombatTracker(this);
     public final Map<Integer, MobEffect> effects = Maps.newHashMap();
@@ -89,18 +110,16 @@ public abstract class EntityLiving extends Entity {
     private float bm;
     private int bn;
     private float bo;
-    // CraftBukkit start
     public int expToDrop;
     public int maxAirTicks = 300;
     ArrayList<org.bukkit.inventory.ItemStack> drops = null;
-    // CraftBukkit end
-    // Spigot start
-    public void inactiveTick()
-    {
+    private boolean isTickingEffects = false;
+    private List<Object> effectsToProcess = Lists.newArrayList();
+
+    public void inactiveTick() {
         super.inactiveTick();
-        ++this.ticksFarFromPlayer; // Above all the floats
+        ++this.ticksFarFromPlayer;
     }
-    // Spigot end
 
     public void G() {
         this.damageEntity(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
@@ -109,11 +128,13 @@ public abstract class EntityLiving extends Entity {
     public EntityLiving(World world) {
         super(world);
         this.initAttributes();
-        // CraftBukkit - setHealth(getMaxHealth()) inlined and simplified to skip the instanceof check for EntityPlayer, as getBukkitEntity() is not initialized in constructor
         this.datawatcher.watch(6, (float) this.getAttributeInstance(GenericAttributes.maxHealth).getValue());
+
         this.k = true;
         this.aH = (float) ((Math.random() + 1.0D) * 0.009999999776482582D);
+
         this.setPosition(this.locX, this.locY, this.locZ);
+
         this.aG = (float) Math.random() * 12398.0F;
         this.yaw = (float) (Math.random() * 3.1415927410125732D * 2.0D);
         this.aK = this.yaw;
@@ -121,10 +142,10 @@ public abstract class EntityLiving extends Entity {
     }
 
     protected void h() {
-        this.datawatcher.a(7, Integer.valueOf(0));
-        this.datawatcher.a(8, Byte.valueOf((byte) 0));
-        this.datawatcher.a(9, Byte.valueOf((byte) 0));
-        this.datawatcher.a(6, Float.valueOf(1.0F));
+        this.datawatcher.a(7, 0);
+        this.datawatcher.a(8, (byte) 0);
+        this.datawatcher.a(9, (byte) 0);
+        this.datawatcher.a(6, 1.0F);
     }
 
     protected void initAttributes() {
@@ -152,13 +173,11 @@ public abstract class EntityLiving extends Entity {
 
                 int i = (int) (150.0D * d1);
 
-                // CraftBukkit start - visiblity api
                 if (this instanceof EntityPlayer) {
-                    ((WorldServer) this.world).sendParticles((EntityPlayer) this, EnumParticle.BLOCK_DUST, false, this.locX, this.locY, this.locZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[] { Block.getCombinedId(iblockdata)});
+                    ((WorldServer) this.world).sendParticles((EntityPlayer) this, EnumParticle.BLOCK_DUST, false, this.locX, this.locY, this.locZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[]{Block.getCombinedId(iblockdata)});
                 } else {
-                    ((WorldServer) this.world).a(EnumParticle.BLOCK_DUST, this.locX, this.locY, this.locZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[] { Block.getCombinedId(iblockdata)});
+                    ((WorldServer) this.world).a(EnumParticle.BLOCK_DUST, this.locX, this.locY, this.locZ, i, 0.0D, 0.0D, 0.0D, 0.15000000596046448D, new int[]{Block.getCombinedId(iblockdata)});
                 }
-                // CraftBukkit end
             }
         }
 
@@ -179,7 +198,7 @@ public abstract class EntityLiving extends Entity {
             if (this.inBlock()) {
                 this.damageEntity(DamageSource.STUCK, 1.0F);
             } else if (flag && !this.world.getWorldBorder().a(this.getBoundingBox())) {
-                double d0 = this.world.getWorldBorder().a((Entity) this) + this.world.getWorldBorder().getDamageBuffer();
+                double d0 = this.world.getWorldBorder().a(this) + this.world.getWorldBorder().getDamageBuffer();
 
                 if (d0 < 0.0D) {
                     this.damageEntity(DamageSource.STUCK, (float) Math.max(1, MathHelper.floor(-d0 * this.world.getWorldBorder().getDamageAmount())));
@@ -213,14 +232,12 @@ public abstract class EntityLiving extends Entity {
                 }
 
                 if (!this.world.isClientSide && this.au() && this.vehicle instanceof EntityLiving) {
-                    this.mount((Entity) null);
+                    this.mount(null);
                 }
             } else {
-                // CraftBukkit start - Only set if needed to work around a DataWatcher inefficiency
                 if (this.getAirTicks() != 300) {
                     this.setAirTicks(maxAirTicks);
                 }
-                // CraftBukkit end
             }
         }
 
@@ -229,6 +246,7 @@ public abstract class EntityLiving extends Entity {
         }
 
         this.aE = this.aF;
+
         if (this.hurtTicks > 0) {
             --this.hurtTicks;
         }
@@ -260,15 +278,16 @@ public abstract class EntityLiving extends Entity {
         }
 
         this.bi();
+
         this.aU = this.aT;
         this.aJ = this.aI;
         this.aL = this.aK;
         this.lastYaw = this.yaw;
         this.lastPitch = this.pitch;
+
         this.world.methodProfiler.b();
     }
 
-    // CraftBukkit start
     public int getExpReward() {
         int exp = this.getExpValue(this.killer);
 
@@ -278,7 +297,6 @@ public abstract class EntityLiving extends Entity {
             return 0;
         }
     }
-    // CraftBukkit end
 
     public boolean isBaby() {
         return false;
@@ -286,18 +304,20 @@ public abstract class EntityLiving extends Entity {
 
     protected void aZ() {
         ++this.deathTicks;
-        if (this.deathTicks >= 20 && !this.dead) { // CraftBukkit - (this.deathTicks == 20) -> (this.deathTicks >= 20 && !this.dead)
+        if (this.deathTicks >= 20 && !this.dead) {
             int i;
 
-            // CraftBukkit start - Update getExpReward() above if the removed if() changes!
             i = this.expToDrop;
+
             while (i > 0) {
                 int j = EntityExperienceOrb.getOrbValue(i);
+
                 i -= j;
+
                 this.world.addEntity(new EntityExperienceOrb(this.world, this.locX, this.locY, this.locZ, j));
             }
+
             this.expToDrop = 0;
-            // CraftBukkit end
 
             this.die();
 
@@ -464,21 +484,25 @@ public abstract class EntityLiving extends Entity {
         this.hurtTimestamp = nbttagcompound.getInt("HurtByTimestamp");
     }
 
-    // CraftBukkit start
-    private boolean isTickingEffects = false;
-    private List<Object> effectsToProcess = Lists.newArrayList();
-    // CraftBukkit end
-
     protected void bi() {
         Iterator iterator = this.effects.keySet().iterator();
+        isTickingEffects = true;
 
-        isTickingEffects = true; // CraftBukkit
         while (iterator.hasNext()) {
             Integer integer = (Integer) iterator.next();
-            MobEffect mobeffect = (MobEffect) this.effects.get(integer);
+            MobEffect mobeffect = this.effects.get(integer);
 
             if (!mobeffect.tick(this)) {
                 if (!this.world.isClientSide) {
+
+                    PotionEffectExpireEvent event = new PotionEffectExpireEvent((LivingEntity) this.getBukkitEntity(), CraftPotionUtil.toBukkit(mobeffect));
+                    this.world.getServer().getPluginManager().callEvent(event);
+                    if (event.isCancelled()) {
+                        // Duration must be extended if event is cancelled
+                        CraftPotionUtil.extendDuration(mobeffect, event.getDuration());
+                        continue;
+                    }
+
                     iterator.remove();
                     this.b(mobeffect);
                 }
@@ -584,7 +608,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public void addEffect(MobEffect mobeffect) {
-        org.spigotmc.AsyncCatcher.catchOp( "effect add"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("effect add"); // Spigot
         // CraftBukkit start
         if (isTickingEffects) {
             effectsToProcess.add(mobeffect);
@@ -592,6 +616,31 @@ public abstract class EntityLiving extends Entity {
         }
         // CraftBukkit end
         if (this.d(mobeffect)) {
+            MobEffect currentEffect = this.effects.get(mobeffect.getEffectId());
+
+            if (currentEffect == null) {
+                // Add Effect
+                PotionEffectAddEvent event = new PotionEffectAddEvent((LivingEntity) this.getBukkitEntity(), CraftPotionUtil.toBukkit(mobeffect));
+                this.world.getServer().getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
+                }
+
+                this.effects.put(mobeffect.getEffectId(), mobeffect);
+                this.a(mobeffect);
+            } else {
+                // Extend Effect
+                PotionEffectExtendEvent event = new PotionEffectExtendEvent((LivingEntity) this.getBukkitEntity(),
+                        CraftPotionUtil.toBukkit(mobeffect),
+                        CraftPotionUtil.toBukkit(mobeffect));
+                this.world.getServer().getPluginManager().callEvent(event);
+                if (event.isCancelled()) {
+                    return;
+                }
+                currentEffect.a(mobeffect);
+                this.a(currentEffect, true);
+            }
+
             if (this.effects.containsKey(Integer.valueOf(mobeffect.getEffectId()))) {
                 ((MobEffect) this.effects.get(Integer.valueOf(mobeffect.getEffectId()))).a(mobeffect);
                 this.a((MobEffect) this.effects.get(Integer.valueOf(mobeffect.getEffectId())), true);
@@ -629,6 +678,12 @@ public abstract class EntityLiving extends Entity {
         MobEffect mobeffect = (MobEffect) this.effects.remove(Integer.valueOf(i));
 
         if (mobeffect != null) {
+            PotionEffectRemoveEvent event = new PotionEffectRemoveEvent((LivingEntity) this.getBukkitEntity(), CraftPotionUtil.toBukkit(mobeffect));
+            this.world.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+
             this.b(mobeffect);
         }
 
@@ -701,7 +756,9 @@ public abstract class EntityLiving extends Entity {
                 player.setRealHealth(f);
             }
 
-            this.datawatcher.watch(6, Float.valueOf(player.getScaledHealth()));
+            float health = player.getScaledHealth() == 0.0F ? 0.0F : 1.0F;
+
+            this.datawatcher.watch(6, health);
             return;
         }
         // CraftBukkit end
@@ -730,18 +787,7 @@ public abstract class EntityLiving extends Entity {
                 boolean flag = true;
 
                 if ((float) this.noDamageTicks > (float) this.maxNoDamageTicks / 2.0F) {
-                    if (f <= this.lastDamage) {
-                        this.forceExplosionKnockback = true; // CraftBukkit - SPIGOT-949 - for vanilla consistency, cooldown does not prevent explosion knockback
-                        return false;
-                    }
-
-                    // CraftBukkit start
-                    if (!this.d(damagesource, f - this.lastDamage)) {
-                        return false;
-                    }
-                    // CraftBukkit end
-                    this.lastDamage = f;
-                    flag = false;
+                    return false;
                 } else {
                     // CraftBukkit start
                     float previousHealth = this.getHealth();
@@ -755,10 +801,10 @@ public abstract class EntityLiving extends Entity {
                 }
 
                 // CraftBukkit start
-                if(this instanceof EntityAnimal){
-                    ((EntityAnimal)this).cq();
-                    if(this instanceof EntityTameableAnimal){
-                        ((EntityTameableAnimal)this).getGoalSit().setSitting(false);
+                if (this instanceof EntityAnimal) {
+                    ((EntityAnimal) this).cq();
+                    if (this instanceof EntityTameableAnimal) {
+                        ((EntityTameableAnimal) this).getGoalSit().setSitting(false);
                     }
                 }
                 // CraftBukkit end
@@ -787,7 +833,7 @@ public abstract class EntityLiving extends Entity {
                 // PaperSpigot start - Disable explosion knockback
                 boolean knockbackCancelled = false;
                 if (flag && !(knockbackCancelled = world.paperSpigotConfig.disableExplosionKnockback && damagesource.isExplosion() && this instanceof EntityHuman)) {
-                // PaperSpigot end
+                    // PaperSpigot end
                     this.world.broadcastEntityEffect(this, (byte) 2);
                     if (damagesource != DamageSource.DROWN) {
                         this.ac();
@@ -846,7 +892,7 @@ public abstract class EntityLiving extends Entity {
             vec3d1 = vec3d1.a(-this.pitch * 3.1415927F / 180.0F);
             vec3d1 = vec3d1.b(-this.yaw * 3.1415927F / 180.0F);
             vec3d1 = vec3d1.add(this.locX, this.locY + (double) this.getHeadHeight(), this.locZ);
-            this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[] { Item.getId(itemstack.getItem())});
+            this.world.addParticle(EnumParticle.ITEM_CRACK, vec3d1.a, vec3d1.b, vec3d1.c, vec3d.a, vec3d.b + 0.05D, vec3d.c, new int[]{Item.getId(itemstack.getItem())});
         }
 
     }
@@ -874,7 +920,7 @@ public abstract class EntityLiving extends Entity {
 
             if (this.ba() && this.world.getGameRules().getBoolean("doMobLoot")) {
                 this.drops = new ArrayList<org.bukkit.inventory.ItemStack>(); // CraftBukkit - Setup drop capture
-                
+
                 this.dropDeathLoot(this.lastDamageByPlayerTime > 0, i);
                 this.dropEquipment(this.lastDamageByPlayerTime > 0, i);
                 if (this.lastDamageByPlayerTime > 0 && this.random.nextFloat() < 0.025F + (float) i * 0.01F) {
@@ -892,24 +938,30 @@ public abstract class EntityLiving extends Entity {
         this.world.broadcastEntityEffect(this, (byte) 3);
     }
 
-    protected void dropEquipment(boolean flag, int i) {}
+    protected void dropEquipment(boolean flag, int i) {
+    }
 
     public void a(Entity entity, float f, double d0, double d1) {
         if (this.random.nextDouble() >= this.getAttributeInstance(GenericAttributes.c).getValue()) {
             this.ai = true;
-            float f1 = MathHelper.sqrt(d0 * d0 + d1 * d1);
-            float f2 = 0.4F;
-
-            this.motX /= 2.0D;
-            this.motY /= 2.0D;
-            this.motZ /= 2.0D;
-            this.motX -= d0 / (double) f1 * (double) f2;
-            this.motY += (double) f2;
-            this.motZ -= d1 / (double) f1 * (double) f2;
-            if (this.motY > 0.4000000059604645D) {
-                this.motY = 0.4000000059604645D;
-            }
 
+            KnockbackProfile profile = this.getKnockbackProfile() == null ? PotionSpigot.INSTANCE.getConfig().getCurrentKb() : this.getKnockbackProfile();
+
+            // Kohi start - configurable knockback
+            double magnitude = MathHelper.sqrt(d0 * d0 + d1 * d1);
+
+            this.motX /= profile.getFriction();
+            this.motY /= profile.getFriction();
+            this.motZ /= profile.getFriction();
+
+            this.motX -= d0 / magnitude * profile.getHorizontal();
+            this.motY += profile.getVertical();
+            this.motZ -= d1 / magnitude * profile.getHorizontal();
+
+            if (this.motY > profile.getVerticalLimit()) {
+                this.motY = profile.getVerticalLimit();
+            }
+            // Kohi end
         }
     }
 
@@ -1009,7 +1061,7 @@ public abstract class EntityLiving extends Entity {
             int i;
             int j;
             float f1;
-            
+
             // CraftBukkit - Moved to d(DamageSource, float)
             if (false && this.hasEffect(MobEffectList.RESISTANCE) && damagesource != DamageSource.OUT_OF_WORLD) {
                 i = (this.getEffect(MobEffectList.RESISTANCE).getAmplifier() + 1) * 5;
@@ -1039,7 +1091,7 @@ public abstract class EntityLiving extends Entity {
 
     // CraftBukkit start
     protected boolean d(final DamageSource damagesource, float f) { // void -> boolean, add final
-       if (!this.isInvulnerable(damagesource)) {
+        if (!this.isInvulnerable(damagesource)) {
             final boolean human = this instanceof EntityHuman;
             float originalDamage = f;
             Function<Double, Double> hardHat = new Function<Double, Double>() {
@@ -1233,6 +1285,7 @@ public abstract class EntityLiving extends Entity {
 
     public void setSprinting(boolean flag) {
         super.setSprinting(flag);
+
         AttributeInstance attributeinstance = this.getAttributeInstance(GenericAttributes.MOVEMENT_SPEED);
 
         if (attributeinstance.a(EntityLiving.a) != null) {
@@ -1427,7 +1480,7 @@ public abstract class EntityLiving extends Entity {
         d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
 
-        f2 = MathHelper.sqrt(d0 * d0 + d1 * d1) * 4.0F;
+        f2 = (float) MathHelper.sqrt(d0 * d0 + d1 * d1) * 4.0F;
         if (f2 > 1.0F) {
             f2 = 1.0F;
         }
@@ -1506,7 +1559,7 @@ public abstract class EntityLiving extends Entity {
             f3 = 1.0F;
             f2 = (float) Math.sqrt((double) f) * 3.0F;
             // CraftBukkit - Math -> TrigMath
-            f1 = (float) org.bukkit.craftbukkit.TrigMath.atan2(d1, d0) * 180.0F / 3.1415927F - 90.0F;
+            f1 = (float) FastMath.atan2(d1, d0) * 180.0F / 3.1415927F - 90.0F;
         }
 
         if (this.az > 0.0F) {
@@ -1678,7 +1731,9 @@ public abstract class EntityLiving extends Entity {
         if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
             numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
             for (int i = 0; i < list.size(); ++i) {
-                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
+                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) {
+                    break;
+                } // Spigot
                 Entity entity = (Entity) list.get(i);
 
                 // TODO better check now?
@@ -1750,18 +1805,17 @@ public abstract class EntityLiving extends Entity {
             EntityTracker entitytracker = ((WorldServer) this.world).getTracker();
 
             if (entity instanceof EntityItem) {
-                entitytracker.a(entity, (Packet) (new PacketPlayOutCollect(entity.getId(), this.getId())));
+                entitytracker.a(entity, new PacketPlayOutCollect(entity.getId(), this.getId()));
             }
 
             if (entity instanceof EntityArrow) {
-                entitytracker.a(entity, (Packet) (new PacketPlayOutCollect(entity.getId(), this.getId())));
+                entitytracker.a(entity, new PacketPlayOutCollect(entity.getId(), this.getId()));
             }
 
             if (entity instanceof EntityExperienceOrb) {
-                entitytracker.a(entity, (Packet) (new PacketPlayOutCollect(entity.getId(), this.getId())));
+                entitytracker.a(entity, new PacketPlayOutCollect(entity.getId(), this.getId()));
             }
         }
-
     }
 
     public boolean hasLineOfSight(Entity entity) {
@@ -1824,7 +1878,11 @@ public abstract class EntityLiving extends Entity {
     }
 
     public ScoreboardTeamBase getScoreboardTeam() {
-        return this.world.getScoreboard().getPlayerTeam(this.getUniqueID().toString());
+        if (this instanceof EntityHuman) {
+            return this.world.getScoreboard().getPlayerTeam(this.getUniqueID().toString());
+        } else {
+            return null;
+        }
     }
 
     public boolean c(EntityLiving entityliving) {
@@ -1832,7 +1890,7 @@ public abstract class EntityLiving extends Entity {
     }
 
     public boolean a(ScoreboardTeamBase scoreboardteambase) {
-        return this.getScoreboardTeam() != null ? this.getScoreboardTeam().isAlly(scoreboardteambase) : false;
+        return this.getScoreboardTeam() != null && this.getScoreboardTeam().isAlly(scoreboardteambase);
     }
 
     public void enterCombat() {}
diff --git a/src/main/java/net/minecraft/server/EntityMinecartAbstract.java b/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
index 4bf790cd..08fc6d94 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartAbstract.java
@@ -5,6 +5,7 @@ import java.util.Iterator;
 import java.util.Map;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.Location;
 import org.bukkit.entity.Vehicle;
 import org.bukkit.event.vehicle.VehicleDamageEvent;
diff --git a/src/main/java/net/minecraft/server/EntityMinecartFurnace.java b/src/main/java/net/minecraft/server/EntityMinecartFurnace.java
index 908620d4..87b6e5b0 100644
--- a/src/main/java/net/minecraft/server/EntityMinecartFurnace.java
+++ b/src/main/java/net/minecraft/server/EntityMinecartFurnace.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 public class EntityMinecartFurnace extends EntityMinecartAbstract {
 
     private int c;
diff --git a/src/main/java/net/minecraft/server/EntityMonster.java b/src/main/java/net/minecraft/server/EntityMonster.java
index 9fefb867..6f611f25 100644
--- a/src/main/java/net/minecraft/server/EntityMonster.java
+++ b/src/main/java/net/minecraft/server/EntityMonster.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
 import org.bukkit.event.entity.EntityCombustByEntityEvent; // CraftBukkit
 
 public abstract class EntityMonster extends EntityCreature implements IMonster {
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 0c49a256..8dfe4a2f 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -3,17 +3,19 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
+
 import io.netty.buffer.Unpooled;
+
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-// CraftBukkit start
 import org.bukkit.Bukkit;
 import org.bukkit.WeatherType;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -22,7 +24,6 @@ import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
-// CraftBukkit end
 
 public class EntityPlayer extends EntityHuman implements ICrafting {
 
@@ -50,8 +51,6 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean g;
     public int ping;
     public boolean viewingCredits;
-
-    // CraftBukkit start
     public String displayName;
     public IChatBaseComponent listName;
     public org.bukkit.Location compassTarget;
@@ -61,24 +60,23 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean keepLevel = false;
     public double maxHealthCache;
     public boolean joining = true;
-    // CraftBukkit end
-    // Spigot start
     public boolean collidesWithEntities = true;
-    public int viewDistance; // PaperSpigot - Player view distance API
-    private int containerUpdateDelay; // PaperSpigot
+    public int viewDistance;
+    private int containerUpdateDelay;
+    private boolean fakePlayer;
+    private boolean fakingDeath;
 
     @Override
     public boolean ad()
     {
-        return this.collidesWithEntities && super.ad(); // (first !this.isDead near bottom of EntityLiving)
+        return this.collidesWithEntities && super.ad();
     }
 
     @Override
     public boolean ae()
     {
-        return this.collidesWithEntities && super.ae(); // (second !this.isDead near bottom of EntityLiving)
+        return this.collidesWithEntities && super.ae();
     }
-    // Spigot end
 
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super(worldserver, gameprofile);
@@ -346,7 +344,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             }
 
             if (this.oldLevel != this.expLevel) {
-                CraftEventFactory.callPlayerLevelChangeEvent(this.world.getServer().getPlayer((EntityPlayer) this), this.oldLevel, this.expLevel);
+                CraftEventFactory.callPlayerLevelChangeEvent(this.world.getServer().getPlayer(this), this.oldLevel, this.expLevel);
                 this.oldLevel = this.expLevel;
             }
             // CraftBukkit end
@@ -1213,6 +1211,22 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.keepLevel = false;
     }
 
+    public void setFakePlayer(boolean flag) {
+        this.fakePlayer = flag;
+    }
+
+    public boolean isFakePlayer() {
+        return fakePlayer;
+    }
+
+    public void setFakingDeath(boolean fakingDeath) {
+        this.fakingDeath = fakingDeath;
+    }
+
+    public boolean isFakingDeath() {
+        return this.fakingDeath;
+    }
+
     @Override
     public CraftPlayer getBukkitEntity() {
         return (CraftPlayer) super.getBukkitEntity();
diff --git a/src/main/java/net/minecraft/server/EntityPotion.java b/src/main/java/net/minecraft/server/EntityPotion.java
index fd174c34..b6b8e872 100644
--- a/src/main/java/net/minecraft/server/EntityPotion.java
+++ b/src/main/java/net/minecraft/server/EntityPotion.java
@@ -2,13 +2,11 @@ package net.minecraft.server;
 
 import java.util.Iterator;
 import java.util.List;
-
-// CraftBukkit start
 import java.util.HashMap;
 
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.entity.LivingEntity;
-// CraftBukkit end
+import org.bukkit.entity.Player;
 
 public class EntityPotion extends EntityProjectile {
 
@@ -64,15 +62,15 @@ public class EntityPotion extends EntityProjectile {
         if (!this.world.isClientSide) {
             List list = Items.POTION.h(this.item);
 
-            if (true || list != null && !list.isEmpty()) { // CraftBukkit - Call event even if no effects to apply
+            if (true || list != null && !list.isEmpty()) {
                 AxisAlignedBB axisalignedbb = this.getBoundingBox().grow(4.0D, 2.0D, 4.0D);
                 List list1 = this.world.a(EntityLiving.class, axisalignedbb);
 
-                if (true || !list1.isEmpty()) { // CraftBukkit - Run code even if there are no entities around
+                if (true || !list1.isEmpty()) {
                     Iterator iterator = list1.iterator();
 
                     // CraftBukkit
-                    HashMap<LivingEntity, Double> affected = new HashMap<LivingEntity, Double>();
+                    HashMap<LivingEntity, Double> affected = new HashMap<>();
 
                     while (iterator.hasNext()) {
                         EntityLiving entityliving = (EntityLiving) iterator.next();
@@ -85,21 +83,33 @@ public class EntityPotion extends EntityProjectile {
                                 d1 = 1.0D;
                             }
 
-                            // CraftBukkit start
                             affected.put((LivingEntity) entityliving.getBukkitEntity(), d1);
                         }
                     }
 
                     org.bukkit.event.entity.PotionSplashEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPotionSplashEvent(this, affected);
-                    if (!event.isCancelled() && list != null && !list.isEmpty()) { // do not process effects if there are no effects to process
+
+                    if (event.getEntity().getShooter() instanceof Player) {
+                        Player shooter = (Player) event.getEntity().getShooter();
+
+                        if (shooter.isSprinting() && event.getIntensity(shooter) > 0.5D) {
+                            event.setIntensity(shooter, 1.0D);
+                        }
+                    }
+
+                    if (!event.isCancelled() && list != null && !list.isEmpty()) {
                         for (LivingEntity victim : event.getAffectedEntities()) {
                             if (!(victim instanceof CraftLivingEntity)) {
                                 continue;
                             }
 
                             EntityLiving entityliving = ((CraftLivingEntity) victim).getHandle();
+
+                            if (entityliving instanceof EntityPlayer && !((EntityPlayer) entityliving).getBukkitEntity().canSeeEntity(this.getShooter().getBukkitEntity())) {
+                                continue;
+                            }
+
                             double d1 = event.getIntensity(victim);
-                            // CraftBukkit end
 
                             Iterator iterator1 = list.iterator();
 
@@ -129,7 +139,11 @@ public class EntityPotion extends EntityProjectile {
                 }
             }
 
-            this.world.triggerEffect(2002, new BlockPosition(this), this.getPotionValue());
+            if (this.getShooter() instanceof EntityHuman) {
+                this.world.a((EntityHuman) this.getShooter(), 2002, new BlockPosition(this), this.getPotionValue());
+            } else {
+                this.world.triggerEffect(2002, new BlockPosition(this), this.getPotionValue());
+            }
             this.die();
         }
 
diff --git a/src/main/java/net/minecraft/server/EntityProjectile.java b/src/main/java/net/minecraft/server/EntityProjectile.java
index e7cca3c6..d45114c7 100644
--- a/src/main/java/net/minecraft/server/EntityProjectile.java
+++ b/src/main/java/net/minecraft/server/EntityProjectile.java
@@ -3,6 +3,11 @@ package net.minecraft.server;
 import java.util.List;
 import java.util.UUID;
 
+import net.jafama.FastMath;
+import org.bukkit.entity.Player;
+import org.bukkit.potion.PotionEffect;
+import org.bukkit.potion.PotionEffectType;
+
 public abstract class EntityProjectile extends Entity implements IProjectile {
 
     private int blockX = -1;
@@ -57,7 +62,16 @@ public abstract class EntityProjectile extends Entity implements IProjectile {
     }
 
     public void shoot(double d0, double d1, double d2, float f, float f1) {
-        float f2 = MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+        /*
+        if (this instanceof EntityPotion && this.shooter.isSprinting()) {
+            Player player = (Player) this.shooter.getBukkitEntity();
+            for (PotionEffect effect : player.getActivePotionEffects()) {
+                if (effect.getType().equals(PotionEffectType.SPEED)) {
+                    f += (effect.getAmplifier() + 1) * 0.0415F;
+                }
+            }
+        } */
+        float f2 = (float) MathHelper.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
 
         d0 /= (double) f2;
         d1 /= (double) f2;
@@ -68,10 +82,11 @@ public abstract class EntityProjectile extends Entity implements IProjectile {
         d0 *= (double) f;
         d1 *= (double) f;
         d2 *= (double) f;
+
         this.motX = d0;
         this.motY = d1;
         this.motZ = d2;
-        float f3 = MathHelper.sqrt(d0 * d0 + d2 * d2);
+        float f3 = (float) MathHelper.sqrt(d0 * d0 + d2 * d2);
 
         this.lastYaw = this.yaw = (float) (MathHelper.b(d0, d2) * 180.0D / 3.1415927410125732D);
         this.lastPitch = this.pitch = (float) (MathHelper.b(d1, (double) f3) * 180.0D / 3.1415927410125732D);
@@ -171,7 +186,7 @@ public abstract class EntityProjectile extends Entity implements IProjectile {
         this.locX += this.motX;
         this.locY += this.motY;
         this.locZ += this.motZ;
-        float f1 = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+        float f1 = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
 
         this.yaw = (float) (MathHelper.b(this.motX, this.motZ) * 180.0D / 3.1415927410125732D);
 
diff --git a/src/main/java/net/minecraft/server/EntitySheep.java b/src/main/java/net/minecraft/server/EntitySheep.java
index 29611a19..3193e959 100644
--- a/src/main/java/net/minecraft/server/EntitySheep.java
+++ b/src/main/java/net/minecraft/server/EntitySheep.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
 import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.Random;
@@ -79,13 +80,15 @@ public class EntitySheep extends EntityAnimal {
             this.a(new ItemStack(Item.getItemOf(Blocks.WOOL), 1, this.getColor().getColorIndex()), 0.0F);
         }
 
-        int j = this.random.nextInt(2) + 1 + this.random.nextInt(1 + i);
+        if(PotionSpigot.INSTANCE.getConfig().isBaseVersionEnabled()) {
+            int j = this.random.nextInt(2) + 1 + this.random.nextInt(1 + i);
 
-        for (int k = 0; k < j; ++k) {
-            if (this.isBurning()) {
-                this.a(Items.COOKED_MUTTON, 1);
-            } else {
-                this.a(Items.MUTTON, 1);
+            for (int k = 0; k < j; ++k) {
+                if (this.isBurning()) {
+                    this.a(Items.COOKED_MUTTON, 1);
+                } else {
+                    this.a(Items.MUTTON, 1);
+                }
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/EntitySlime.java b/src/main/java/net/minecraft/server/EntitySlime.java
index c927832b..7f9b2451 100644
--- a/src/main/java/net/minecraft/server/EntitySlime.java
+++ b/src/main/java/net/minecraft/server/EntitySlime.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.event.entity.SlimeSplitEvent;
 // CraftBukkit end
 
@@ -81,7 +82,7 @@ public class EntitySlime extends EntityInsentient implements IMonster {
             for (int j = 0; j < i * 8; ++j) {
                 float f = this.random.nextFloat() * 3.1415927F * 2.0F;
                 float f1 = this.random.nextFloat() * 0.5F + 0.5F;
-                float f2 = MathHelper.sin(f) * (float) i * 0.5F * f1;
+                float f2 = (float) MathHelper.sin(f) * (float) i * 0.5F * f1;
                 float f3 = MathHelper.cos(f) * (float) i * 0.5F * f1;
                 World world = this.world;
                 EnumParticle enumparticle = this.n();
diff --git a/src/main/java/net/minecraft/server/EntitySnowman.java b/src/main/java/net/minecraft/server/EntitySnowman.java
index cb875c75..d63ac2d3 100644
--- a/src/main/java/net/minecraft/server/EntitySnowman.java
+++ b/src/main/java/net/minecraft/server/EntitySnowman.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.event.block.EntityBlockFormEvent;
@@ -83,7 +84,7 @@ public class EntitySnowman extends EntityGolem implements IRangedEntity {
         double d1 = entityliving.locX - this.locX;
         double d2 = d0 - entitysnowball.locY;
         double d3 = entityliving.locZ - this.locZ;
-        float f1 = MathHelper.sqrt(d1 * d1 + d3 * d3) * 0.2F;
+        float f1 = (float) MathHelper.sqrt(d1 * d1 + d3 * d3) * 0.2F;
 
         entitysnowball.shoot(d1, d2 + (double) f1, d3, 1.6F, 12.0F);
         this.makeSound("random.bow", 1.0F, 1.0F / (this.bc().nextFloat() * 0.4F + 0.8F));
diff --git a/src/main/java/net/minecraft/server/EntitySquid.java b/src/main/java/net/minecraft/server/EntitySquid.java
index 31996b46..e6af96e0 100644
--- a/src/main/java/net/minecraft/server/EntitySquid.java
+++ b/src/main/java/net/minecraft/server/EntitySquid.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 public class EntitySquid extends EntityWaterAnimal {
 
     public float a;
@@ -98,7 +100,7 @@ public class EntitySquid extends EntityWaterAnimal {
 
             if (this.bl < 3.1415927F) {
                 f = this.bl / 3.1415927F;
-                this.bn = MathHelper.sin(f * f * 3.1415927F) * 3.1415927F * 0.25F;
+                this.bn = (float) MathHelper.sin(f * f * 3.1415927F) * 3.1415927F * 0.25F;
                 if ((double) f > 0.75D) {
                     this.bp = 1.0F;
                     this.br = 1.0F;
@@ -117,13 +119,13 @@ public class EntitySquid extends EntityWaterAnimal {
                 this.motZ = (double) (this.bu * this.bp);
             }
 
-            f = MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
+            f = (float) MathHelper.sqrt(this.motX * this.motX + this.motZ * this.motZ);
             this.aI += (-((float) MathHelper.b(this.motX, this.motZ)) * 180.0F / 3.1415927F - this.aI) * 0.1F;
             this.yaw = this.aI;
             this.c = (float) ((double) this.c + 3.141592653589793D * (double) this.br * 1.5D);
             this.a += (-((float) MathHelper.b((double) f, this.motY)) * 180.0F / 3.1415927F - this.a) * 0.1F;
         } else {
-            this.bn = MathHelper.e(MathHelper.sin(this.bl)) * 3.1415927F * 0.25F;
+            this.bn = MathHelper.e((float) MathHelper.sin(this.bl)) * 3.1415927F * 0.25F;
             if (!this.world.isClientSide) {
                 this.motX = 0.0D;
                 this.motY -= 0.08D;
@@ -174,9 +176,9 @@ public class EntitySquid extends EntityWaterAnimal {
                 this.a.b(0.0F, 0.0F, 0.0F);
             } else if (this.a.bc().nextInt(50) == 0 || !this.a.inWater || !this.a.n()) {
                 float f = this.a.bc().nextFloat() * 3.1415927F * 2.0F;
-                float f1 = MathHelper.cos(f) * 0.2F;
+                float f1 = (float) MathHelper.cos(f) * 0.2F;
                 float f2 = -0.1F + this.a.bc().nextFloat() * 0.2F;
-                float f3 = MathHelper.sin(f) * 0.2F;
+                float f3 = (float) MathHelper.sin(f) * 0.2F;
 
                 this.a.b(f1, f2, f3);
             }
diff --git a/src/main/java/net/minecraft/server/EntityTNTPrimed.java b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
index 872d9659..8f4cc19a 100644
--- a/src/main/java/net/minecraft/server/EntityTNTPrimed.java
+++ b/src/main/java/net/minecraft/server/EntityTNTPrimed.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
 import org.bukkit.event.entity.ExplosionPrimeEvent; // CraftBukkit
 
 public class EntityTNTPrimed extends Entity {
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index cb72b367..83c6fdbc 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -234,7 +234,7 @@ public class EntityTracker {
         while (iterator.hasNext()) {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
-            entitytrackerentry.clear(entityplayer);
+            entitytrackerentry.clear(entityplayer, true);
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 1fc2388e..c24197bf 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -1,6 +1,5 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
@@ -9,8 +8,6 @@ import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerVelocityEvent;
 // CraftBukkit end
 
 public class EntityTrackerEntry {
@@ -128,6 +125,7 @@ public class EntityTrackerEntry {
 
                 if (this.m > 0 || this.tracker instanceof EntityArrow) { // PaperSpigot - Moved up
                     // CraftBukkit start - Code moved from below
+
                     if (flag) {
                         this.xLoc = i;
                         this.yLoc = j;
@@ -141,7 +139,7 @@ public class EntityTrackerEntry {
                     // CraftBukkit end
 
                     if (j1 >= -128 && j1 < 128 && k1 >= -128 && k1 < 128 && l1 >= -128 && l1 < 128 && this.v <= 400 && !this.x && this.y == this.tracker.onGround) {
-                        if ((!flag || !flag1) && !(this.tracker instanceof EntityArrow)) {
+                        if (((!flag || !flag1) && !(this.tracker instanceof EntityArrow))) {
                             if (flag) {
                                 object = new PacketPlayOutEntity.PacketPlayOutRelEntityMove(this.tracker.getId(), (byte) j1, (byte) k1, (byte) l1, this.tracker.onGround);
                             } else if (flag1) {
@@ -245,6 +243,7 @@ public class EntityTrackerEntry {
         ++this.m;
         if (this.tracker.velocityChanged) {
             // CraftBukkit start - Create PlayerVelocity event
+            /*
             boolean cancelled = false;
 
             if (this.tracker instanceof EntityPlayer) {
@@ -264,7 +263,9 @@ public class EntityTrackerEntry {
             if (!cancelled) {
                 this.broadcastIncludingSelf(new PacketPlayOutEntityVelocity(this.tracker));
             }
+            */
             // CraftBukkit end
+            this.broadcastIncludingSelf(new PacketPlayOutEntityVelocity(this.tracker));
             this.tracker.velocityChanged = false;
         }
 
@@ -273,8 +274,28 @@ public class EntityTrackerEntry {
     private void b() {
         DataWatcher datawatcher = this.tracker.getDataWatcher();
 
-        if (datawatcher.a()) {
-            this.broadcastIncludingSelf(new PacketPlayOutEntityMetadata(this.tracker.getId(), datawatcher, false));
+        boolean fakingDeath = false;
+        boolean isPlayer = this.tracker instanceof EntityPlayer;
+
+        if (isPlayer) {
+            fakingDeath = ((EntityPlayer) this.tracker).isFakingDeath();
+        }
+        if (datawatcher.a() || fakingDeath) {
+            if (isPlayer) {
+                if (fakingDeath) {
+                    datawatcher.watch(6, 0.0F);
+                    ((EntityPlayer) this.tracker).setFakingDeath(false);
+                }
+            }
+            this.broadcast(new PacketPlayOutEntityMetadata(this.tracker.getId(), datawatcher, false));
+	        //Update the metadata we send to the player we're tracking itself,
+	        //because we're faking some metadata to the other players..
+            if (isPlayer) {
+                DataWatcher otherWatcher = datawatcher.clone();
+                EntityPlayer player = ((EntityPlayer) this.tracker);
+                otherWatcher.watch(6, player.getHealth());
+	            player.playerConnection.sendPacket(new PacketPlayOutEntityMetadata(this.tracker.getId(), otherWatcher, false));
+            }
         }
 
         if (this.tracker instanceof EntityLiving) {
@@ -338,12 +359,8 @@ public class EntityTrackerEntry {
         if (entityplayer != this.tracker) {
             if (this.c(entityplayer)) {
                 if (!this.trackedPlayers.contains(entityplayer) && (this.e(entityplayer) || this.tracker.attachedToPlayer)) {
-                    // CraftBukkit start - respect vanish API
-                    if (this.tracker instanceof EntityPlayer) {
-                        Player player = ((EntityPlayer) this.tracker).getBukkitEntity();
-                        if (!entityplayer.getBukkitEntity().canSee(player)) {
-                            return;
-                        }
+                    if (!entityplayer.getBukkitEntity().canSeeEntity(this.tracker.getBukkitEntity())) {
+                        return;
                     }
 
                     entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
@@ -564,11 +581,15 @@ public class EntityTrackerEntry {
         }
     }
 
-    public void clear(EntityPlayer entityplayer) {
+    public void clear(EntityPlayer entityplayer, boolean sendDestroy) {
         org.spigotmc.AsyncCatcher.catchOp( "player tracker clear"); // Spigot
+
         if (this.trackedPlayers.contains(entityplayer)) {
             this.trackedPlayers.remove(entityplayer);
-            entityplayer.d(this.tracker);
+
+            if (sendDestroy) {
+                entityplayer.d(this.tracker);
+            }
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index fb19bad3..bd5736ae 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -6,6 +6,7 @@ import java.util.Iterator;
 import java.util.List;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityRegainHealthEvent;
 import org.bukkit.event.entity.ExplosionPrimeEvent;
@@ -355,7 +356,7 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
             return this.locZ;
         } else {
             float f = (this.aI + (float) (180 * (i - 1))) / 180.0F * 3.1415927F;
-            float f1 = MathHelper.sin(f);
+            float f1 = (float) MathHelper.sin(f);
 
             return this.locZ + (double) f1 * 1.3D;
         }
diff --git a/src/main/java/net/minecraft/server/EntityWolf.java b/src/main/java/net/minecraft/server/EntityWolf.java
index 469c87a1..27933de3 100644
--- a/src/main/java/net/minecraft/server/EntityWolf.java
+++ b/src/main/java/net/minecraft/server/EntityWolf.java
@@ -3,6 +3,7 @@ package net.minecraft.server;
 import com.google.common.base.Predicate;
 
 // CraftBukkit start
+import net.jafama.FastMath;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityTargetEvent.TargetReason;
 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/Explosion.java b/src/main/java/net/minecraft/server/Explosion.java
index b7d410ee..b587bef3 100644
--- a/src/main/java/net/minecraft/server/Explosion.java
+++ b/src/main/java/net/minecraft/server/Explosion.java
@@ -2,19 +2,19 @@ package net.minecraft.server;
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
+
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
 
-// CraftBukkit start
+import net.jafama.FastMath;
+
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.entity.EntityExplodeEvent;
 import org.bukkit.Location;
 import org.bukkit.event.block.BlockExplodeEvent;
-// CraftBukkit end
 
 public class Explosion {
 
@@ -43,13 +43,11 @@ public class Explosion {
     }
 
     public void a() {
-        // CraftBukkit start
         if (this.size < 0.1F) {
             return;
         }
-        // CraftBukkit end
-        HashSet hashset = Sets.newHashSet();
-        boolean flag = true;
+
+        HashSet<BlockPosition> hashSet = new HashSet<>();
 
         int i;
         int j;
@@ -82,7 +80,7 @@ public class Explosion {
                             }
 
                             if (f > 0.0F && (this.source == null || this.source.a(this, this.world, blockposition, iblockdata, f)) && blockposition.getY() < 256 && blockposition.getY() >= 0) { // CraftBukkit - don't wrap explosions
-                                hashset.add(blockposition);
+                                hashSet.add(blockposition);
                             }
 
                             d4 += d0 * 0.30000001192092896D;
@@ -94,7 +92,7 @@ public class Explosion {
             }
         }
 
-        this.blocks.addAll(hashset);
+        this.blocks.addAll(hashSet);
         float f3 = this.size * 2.0F;
 
         i = MathHelper.floor(this.posX - (double) f3 - 1.0D);
@@ -103,14 +101,14 @@ public class Explosion {
         int i1 = MathHelper.floor(this.posY + (double) f3 + 1.0D);
         int j1 = MathHelper.floor(this.posZ - (double) f3 - 1.0D);
         int k1 = MathHelper.floor(this.posZ + (double) f3 + 1.0D);
-        // PaperSpigot start - Fix lag from explosions processing dead entities
+
         List list = this.world.a(this.source, new AxisAlignedBB((double) i, (double) l, (double) j1, (double) j, (double) i1, (double) k1), new com.google.common.base.Predicate<Entity>() {
             @Override
             public boolean apply(Entity entity) {
                 return IEntitySelector.d.apply(entity) && !entity.dead;
             }
         });
-        // PaperSpigot end
+
         Vec3D vec3d = new Vec3D(this.posX, this.posY, this.posZ);
 
         for (int l1 = 0; l1 < list.size(); ++l1) {
@@ -123,35 +121,27 @@ public class Explosion {
                     double d8 = entity.locX - this.posX;
                     double d9 = entity.locY + (double) entity.getHeadHeight() - this.posY;
                     double d10 = entity.locZ - this.posZ;
-                    double d11 = (double) MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
+                    double d11 = MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
 
                     if (d11 != 0.0D) {
                         d8 /= d11;
                         d9 /= d11;
                         d10 /= d11;
-                        double d12 = this.getBlockDensity(vec3d, entity.getBoundingBox()); // PaperSpigot - Optimize explosions
+                        double d12 = this.getBlockDensity(vec3d, entity.getBoundingBox());
                         double d13 = (1.0D - d7) * d12;
 
-                        // entity.damageEntity(DamageSource.explosion(this), (float) ((int) ((d13 * d13 + d13) / 2.0D * 8.0D * (double) f3 + 1.0D)));+                        // CraftBukkit start
                         CraftEventFactory.entityDamage = source;
                         entity.forceExplosionKnockback = false;
                         boolean wasDamaged = entity.damageEntity(DamageSource.explosion(this), (float) ((int) ((d13 * d13 + d13) / 2.0D * 8.0D * (double) f3 + 1.0D)));
                         CraftEventFactory.entityDamage = null;
+
                         if (!wasDamaged && !(entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && !entity.forceExplosionKnockback) {
                             continue;
                         }
-                        // CraftBukkit end
+
                         double d14 = entity instanceof EntityHuman && world.paperSpigotConfig.disableExplosionKnockback ? 0 : EnchantmentProtection.a(entity, d13); // PaperSpigot
 
-                        // PaperSpigot start - Fix cannons
-                        /*
-                        entity.motX += d8 * d14;
-                        entity.motY += d9 * d14;
-                        entity.motZ += d10 * d14;
-                        */
-                        // This impulse method sets the dirty flag, so clients will get an immediate velocity update
                         entity.g(d8 * d14, d9 * d14, d10 * d14);
-                        // PaperSpigot end
 
                         if (entity instanceof EntityHuman && !((EntityHuman) entity).abilities.isInvulnerable && !world.paperSpigotConfig.disableExplosionKnockback) { // PaperSpigot
                             this.k.put((EntityHuman) entity, new Vec3D(d8 * d13, d9 * d13, d10 * d13));
@@ -164,14 +154,14 @@ public class Explosion {
     }
 
     public void a(boolean flag) {
-        // PaperSpigot start - Configurable TNT explosion volume.
         float volume = source instanceof EntityTNTPrimed ? world.paperSpigotConfig.tntExplosionVolume : 4.0F;
+
         this.world.makeSound(this.posX, this.posY, this.posZ, "random.explode", volume, (1.0F + (this.world.random.nextFloat() - this.world.random.nextFloat()) * 0.2F) * 0.7F);
-        // PaperSpigot end
+
         if (this.size >= 2.0F && this.b) {
-            this.world.addParticle(EnumParticle.EXPLOSION_HUGE, this.posX, this.posY, this.posZ, 1.0D, 0.0D, 0.0D, new int[0]);
+            this.world.addParticle(EnumParticle.EXPLOSION_HUGE, this.posX, this.posY, this.posZ, 1.0D, 0.0D, 0.0D);
         } else {
-            this.world.addParticle(EnumParticle.EXPLOSION_LARGE, this.posX, this.posY, this.posZ, 1.0D, 0.0D, 0.0D, new int[0]);
+            this.world.addParticle(EnumParticle.EXPLOSION_LARGE, this.posX, this.posY, this.posZ, 1.0D, 0.0D, 0.0D);
         }
 
         Iterator iterator;
@@ -184,9 +174,12 @@ public class Explosion {
             Location location = new Location(bworld, this.posX, this.posY, this.posZ);
 
             List<org.bukkit.block.Block> blockList = Lists.newArrayList();
+
             for (int i1 = this.blocks.size() - 1; i1 >= 0; i1--) {
-                BlockPosition cpos = (BlockPosition) this.blocks.get(i1);
+                BlockPosition cpos = this.blocks.get(i1);
+
                 org.bukkit.block.Block bblock = bworld.getBlockAt(cpos.getX(), cpos.getY(), cpos.getZ());
+
                 if (bblock.getType() != org.bukkit.Material.AIR) {
                     blockList.add(bblock);
                 }
@@ -221,14 +214,13 @@ public class Explosion {
                 this.wasCanceled = true;
                 return;
             }
-            // CraftBukkit end
+
             iterator = this.blocks.iterator();
 
             while (iterator.hasNext()) {
                 blockposition = (BlockPosition) iterator.next();
                 Block block = this.world.getType(blockposition).getBlock();
 
-                world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
                 if (flag) {
                     double d0 = (double) ((float) blockposition.getX() + this.world.random.nextFloat());
                     double d1 = (double) ((float) blockposition.getY() + this.world.random.nextFloat());
@@ -236,7 +228,7 @@ public class Explosion {
                     double d3 = d0 - this.posX;
                     double d4 = d1 - this.posY;
                     double d5 = d2 - this.posZ;
-                    double d6 = (double) MathHelper.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
+                    double d6 = MathHelper.sqrt(d3 * d3 + d4 * d4 + d5 * d5);
 
                     d3 /= d6;
                     d4 /= d6;
@@ -247,8 +239,9 @@ public class Explosion {
                     d3 *= d7;
                     d4 *= d7;
                     d5 *= d7;
+
                     this.world.addParticle(EnumParticle.EXPLOSION_NORMAL, (d0 + this.posX * 1.0D) / 2.0D, (d1 + this.posY * 1.0D) / 2.0D, (d2 + this.posZ * 1.0D) / 2.0D, d3, d4, d5, new int[0]);
-                    this.world.addParticle(EnumParticle.SMOKE_NORMAL, d0, d1, d2, d3, d4, d5, new int[0]);
+                    this.world.addParticle(EnumParticle.SMOKE_NORMAL, d0, d1, d2, d3, d4, d5);
                 }
 
                 if (block.getMaterial() != Material.AIR) {
diff --git a/src/main/java/net/minecraft/server/ItemBoat.java b/src/main/java/net/minecraft/server/ItemBoat.java
index eb62bbb6..7a4178b4 100644
--- a/src/main/java/net/minecraft/server/ItemBoat.java
+++ b/src/main/java/net/minecraft/server/ItemBoat.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
+
 import java.util.List;
 
 public class ItemBoat extends Item {
@@ -18,13 +20,14 @@ public class ItemBoat extends Item {
         double d2 = entityhuman.lastZ + (entityhuman.locZ - entityhuman.lastZ) * (double) f;
         Vec3D vec3d = new Vec3D(d0, d1, d2);
         float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
-        float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
+        float f4 = (float) MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
         float f5 = -MathHelper.cos(-f1 * 0.017453292F);
-        float f6 = MathHelper.sin(-f1 * 0.017453292F);
+        float f6 = (float) MathHelper.sin(-f1 * 0.017453292F);
         float f7 = f4 * f5;
         float f8 = f3 * f5;
         double d3 = 5.0D;
         Vec3D vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+        //TODO: Fucking Raytrace but its a boat so who cares bro
         MovingObjectPosition movingobjectposition = world.rayTrace(vec3d, vec3d1, true);
 
         if (movingobjectposition == null) {
@@ -56,6 +59,7 @@ public class ItemBoat extends Item {
 
                     // CraftBukkit start - Boat placement
                     org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(entityhuman, org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK, blockposition, movingobjectposition.direction, itemstack);
+//                    org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(entityhuman, org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK, blockposition, itemstack);
 
                     if (event.isCancelled()) {
                         return itemstack;
diff --git a/src/main/java/net/minecraft/server/ItemMinecart.java b/src/main/java/net/minecraft/server/ItemMinecart.java
index e9fc40e9..0bdf8270 100644
--- a/src/main/java/net/minecraft/server/ItemMinecart.java
+++ b/src/main/java/net/minecraft/server/ItemMinecart.java
@@ -109,6 +109,7 @@ public class ItemMinecart extends Item {
 
                 // CraftBukkit start - Minecarts
                 org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(entityhuman, org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK, blockposition, enumdirection, itemstack);
+//                org.bukkit.event.player.PlayerInteractEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerInteractEvent(entityhuman, org.bukkit.event.block.Action.RIGHT_CLICK_BLOCK, blockposition, itemstack);
 
                 if (event.isCancelled()) {
                     return false;
diff --git a/src/main/java/net/minecraft/server/LoginListener.java b/src/main/java/net/minecraft/server/LoginListener.java
index 541cec7c..3b5f26d8 100644
--- a/src/main/java/net/minecraft/server/LoginListener.java
+++ b/src/main/java/net/minecraft/server/LoginListener.java
@@ -152,7 +152,7 @@ public class LoginListener implements PacketLoginInListener, IUpdatePlayerListBo
     }
 
     public String d() {
-        return this.i != null ? this.i.toString() + " (" + this.networkManager.getSocketAddress().toString() + ")" : String.valueOf(this.networkManager.getSocketAddress());
+        return this.i != null ? this.i.getName() + "(" + this.i.getId().toString() + ") (" + this.networkManager.getSocketAddress().toString() + ")" : String.valueOf(this.networkManager.getSocketAddress());
     }
 
     public void a(PacketLoginInStart packetlogininstart) {
@@ -249,9 +249,11 @@ public class LoginListener implements PacketLoginInListener, IUpdatePlayerListBo
 
                             if (PlayerPreLoginEvent.getHandlerList().getRegisteredListeners().length != 0) {
                                 final PlayerPreLoginEvent event = new PlayerPreLoginEvent(playerName, address, uniqueId);
+
                                 if (asyncEvent.getResult() != PlayerPreLoginEvent.Result.ALLOWED) {
                                     event.disallow(asyncEvent.getResult(), asyncEvent.getKickMessage());
                                 }
+
                                 Waitable<PlayerPreLoginEvent.Result> waitable = new Waitable<PlayerPreLoginEvent.Result>() {
                                     @Override
                                     protected PlayerPreLoginEvent.Result evaluate() {
diff --git a/src/main/java/net/minecraft/server/MethodProfiler.java b/src/main/java/net/minecraft/server/MethodProfiler.java
index 2aea31b6..3f8b1d23 100644
--- a/src/main/java/net/minecraft/server/MethodProfiler.java
+++ b/src/main/java/net/minecraft/server/MethodProfiler.java
@@ -1,14 +1,6 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start - Strip down to empty methods, performance cost
 public class MethodProfiler {
@@ -53,7 +45,7 @@ public class MethodProfiler {
         }
 
         public int compareTo(MethodProfiler.ProfilerInfo object) {
-            return this.a((MethodProfiler.ProfilerInfo) object);
+            return this.a(object);
         }
     }
 }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index b400ce04..e16a5c0d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -2,7 +2,6 @@ package net.minecraft.server;
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -10,10 +9,12 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.base64.Base64;
+
 import java.awt.GraphicsEnvironment;
 import java.awt.image.BufferedImage;
 import java.io.File;
@@ -25,7 +26,6 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -34,24 +34,22 @@ import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
 import javax.imageio.ImageIO;
+
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-// CraftBukkit start
-import java.io.IOException;
-
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.craftbukkit.Main;
-import co.aikar.timings.SpigotTimings; // Spigot
-// CraftBukkit end
+import co.aikar.timings.SpigotTimings;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
     public static final Logger LOGGER = LogManager.getLogger();
     public static final File a = new File("usercache.json");
+    public static long LAST_TICK_TIME;
     private static MinecraftServer l;
     public Convertable convertable;
     private final MojangStatisticsGenerator n = new MojangStatisticsGenerator("server", this, az());
@@ -59,13 +57,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
     protected final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
-    private ServerConnection q; // Spigot
+    private ServerConnection serverConnection;
     private final ServerPing r = new ServerPing();
     private final Random s = new Random();
     private String serverIp;
     private int u = -1;
     public WorldServer[] worldServer;
-    private PlayerList v;
+    private PlayerList playerList;
     private boolean isRunning = true;
     private boolean isStopped;
     private int ticks;
@@ -78,13 +76,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     private boolean pvpMode;
     private boolean allowFlight;
     private String motd;
-    private int F;
+    private int maxBuildHeight;
     private int G = 0;
     public final long[] h = new long[100];
     public long[][] i;
     private KeyPair H;
     private String I;
-    private String J;
+    private String worldName;
     private boolean demoMode;
     private boolean M;
     private boolean N;
@@ -100,65 +98,63 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     private long X = 0L;
     private final GameProfileRepository Y;
     private final UserCache Z;
-    protected final Queue<FutureTask<?>> j = new java.util.concurrent.ConcurrentLinkedQueue<FutureTask<?>>(); // Spigot, PAIL: Rename
+    protected final Queue<FutureTask<?>> j = new java.util.concurrent.ConcurrentLinkedQueue<>();
     private Thread serverThread;
     private long ab = az();
 
-    // CraftBukkit start
-    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public List<WorldServer> worlds = new ArrayList<>();
     public org.bukkit.craftbukkit.CraftServer server;
     public OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
     public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
     public ConsoleReader reader;
-    public static int currentTick = 0; // PaperSpigot - Further improve tick loop
+    public static int currentTick = 0;
     public final Thread primaryThread;
-    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
-    public int autosavePeriod;
-    // CraftBukkit end
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    public int autoSavePeriod;
 
     public MinecraftServer(OptionSet options, Proxy proxy, File file1) {
-        io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
+        io.netty.util.ResourceLeakDetector.setEnabled(false);
+
         this.e = proxy;
         MinecraftServer.l = this;
-        // this.universe = file; // CraftBukkit
-        // this.q = new ServerConnection(this); // Spigot
         this.Z = new UserCache(this, file1);
         this.b = this.h();
-        // this.convertable = new WorldLoaderServer(file); // CraftBukkit - moved to DedicatedServer.init
         this.V = new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString());
         this.W = this.V.createMinecraftSessionService();
         this.Y = this.V.createProfileRepository();
-        // CraftBukkit start
+
         this.options = options;
-        // Try to see if we're actually running in a terminal, disable jline if not
+
         if (System.console() == null && System.getProperty("jline.terminal") == null) {
             System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+
             Main.useJline = false;
         }
 
         try {
             reader = new ConsoleReader(System.in, System.out);
-            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+            reader.setExpandEvents(false);
         } catch (Throwable e) {
             try {
-                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
                 System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
                 System.setProperty("user.language", "en");
+
                 Main.useJline = false;
+
                 reader = new ConsoleReader(System.in, System.out);
                 reader.setExpandEvents(false);
             } catch (IOException ex) {
                 LOGGER.warn((String) null, ex);
             }
         }
+
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
 
-        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
+        this.serverThread = primaryThread = new Thread(this, "Server thread");
     }
 
     public abstract PropertyManager getPropertyManager();
-    // CraftBukkit end
 
     protected CommandDispatcher h() {
         return new CommandDispatcher();
@@ -170,6 +166,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         if (this.getConvertable().isConvertable(s)) {
             MinecraftServer.LOGGER.info("Converting map!");
             this.b("menu.convertingLevel");
+
             this.getConvertable().convert(s, new IProgressUpdate() {
                 private long b = System.currentTimeMillis();
 
@@ -197,31 +194,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.a(s);
         this.b("menu.loadingLevel");
         this.worldServer = new WorldServer[3];
-        /* CraftBukkit start - Remove ticktime arrays and worldsettings
-        this.i = new long[this.worldServer.length][100];
-        IDataManager idatamanager = this.convertable.a(s, true);
 
-        this.a(this.U(), idatamanager);
-        WorldData worlddata = idatamanager.getWorldData();
-        WorldSettings worldsettings;
-
-        if (worlddata == null) {
-            if (this.X()) {
-                worldsettings = DemoWorldServer.a;
-            } else {
-                worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
-                worldsettings.setGeneratorSettings(s2);
-                if (this.M) {
-                    worldsettings.a();
-                }
-            }
-
-            worlddata = new WorldData(worldsettings, s1);
-        } else {
-            worlddata.a(s1);
-            worldsettings = new WorldSettings(worlddata);
-        }
-        */
         int worldCount = 3;
 
         for (int j = 0; j < worldCount; ++j) {
@@ -254,10 +227,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             if (j == 0) {
                 IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), s1, true);
                 WorldData worlddata = idatamanager.getWorldData();
+
                 if (worlddata == null) {
                     worlddata = new WorldData(worldsettings, s1);
                 }
-                worlddata.checkName(s1); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+
+                worlddata.checkName(s1);
+
                 if (this.X()) {
                     world = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler)).b();
                 } else {
@@ -265,6 +241,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 }
 
                 world.a(worldsettings);
+
                 this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
             } else {
                 String dim = "DIM" + dimension;
@@ -302,18 +279,19 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 }
 
                 IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), name, true);
-                // world =, b0 to dimension, s1 to name, added Environment and gen
                 WorldData worlddata = idatamanager.getWorldData();
+
                 if (worlddata == null) {
                     worlddata = new WorldData(worldsettings, name);
                 }
-                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+
+                worlddata.checkName(name);
                 world = (WorldServer) new SecondaryWorldServer(this, idatamanager, dimension, this.worlds.get(0), this.methodProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).b();
             }
 
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
-
             world.addIWorldAccess(new WorldManager(this, world));
+
             if (!this.T()) {
                 world.getWorldData().setGameType(this.getGamemode());
             }
@@ -322,22 +300,15 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             getPlayerList().setPlayerFileData(worlds.toArray(new WorldServer[worlds.size()]));
         }
 
-        // CraftBukkit end
         this.a(this.getDifficulty());
         this.k();
     }
 
     protected void k() {
-        boolean flag = true;
-        boolean flag1 = true;
-        boolean flag2 = true;
-        boolean flag3 = true;
-        int i = 0;
+        int i;
 
         this.b("menu.generatingTerrain");
-        byte b0 = 0;
 
-        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
         for (int m = 0; m < worlds.size(); m++) {
             WorldServer worldserver = this.worlds.get(m);
             LOGGER.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
@@ -360,6 +331,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                     }
 
                     ++i;
+
                     worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
                 }
             }
@@ -368,7 +340,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         for (WorldServer world : this.worlds) {
             this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
         }
-        // CraftBukkit end
+
         this.s();
     }
 
@@ -405,18 +377,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.f = null;
         this.g = 0;
 
-        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
     }
 
-    protected void saveChunks(boolean flag) throws ExceptionWorldConflict { // CraftBukkit - added throws
+    protected void saveChunks(boolean flag) throws ExceptionWorldConflict {
         if (!this.N) {
-            WorldServer[] aworldserver = this.worldServer;
-            int i = aworldserver.length;
-
-            // CraftBukkit start
             for (int j = 0; j < worlds.size(); ++j) {
                 WorldServer worldserver = worlds.get(j);
-                // CraftBukkit end
 
                 if (worldserver != null) {
                     if (!flag) {
@@ -424,8 +391,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                     }
 
                     try {
-                        worldserver.save(true, (IProgressUpdate) null);
-                        worldserver.saveLevel(); // CraftBukkit
+                        worldserver.save(true, null);
+                        worldserver.saveLevel();
                     } catch (ExceptionWorldConflict exceptionworldconflict) {
                         MinecraftServer.LOGGER.warn(exceptionworldconflict.getMessage());
                     }
@@ -435,61 +402,53 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         }
     }
 
-    // CraftBukkit start
     private boolean hasStopped = false;
     private final Object stopLock = new Object();
-    // CraftBukkit end
 
-    public void stop() throws ExceptionWorldConflict { // CraftBukkit - added throws
-        // CraftBukkit start - prevent double stopping on multiple threads
+    public void stop() throws ExceptionWorldConflict {
         synchronized(stopLock) {
-            if (hasStopped) return;
+            if (hasStopped) {
+                return;
+            }
+
             hasStopped = true;
         }
-        // CraftBukkit end
+
         if (!this.N) {
             MinecraftServer.LOGGER.info("Stopping server");
-            SpigotTimings.stopServer(); // Spigot
+            SpigotTimings.stopServer();
 
-            // CraftBukkit start
             if (this.server != null) {
                 this.server.disablePlugins();
             }
-            // CraftBukkit end
+
             if (this.aq() != null) {
                 this.aq().b();
             }
 
-            if (this.v != null) {
+            if (this.playerList != null) {
                 MinecraftServer.LOGGER.info("Saving players");
-                this.v.savePlayers();
-                this.v.u();
-                try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+                this.playerList.savePlayers();
+                this.playerList.u();
+
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ex) {}
             }
 
             if (this.worldServer != null) {
                 MinecraftServer.LOGGER.info("Saving worlds");
                 this.saveChunks(false);
-
-                /* CraftBukkit start - Handled in saveChunks
-                for (int i = 0; i < this.worldServer.length; ++i) {
-                    WorldServer worldserver = this.worldServer[i];
-
-                    worldserver.saveLevel();
-                }
-                // CraftBukkit end */
             }
 
             if (this.n.d()) {
                 this.n.e();
             }
-            // Spigot start
-            if( org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly )
-            {
+
+            if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
                 LOGGER.info("Saving usercache.json");
                 this.Z.c();
             }
-            //Spigot end
         }
     }
 
@@ -497,7 +456,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         return this.serverIp;
     }
 
-    public void c(String s) {
+    public void setServerIp(String s) {
         this.serverIp = s;
     }
 
@@ -509,18 +468,18 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.isRunning = false;
     }
 
-    // PaperSpigot start - Further improve tick loop
-    private static final int TPS = 20;
-    private static final long SEC_IN_NANO = 1000000000;
-    private static final long TICK_TIME = SEC_IN_NANO / TPS;
-    private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
-    private static final int SAMPLE_INTERVAL = 20;
+    public static int TPS = 20;
+    public static final long SEC_IN_NANO = 1000000000;
+    public static long TICK_TIME = SEC_IN_NANO / TPS;
+    public static long NORMAL_TICK_TIME = TPS / 20;
+    public static long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * (TPS * 3);
+    private static final int SAMPLE_INTERVAL = TPS;
     public final RollingAverage tps1 = new RollingAverage(60);
     public final RollingAverage tps5 = new RollingAverage(60 * 5);
     public final RollingAverage tps15 = new RollingAverage(60 * 15);
-    public double[] recentTps = new double[ 3 ]; // PaperSpigot - Fine have your darn compat with bad plugins
 
     public static class RollingAverage {
+
         private final int size;
         private long time;
         private double total;
@@ -534,6 +493,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             this.total = TPS * SEC_IN_NANO * size;
             this.samples = new double[size];
             this.times = new long[size];
+
             for (int i = 0; i < size; i++) {
                 this.samples[i] = TPS;
                 this.times[i] = SEC_IN_NANO;
@@ -547,6 +507,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             times[index] = t;
             time += t;
             total += x * t;
+
             if (++index == size) {
                 index = 0;
             }
@@ -555,80 +516,75 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         public double getAverage() {
             return total / time;
         }
+
     }
-    // PaperSpigot End
- 
+
     public void run() {
         try {
             if (this.init()) {
                 this.ab = az();
-                long i = 0L;
 
                 this.r.setMOTD(new ChatComponentText(this.motd));
                 this.r.setServerInfo(new ServerPing.ServerData("1.8.8", 47));
                 this.a(this.r);
 
-                // Spigot start
-                // PaperSpigot start - Further improve tick loop
-                Arrays.fill( recentTps, 20 );
-                //long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
-                long start = System.nanoTime(), lastTick = start - TICK_TIME, catchupTime = 0, curTime, wait, tickSection = start;
-                // PaperSpigot end
+                final long start = System.nanoTime();
+                long lastTick = start - TICK_TIME, catchupTime = 0, curTime, wait, tickSection = start;
+
                 while (this.isRunning) {
                     curTime = System.nanoTime();
-                    // PaperSpigot start - Further improve tick loop
                     wait = TICK_TIME - (curTime - lastTick);
+
                     if (wait > 0) {
                         if (catchupTime < 2E6) {
                             wait += Math.abs(catchupTime);
                         }
+
                         if (wait < catchupTime) {
                             catchupTime -= wait;
                             wait = 0;
                         } else if (catchupTime > 2E6) {
                             wait -= catchupTime;
-                            catchupTime -= catchupTime;
+                            catchupTime = 0;
                         }
                     }
+
                     if (wait > 0) {
                         Thread.sleep(wait / 1000000);
+                        curTime = System.nanoTime();
                         wait = TICK_TIME - (curTime - lastTick);
                     }
 
                     catchupTime = Math.min(MAX_CATCHUP_BUFFER, catchupTime - wait);
 
-                    if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0 )
-                    {
+                    if ( ++MinecraftServer.currentTick % SAMPLE_INTERVAL == 0) {
                         final long diff = curTime - tickSection;
                         double currentTps = 1E9 / diff * SAMPLE_INTERVAL;
+
                         tps1.add(currentTps, diff);
                         tps5.add(currentTps, diff);
                         tps15.add(currentTps, diff);
-                        // Backwards compat with bad plugins
-                        recentTps[0] = tps1.getAverage();
-                        recentTps[1] = tps5.getAverage();
-                        recentTps[2] = tps15.getAverage();
+
                         tickSection = curTime;
-                        // PaperSpigot end
                     }
+
                     lastTick = curTime;
+	                LAST_TICK_TIME = System.currentTimeMillis();
 
                     this.A();
                     this.Q = true;
                 }
-                // Spigot end
             } else {
                 this.a((CrashReport) null);
             }
         } catch (Throwable throwable) {
             MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
-            // Spigot Start
-            if ( throwable.getCause() != null )
-            {
+
+            if ( throwable.getCause() != null ) {
                 MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
             }
-            // Spigot End
-            CrashReport crashreport = null;
+
+            CrashReport crashreport;
 
             if (throwable instanceof ReportedException) {
                 crashreport = this.b(((ReportedException) throwable).a());
@@ -653,15 +609,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             } catch (Throwable throwable1) {
                 MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
             } finally {
-                // CraftBukkit start - Restore terminal to original settings
                 try {
                     reader.getTerminal().restore();
                 } catch (Exception ignored) {
                 }
-                // CraftBukkit end
+
                 this.z();
             }
-
         }
 
     }
@@ -678,16 +632,16 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
                 Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
                 ImageIO.write(bufferedimage, "PNG", new ByteBufOutputStream(bytebuf));
-                ByteBuf bytebuf1 = Base64.encode(bytebuf);
 
-                serverping.setFavicon("data:image/png;base64," + bytebuf1.toString(Charsets.UTF_8));
+                ByteBuf buffer = Base64.encode(bytebuf);
+
+                serverping.setFavicon("data:image/png;base64," + buffer.toString(Charsets.UTF_8));
             } catch (Exception exception) {
                 MinecraftServer.LOGGER.error("Couldn\'t load server icon", exception);
             } finally {
                 bytebuf.release();
             }
         }
-
     }
 
     public File y() {
@@ -703,6 +657,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         long i = System.nanoTime();
 
         ++this.ticks;
+
         if (this.T) {
             this.T = false;
             this.methodProfiler.a = true;
@@ -710,181 +665,181 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         }
 
         this.methodProfiler.a("root");
-        this.B();
+        this.tickServer();
+
         if (i - this.X >= 5000000000L) {
             this.X = i;
             this.r.setPlayerSample(new ServerPing.ServerPingPlayerSample(this.J(), this.I()));
-            GameProfile[] agameprofile = new GameProfile[Math.min(this.I(), 12)];
-            int j = MathHelper.nextInt(this.s, 0, this.I() - agameprofile.length);
+            GameProfile[] gameProfile = new GameProfile[Math.min(this.I(), 12)];
+            int j = MathHelper.nextInt(this.s, 0, this.I() - gameProfile.length);
 
-            for (int k = 0; k < agameprofile.length; ++k) {
-                agameprofile[k] = ((EntityPlayer) this.v.v().get(j + k)).getProfile();
+            for (int k = 0; k < gameProfile.length; ++k) {
+                gameProfile[k] = (this.playerList.v().get(j + k)).getProfile();
             }
 
-            Collections.shuffle(Arrays.asList(agameprofile));
-            this.r.b().a(agameprofile);
+            Collections.shuffle(Arrays.asList(gameProfile));
+            this.r.b().a(gameProfile);
         }
 
-        if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
-            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
+        if (autoSavePeriod > 0 && this.ticks % autoSavePeriod == 0) {
+            SpigotTimings.worldSaveTimer.startTiming();
             this.methodProfiler.a("save");
-            this.v.savePlayers();
-            // Spigot Start
-            // We replace this with saving each individual world as this.saveChunks(...) is broken,
-            // and causes the main thread to sleep for random amounts of time depending on chunk activity
-            // Also pass flag to only save modified chunks
+            this.playerList.savePlayers();
+
             server.playerCommandState = true;
+
             for (World world : worlds) {
                 world.getWorld().save(false);
             }
+
             server.playerCommandState = false;
-            // this.saveChunks(true);
-            // Spigot End
+
             this.methodProfiler.b();
-            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
+            SpigotTimings.worldSaveTimer.stopTiming();
         }
 
         this.methodProfiler.a("tallying");
         this.h[this.ticks % 100] = System.nanoTime() - i;
         this.methodProfiler.b();
         this.methodProfiler.a("snooper");
-        if (getSnooperEnabled() && !this.n.d() && this.ticks > 100) {  // Spigot
+
+        if (getSnooperEnabled() && !this.n.d() && this.ticks > 100) {
             this.n.a();
         }
 
-        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // Spigot
+        if (getSnooperEnabled() && this.ticks % 6000 == 0) {
             this.n.b();
         }
 
         this.methodProfiler.b();
         this.methodProfiler.b();
-        org.spigotmc.WatchdogThread.tick(); // Spigot
-        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming(); // Spigot
+        org.spigotmc.WatchdogThread.tick();
+        co.aikar.timings.TimingsManager.FULL_SERVER_TICK.stopTiming();
     }
 
-    public void B() {
-        SpigotTimings.minecraftSchedulerTimer.startTiming(); // Spigot
+    public void tickServer() {
+        SpigotTimings.minecraftSchedulerTimer.startTiming();
         this.methodProfiler.a("jobs");
-        Queue queue = this.j;
 
-        // Spigot start
         FutureTask<?> entry;
         int count = this.j.size();
+
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
-        // Spigot end
-        SpigotTimings.minecraftSchedulerTimer.stopTiming(); // Spigot
+        }
+
+        SpigotTimings.minecraftSchedulerTimer.stopTiming();
 
         this.methodProfiler.c("levels");
 
-        SpigotTimings.bukkitSchedulerTimer.startTiming(); // Spigot
-        // CraftBukkit start
+        // Tick main heartbeat
+        SpigotTimings.bukkitSchedulerTimer.startTiming();
         this.server.getScheduler().mainThreadHeartbeat(this.ticks);
-        SpigotTimings.bukkitSchedulerTimer.stopTiming(); // Spigot
+        SpigotTimings.bukkitSchedulerTimer.stopTiming();
+
+        // Tick process queue
+        SpigotTimings.processQueueTimer.startTiming();
 
-        // Run tasks that are waiting on processing
-        SpigotTimings.processQueueTimer.startTiming(); // Spigot
         while (!processQueue.isEmpty()) {
             processQueue.remove().run();
         }
-        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
 
-        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
+        SpigotTimings.processQueueTimer.stopTiming();
+
+        // Tick chunks
+        SpigotTimings.chunkIOTickTimer.startTiming();
         org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
-        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+        SpigotTimings.chunkIOTickTimer.stopTiming();
+
+        SpigotTimings.timeUpdateTimer.startTiming();
 
-        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
         // Send time updates to everyone, it will get the right time from the world the player is in.
-        if (this.ticks % 20 == 0) {
-            for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
-            }
+        for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
+            final EntityPlayer entityplayer = this.getPlayerList().players.get(i);
+
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle")));
         }
-        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+
+        SpigotTimings.timeUpdateTimer.stopTiming();
 
         int i;
 
         for (i = 0; i < this.worlds.size(); ++i) {
-            long j = System.nanoTime();
-
-            // if (i == 0 || this.getAllowNether()) {
-                WorldServer worldserver = this.worlds.get(i);
-
-                this.methodProfiler.a(worldserver.getWorldData().getName());
-                /* Drop global time updates
-                if (this.ticks % 20 == 0) {
-                    this.methodProfiler.a("timeSync");
-                    this.v.a(new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")), worldserver.worldProvider.getDimension());
-                    this.methodProfiler.b();
-                }
-                // CraftBukkit end */
+            WorldServer worldserver = this.worlds.get(i);
 
-                this.methodProfiler.a("tick");
+            this.methodProfiler.a(worldserver.getWorldData().getName());
+            this.methodProfiler.a("tick");
 
-                CrashReport crashreport;
+            CrashReport crashreport;
 
+            try {
+                worldserver.timings.doTick.startTiming();
+                worldserver.doTick(this.ticks);
+                worldserver.timings.doTick.stopTiming();
+            } catch (Throwable throwable) {
                 try {
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick();
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    try {
                     crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                } catch (Throwable t){
+                    throw new RuntimeException("Error generating crash report", t);
                 }
 
-                try {
-                    worldserver.timings.tickEntities.startTiming(); // Spigot
+                worldserver.a(crashreport);
+
+                throw new ReportedException(crashreport);
+            }
+
+            try {
+                if (this.ticks % DedicatedServer.NORMAL_TICK_TIME == 0) {
+                    worldserver.timings.tickEntities.startTiming();
                     worldserver.tickEntities();
-                    worldserver.timings.tickEntities.stopTiming(); // Spigot
-                } catch (Throwable throwable1) {
-                    // Spigot Start
-                    try {
+                    worldserver.timings.tickEntities.stopTiming();
+                }
+            } catch (Throwable throwable1) {
+                try {
                     crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                } catch (Throwable t){
+                    throw new RuntimeException("Error generating crash report", t);
                 }
 
-                this.methodProfiler.b();
-                this.methodProfiler.a("tracker");
-                worldserver.timings.tracker.startTiming(); // Spigot
-                worldserver.getTracker().updatePlayers();
-                worldserver.timings.tracker.stopTiming(); // Spigot
-                this.methodProfiler.b();
-                this.methodProfiler.b();
-                worldserver.explosionDensityCache.clear(); // PaperSpigot - Optimize explosions
-            // } // CraftBukkit
-
-            // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
+                worldserver.a(crashreport);
+
+                throw new ReportedException(crashreport);
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("tracker");
+
+            // Tick trackers
+            worldserver.timings.tracker.startTiming();
+            worldserver.getTracker().updatePlayers();
+            worldserver.timings.tracker.stopTiming();
+
+            this.methodProfiler.b();
+            this.methodProfiler.b();
+            worldserver.explosionDensityCache.clear();
         }
 
+        // Tick connections
         this.methodProfiler.c("connection");
         SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.aq().c();
         SpigotTimings.connectionTimer.stopTiming(); // Spigot
+
+        // Tick players
         this.methodProfiler.c("players");
         SpigotTimings.playerListTimer.startTiming(); // Spigot
-        this.v.tick();
+        this.playerList.tick();
         SpigotTimings.playerListTimer.stopTiming(); // Spigot
+
+        // Tick tickables
         this.methodProfiler.c("tickables");
+        SpigotTimings.tickablesTimer.startTiming();
 
-        SpigotTimings.tickablesTimer.startTiming(); // Spigot
         for (i = 0; i < this.p.size(); ++i) {
-            ((IUpdatePlayerListBox) this.p.get(i)).c();
+            this.p.get(i).c();
         }
-        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
+
+        SpigotTimings.tickablesTimer.stopTiming();
 
         this.methodProfiler.b();
     }
@@ -897,94 +852,15 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.p.add(iupdateplayerlistbox);
     }
 
-    public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
+    public static void main(final OptionSet options) {
         DispenserRegistry.c();
 
         try {
-            /* CraftBukkit start - Replace everything
-            boolean flag = true;
-            String s = null;
-            String s1 = ".";
-            String s2 = null;
-            boolean flag1 = false;
-            boolean flag2 = false;
-            int i = -1;
-
-            for (int j = 0; j < astring.length; ++j) {
-                String s3 = astring[j];
-                String s4 = j == astring.length - 1 ? null : astring[j + 1];
-                boolean flag3 = false;
-
-                if (!s3.equals("nogui") && !s3.equals("--nogui")) {
-                    if (s3.equals("--port") && s4 != null) {
-                        flag3 = true;
-
-                        try {
-                            i = Integer.parseInt(s4);
-                        } catch (NumberFormatException numberformatexception) {
-                            ;
-                        }
-                    } else if (s3.equals("--singleplayer") && s4 != null) {
-                        flag3 = true;
-                        s = s4;
-                    } else if (s3.equals("--universe") && s4 != null) {
-                        flag3 = true;
-                        s1 = s4;
-                    } else if (s3.equals("--world") && s4 != null) {
-                        flag3 = true;
-                        s2 = s4;
-                    } else if (s3.equals("--demo")) {
-                        flag1 = true;
-                    } else if (s3.equals("--bonusChest")) {
-                        flag2 = true;
-                    }
-                } else {
-                    flag = false;
-                }
-
-                if (flag3) {
-                    ++j;
-                }
-            }
-
-            final DedicatedServer dedicatedserver = new DedicatedServer(new File(s1));
-
-            if (s != null) {
-                dedicatedserver.i(s);
-            }
-
-            if (s2 != null) {
-                dedicatedserver.setWorld(s2);
-            }
-
-            if (i >= 0) {
-                dedicatedserver.setPort(i);
-            }
-
-            if (flag1) {
-                dedicatedserver.b(true);
-            }
-
-            if (flag2) {
-                dedicatedserver.c(true);
-            }
-
-            if (flag && !GraphicsEnvironment.isHeadless()) {
-                dedicatedserver.aQ();
-            }
-
-            dedicatedserver.D();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
-                public void run() {
-                    dedicatedserver.stop();
-                }
-            });
-            */
-
             DedicatedServer dedicatedserver = new DedicatedServer(options);
 
             if (options.has("port")) {
                 int port = (Integer) options.valueOf("port");
+
                 if (port > 0) {
                     dedicatedserver.setPort(port);
                 }
@@ -999,19 +875,12 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
             }
 
             dedicatedserver.primaryThread.start();
-            // CraftBukkit end
         } catch (Exception exception) {
             MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
         }
-
     }
 
-    public void C() {
-        /* CraftBukkit start - prevent abuse
-        this.serverThread = new Thread(this, "Server thread");
-        this.serverThread.start();
-        // CraftBukkit end */
-    }
+    public void C() {}
 
     public File d(String s) {
         return new File(this.y(), s);
@@ -1026,14 +895,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public WorldServer getWorldServer(int i) {
-        // CraftBukkit start
         for (WorldServer world : worlds) {
             if (world.dimension == i) {
                 return world;
             }
         }
+
         return worlds.get(0);
-        // CraftBukkit end
     }
 
     public String E() {
@@ -1053,23 +921,23 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public int I() {
-        return this.v.getPlayerCount();
+        return this.playerList.getPlayerCount();
     }
 
     public int J() {
-        return this.v.getMaxPlayers();
+        return this.playerList.getMaxPlayers();
     }
 
     public String[] getPlayers() {
-        return this.v.f();
+        return this.playerList.f();
     }
 
     public GameProfile[] L() {
-        return this.v.g();
+        return this.playerList.g();
     }
 
     public boolean isDebugging() {
-        return this.getPropertyManager().getBoolean("debug", false); // CraftBukkit - don't hardcode
+        return this.getPropertyManager().getBoolean("debug", false);
     }
 
     public void g(String s) {
@@ -1084,7 +952,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public String getServerModName() {
-        return "PaperSpigot"; // PaperSpigot - PaperSpigot > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Spigot";
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1097,10 +965,10 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
                 return this.a();
             }
         });
-        if (this.v != null) {
+        if (this.playerList != null) {
             crashreport.g().a("Player Count", new Callable() {
                 public String a() {
-                    return MinecraftServer.this.v.getPlayerCount() + " / " + MinecraftServer.this.v.getMaxPlayers() + "; " + MinecraftServer.this.v.v();
+                    return MinecraftServer.this.playerList.getPlayerCount() + " / " + MinecraftServer.this.playerList.getMaxPlayers() + "; " + MinecraftServer.this.playerList.v();
                 }
 
                 public Object call() throws Exception {
@@ -1113,48 +981,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public List<String> tabCompleteCommand(ICommandListener icommandlistener, String s, BlockPosition blockposition) {
-        /* CraftBukkit start - Allow tab-completion of Bukkit commands
-        ArrayList arraylist = Lists.newArrayList();
-
-        if (s.startsWith("/")) {
-            s = s.substring(1);
-            boolean flag = !s.contains(" ");
-            List list = this.b.a(icommandlistener, s, blockposition);
-
-            if (list != null) {
-                Iterator iterator = list.iterator();
-
-                while (iterator.hasNext()) {
-                    String s1 = (String) iterator.next();
-
-                    if (flag) {
-                        arraylist.add("/" + s1);
-                    } else {
-                        arraylist.add(s1);
-                    }
-                }
-            }
-
-            return arraylist;
-        } else {
-            String[] astring = s.split(" ", -1);
-            String s2 = astring[astring.length - 1];
-            String[] astring1 = this.v.f();
-            int i = astring1.length;
-
-            for (int j = 0; j < i; ++j) {
-                String s3 = astring1[j];
-
-                if (CommandAbstract.a(s2, s3)) {
-                    arraylist.add(s3);
-                }
-            }
-
-            return arraylist;
-        }
-        */
-        return server.tabComplete(icommandlistener, s, blockposition); // PaperSpigot - add Location argument
-        // CraftBukkit end
+        return server.tabComplete(icommandlistener, s, blockposition);
     }
 
     public static MinecraftServer getServer() {
@@ -1162,7 +989,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public boolean O() {
-        return true; // CraftBukkit
+        return true;
     }
 
     public String getName() {
@@ -1185,7 +1012,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         return this.H;
     }
 
-    public int R() {
+    public int getPort() {
         return this.u;
     }
 
@@ -1206,11 +1033,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public String U() {
-        return this.J;
+        return this.worldName;
     }
 
-    public void setWorld(String s) {
-        this.J = s;
+    public void setWorld(String worldName) {
+        this.worldName = worldName;
     }
 
     public void a(KeyPair keypair) {
@@ -1218,10 +1045,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public void a(EnumDifficulty enumdifficulty) {
-        // CraftBukkit start
         for (int i = 0; i < this.worlds.size(); ++i) {
             WorldServer worldserver = this.worlds.get(i);
-            // CraftBukkit end
 
             if (worldserver != null) {
                 if (worldserver.getWorldData().isHardcore()) {
@@ -1251,29 +1076,24 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         this.demoMode = flag;
     }
 
-    public void c(boolean flag) {
-        this.M = flag;
-    }
-
     public Convertable getConvertable() {
         return this.convertable;
     }
 
     public void aa() {
         this.N = true;
+
         this.getConvertable().d();
 
-        // CraftBukkit start
         for (int i = 0; i < this.worlds.size(); ++i) {
             WorldServer worldserver = this.worlds.get(i);
-            // CraftBukkit end
-            
+
             if (worldserver != null) {
                 worldserver.saveLevel();
             }
         }
 
-        this.getConvertable().e(this.worlds.get(0).getDataManager().g()); // CraftBukkit
+        this.getConvertable().e(this.worlds.get(0).getDataManager().g());
         this.safeShutdown();
     }
 
@@ -1291,49 +1111,51 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(false));
-        mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(0));
-        if (this.v != null) {
-            mojangstatisticsgenerator.a("players_current", Integer.valueOf(this.I()));
-            mojangstatisticsgenerator.a("players_max", Integer.valueOf(this.J()));
-            mojangstatisticsgenerator.a("players_seen", Integer.valueOf(this.v.getSeenPlayers().length));
+        mojangstatisticsgenerator.a("whitelist_enabled", false);
+        mojangstatisticsgenerator.a("whitelist_count", 0);
+
+        if (this.playerList != null) {
+            mojangstatisticsgenerator.a("players_current", this.I());
+            mojangstatisticsgenerator.a("players_max", this.J());
+            mojangstatisticsgenerator.a("players_seen", this.playerList.getSeenPlayers().length);
         }
 
-        mojangstatisticsgenerator.a("uses_auth", Boolean.valueOf(this.onlineMode));
+        mojangstatisticsgenerator.a("uses_auth", this.onlineMode);
         mojangstatisticsgenerator.a("gui_state", this.as() ? "enabled" : "disabled");
-        mojangstatisticsgenerator.a("run_time", Long.valueOf((az() - mojangstatisticsgenerator.g()) / 60L * 1000L));
-        mojangstatisticsgenerator.a("avg_tick_ms", Integer.valueOf((int) (MathHelper.a(this.h) * 1.0E-6D)));
+        mojangstatisticsgenerator.a("run_time", (az() - mojangstatisticsgenerator.g()) / 60L * 1000L);
+        mojangstatisticsgenerator.a("avg_tick_ms", (int) (MathHelper.a(this.h) * 1.0E-6D));
+
         int i = 0;
 
         if (this.worldServer != null) {
-            // CraftBukkit start
             for (int j = 0; j < this.worlds.size(); ++j) {
                 WorldServer worldserver = this.worlds.get(j);
+
                 if (worldserver != null) {
-                    // CraftBukkit end
                     WorldData worlddata = worldserver.getWorldData();
 
-                    mojangstatisticsgenerator.a("world[" + i + "][dimension]", Integer.valueOf(worldserver.worldProvider.getDimension()));
+                    mojangstatisticsgenerator.a("world[" + i + "][dimension]", worldserver.worldProvider.getDimension());
                     mojangstatisticsgenerator.a("world[" + i + "][mode]", worlddata.getGameType());
                     mojangstatisticsgenerator.a("world[" + i + "][difficulty]", worldserver.getDifficulty());
-                    mojangstatisticsgenerator.a("world[" + i + "][hardcore]", Boolean.valueOf(worlddata.isHardcore()));
+                    mojangstatisticsgenerator.a("world[" + i + "][hardcore]", worlddata.isHardcore());
                     mojangstatisticsgenerator.a("world[" + i + "][generator_name]", worlddata.getType().name());
-                    mojangstatisticsgenerator.a("world[" + i + "][generator_version]", Integer.valueOf(worlddata.getType().getVersion()));
-                    mojangstatisticsgenerator.a("world[" + i + "][height]", Integer.valueOf(this.F));
-                    mojangstatisticsgenerator.a("world[" + i + "][chunks_loaded]", Integer.valueOf(worldserver.N().getLoadedChunks()));
+                    mojangstatisticsgenerator.a("world[" + i + "][generator_version]", worlddata.getType().getVersion());
+                    mojangstatisticsgenerator.a("world[" + i + "][height]", this.maxBuildHeight);
+                    mojangstatisticsgenerator.a("world[" + i + "][chunks_loaded]", worldserver.N().getLoadedChunks());
+
                     ++i;
                 }
             }
         }
 
-        mojangstatisticsgenerator.a("worlds", Integer.valueOf(i));
+        mojangstatisticsgenerator.a("worlds", i);
     }
 
     public void b(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.b("singleplayer", Boolean.valueOf(this.T()));
+        mojangstatisticsgenerator.b("singleplayer", this.T());
         mojangstatisticsgenerator.b("server_brand", this.getServerModName());
         mojangstatisticsgenerator.b("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
-        mojangstatisticsgenerator.b("dedicated", Boolean.valueOf(this.ae()));
+        mojangstatisticsgenerator.b("dedicated", this.ae());
     }
 
     public boolean getSnooperEnabled() {
@@ -1343,7 +1165,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     public abstract boolean ae();
 
     public boolean getOnlineMode() {
-        return server.getOnlineMode(); // CraftBukkit
+        return server.getOnlineMode();
     }
 
     public void setOnlineMode(boolean flag) {
@@ -1395,11 +1217,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public int getMaxBuildHeight() {
-        return this.F;
+        return this.maxBuildHeight;
     }
 
-    public void c(int i) {
-        this.F = i;
+    public void setMaxBuildHeight(int i) {
+        this.maxBuildHeight = i;
     }
 
     public boolean isStopped() {
@@ -1407,11 +1229,11 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public PlayerList getPlayerList() {
-        return this.v;
+        return this.playerList;
     }
 
     public void a(PlayerList playerlist) {
-        this.v = playerlist;
+        this.playerList = playerlist;
     }
 
     public void setGamemode(WorldSettings.EnumGamemode worldsettings_enumgamemode) {
@@ -1422,14 +1244,12 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
     }
 
-    // Spigot Start
-    public ServerConnection getServerConnection()
-    {
-        return this.q;
+    public ServerConnection getServerConnection() {
+        return this.serverConnection;
     }
-    // Spigot End
+
     public ServerConnection aq() {
-        return this.q == null ? this.q = new ServerConnection(this) : this.q; // Spigot
+        return this.serverConnection == null ? this.serverConnection = new ServerConnection(this) : this.serverConnection; // Spigot
     }
 
     public boolean as() {
@@ -1455,7 +1275,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public World getWorld() {
-        return this.worlds.get(0); // CraftBukkit
+        return this.worlds.get(0);
     }
 
     public Entity f() {
@@ -1523,13 +1343,8 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
     }
 
     public Entity a(UUID uuid) {
-        WorldServer[] aworldserver = this.worldServer;
-        int i = aworldserver.length;
-
-        // CraftBukkit start
         for (int j = 0; j < worlds.size(); ++j) {
             WorldServer worldserver = worlds.get(j);
-            // CraftBukkit end
 
             if (worldserver != null) {
                 Entity entity = worldserver.getEntity(uuid);
@@ -1547,7 +1362,7 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
         return getServer().worlds.get(0).getGameRules().getBoolean("sendCommandFeedback");
     }
 
-    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {}
+    public void a(CommandObjectiveExecutor.EnumCommandResult result, int i) {}
 
     public int aI() {
         return 29999984;
@@ -1555,14 +1370,13 @@ public abstract class MinecraftServer implements Runnable, ICommandListener, IAs
 
     public <V> ListenableFuture<V> a(Callable<V> callable) {
         Validate.notNull(callable);
-        if (!this.isMainThread()) { // CraftBukkit && !this.isStopped()) {
-            ListenableFutureTask listenablefuturetask = ListenableFutureTask.create(callable);
-            Queue queue = this.j;
-
-            // Spigot start
-            this.j.add(listenablefuturetask);
-            return listenablefuturetask;
-            // Spigot end
+
+        if (!this.isMainThread()) {
+            ListenableFutureTask task = ListenableFutureTask.create(callable);
+
+            this.j.add(task);
+
+            return task;
         } else {
             try {
                 return Futures.immediateFuture(callable.call());
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 9d23c6c0..1f2c7bfa 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.handler.PacketHandler;
 import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.netty.channel.Channel;
@@ -33,35 +35,28 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     public static final Marker a = MarkerManager.getMarker("NETWORK");
     public static final Marker b = MarkerManager.getMarker("NETWORK_PACKETS", NetworkManager.a);
     public static final AttributeKey<EnumProtocol> c = AttributeKey.valueOf("protocol");
-    public static final LazyInitVar<NioEventLoopGroup> d = new LazyInitVar() {
-        protected NioEventLoopGroup a() {
-            return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Client IO #%d").setDaemon(true).build());
-        }
 
-        protected Object init() {
-            return this.a();
+    public static final LazyInitVar<NioEventLoopGroup> d = new LazyInitVar<NioEventLoopGroup>() {
+        @Override
+        protected NioEventLoopGroup init() {
+            return new NioEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Client IO #%d").setDaemon(true).build());
         }
     };
-    public static final LazyInitVar<EpollEventLoopGroup> e = new LazyInitVar() {
-        protected EpollEventLoopGroup a() {
+    public static final LazyInitVar<EpollEventLoopGroup> e = new LazyInitVar<EpollEventLoopGroup>() {
+        @Override
+        protected EpollEventLoopGroup init() {
             return new EpollEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Epoll Client IO #%d").setDaemon(true).build());
         }
-
-        protected Object init() {
-            return this.a();
-        }
     };
-    public static final LazyInitVar<LocalEventLoopGroup> f = new LazyInitVar() {
-        protected LocalEventLoopGroup a() {
+    public static final LazyInitVar<LocalEventLoopGroup> f = new LazyInitVar<LocalEventLoopGroup>() {
+        @Override
+        protected LocalEventLoopGroup init() {
             return new LocalEventLoopGroup(0, (new ThreadFactoryBuilder()).setNameFormat("Netty Local Client IO #%d").setDaemon(true).build());
         }
-
-        protected Object init() {
-            return this.a();
-        }
     };
+
     private final EnumProtocolDirection h;
-    private final Queue<NetworkManager.QueuedPacket> i = Queues.newConcurrentLinkedQueue();
+    private final Queue<NetworkManager.QueuedPacket> packetQueue = Queues.newConcurrentLinkedQueue();
     private final ReentrantReadWriteLock j = new ReentrantReadWriteLock();
     public Channel channel;
     // Spigot Start // PAIL
@@ -75,6 +70,12 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     private boolean o;
     private boolean p;
 
+    private boolean openedBook;
+
+    public static Channel getChannel(final NetworkManager nm) {
+        return nm.channel;
+    }
+
     public NetworkManager(EnumProtocolDirection enumprotocoldirection) {
         this.h = enumprotocoldirection;
     }
@@ -120,30 +121,64 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
     protected void a(ChannelHandlerContext channelhandlercontext, Packet packet) throws Exception {
         if (this.channel.isOpen()) {
+	        if (packet instanceof PacketPlayInCustomPayload) {
+	            PacketPlayInCustomPayload payload = (PacketPlayInCustomPayload) packet;
+	            String name = payload.a();
+
+                if (name.equalsIgnoreCase("MC|BSign") || name.equalsIgnoreCase("MC|BEdit")) {
+                    if (this.m instanceof PlayerConnection) {
+                        byte[] data = payload.b().array();
+
+                        if(data.length > 15000){
+                            this.close(new ChatMessage("Invalid book packet"));
+                            return;
+                        }
+                        if (!this.openedBook) {
+                            this.close(new ChatMessage("Invalid book packet"));
+                            return;
+                        }
+                        this.openedBook = false;
+                    }
+                }
+            } else if (packet instanceof PacketPlayInBlockPlace) {
+	            ItemStack stack = ((PacketPlayInBlockPlace) packet).getItemStack();
+	            if (stack != null && stack.getItem() != null && stack.getItem().getName().equalsIgnoreCase("item.writingBook")) {
+	                this.openedBook = true;
+                }
+	        }
             try {
                 packet.a(this.m);
             } catch (CancelledPacketHandleException cancelledpackethandleexception) {
                 ;
             }
+            if (this.m instanceof PlayerConnection) {
+                try {
+                    for (PacketHandler handler : PotionSpigot.INSTANCE.getPacketHandlers()) {
+                        handler.handleReceivedPacket((PlayerConnection) this.m, packet);
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
         }
 
     }
 
     public void a(PacketListener packetlistener) {
-        Validate.notNull(packetlistener, "packetListener", new Object[0]);
-        NetworkManager.g.debug("Set listener of {} to {}", new Object[] { this, packetlistener});
+        Validate.notNull(packetlistener, "packetListener");
+        NetworkManager.g.debug("Set listener of {} to {}", this, packetlistener);
         this.m = packetlistener;
     }
 
     public void handle(Packet packet) {
         if (this.g()) {
             this.m();
-            this.a(packet, (GenericFutureListener[]) null);
+            this.a(packet, null);
         } else {
             this.j.writeLock().lock();
 
             try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) null));
+                this.packetQueue.add(new NetworkManager.QueuedPacket(packet));
             } finally {
                 this.j.writeLock().unlock();
             }
@@ -159,7 +194,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             this.j.writeLock().lock();
 
             try {
-                this.i.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener)));
+                this.packetQueue.add(new NetworkManager.QueuedPacket(packet, (GenericFutureListener[]) ArrayUtils.add(agenericfuturelistener, 0, genericfuturelistener)));
             } finally {
                 this.j.writeLock().unlock();
             }
@@ -167,38 +202,38 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
     }
 
-    private void a(final Packet packet, final GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
-        final EnumProtocol enumprotocol = EnumProtocol.a(packet);
-        final EnumProtocol enumprotocol1 = (EnumProtocol) this.channel.attr(NetworkManager.c).get();
+    private void a(Packet packet, GenericFutureListener<? extends Future<? super Void>>[] listeners) {
+        final EnumProtocol packetProtocol = EnumProtocol.a(packet);
+        final EnumProtocol channelProtocol = this.channel.attr(NetworkManager.c).get();
 
-        if (enumprotocol1 != enumprotocol) {
+        if (channelProtocol != packetProtocol) {
             NetworkManager.g.debug("Disabled auto read");
             this.channel.config().setAutoRead(false);
         }
 
         if (this.channel.eventLoop().inEventLoop()) {
-            if (enumprotocol != enumprotocol1) {
-                this.a(enumprotocol);
+            if (packetProtocol != channelProtocol) {
+                this.a(packetProtocol);
             }
 
-            ChannelFuture channelfuture = this.channel.writeAndFlush(packet);
+            ChannelFuture channelfuture = NetworkManager.this.channel.writeAndFlush(packet);
 
-            if (agenericfuturelistener != null) {
-                channelfuture.addListeners(agenericfuturelistener);
+            if (listeners != null) {
+                channelfuture.addListeners(listeners);
             }
 
             channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
         } else {
             this.channel.eventLoop().execute(new Runnable() {
                 public void run() {
-                    if (enumprotocol != enumprotocol1) {
-                        NetworkManager.this.a(enumprotocol);
+                    if (packetProtocol != channelProtocol) {
+                        NetworkManager.this.a(packetProtocol);
                     }
 
                     ChannelFuture channelfuture = NetworkManager.this.channel.writeAndFlush(packet);
 
-                    if (agenericfuturelistener != null) {
-                        channelfuture.addListeners(agenericfuturelistener);
+                    if (listeners != null) {
+                        channelfuture.addListeners(listeners);
                     }
 
                     channelfuture.addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
@@ -213,10 +248,10 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
             this.j.readLock().lock();
 
             try {
-                while (!this.i.isEmpty()) {
-                    NetworkManager.QueuedPacket networkmanager_queuedpacket = (NetworkManager.QueuedPacket) this.i.poll();
+                while (!this.packetQueue.isEmpty()) {
+                    NetworkManager.QueuedPacket queuedPacket = this.packetQueue.poll();
 
-                    this.a(networkmanager_queuedpacket.a, networkmanager_queuedpacket.b);
+                    this.a(queuedPacket.a, queuedPacket.b);
                 }
             } finally {
                 this.j.readLock().unlock();
@@ -227,6 +262,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
 
     public void a() {
         this.m();
+
         if (this.m instanceof IUpdatePlayerListBox) {
             ((IUpdatePlayerListBox) this.m).c();
         }
@@ -239,11 +275,10 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
 
     public void close(IChatBaseComponent ichatbasecomponent) {
-        // Spigot Start
         this.preparing = false;
-        // Spigot End
+
         if (this.channel.isOpen()) {
-            this.channel.close(); // We can't wait as this may be called from an event loop.
+            this.channel.close();
             this.n = ichatbasecomponent;
         }
 
@@ -313,7 +348,7 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
                 } else if (this.getPacketListener() != null) {
                     this.getPacketListener().a(new ChatComponentText("Disconnected"));
                 }
-                this.i.clear(); // Free up packet queue.
+                this.packetQueue.clear(); // Free up packet queue.
             } else {
                 NetworkManager.g.warn("handleDisconnection() called twice");
             }
@@ -321,8 +356,12 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         }
     }
 
-    protected void channelRead0(ChannelHandlerContext channelhandlercontext, Packet object) throws Exception { // CraftBukkit - fix decompile error
-        this.a(channelhandlercontext, (Packet) object);
+    public EnumProtocol getProtocol() {
+        return this.channel.attr(NetworkManager.c).get();
+    }
+
+    protected void channelRead0(ChannelHandlerContext channelhandlercontext, Packet object) throws Exception {
+        this.a(channelhandlercontext, object);
     }
 
     static class QueuedPacket {
@@ -336,10 +375,8 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
         }
     }
 
-    // Spigot Start
-    public SocketAddress getRawAddress()
-    {
+    public SocketAddress getRawAddress() {
         return this.channel.remoteAddress();
     }
-    // Spigot End
+
 }
diff --git a/src/main/java/net/minecraft/server/PacketDataSerializer.java b/src/main/java/net/minecraft/server/PacketDataSerializer.java
index e2eb3054..7af8afc1 100644
--- a/src/main/java/net/minecraft/server/PacketDataSerializer.java
+++ b/src/main/java/net/minecraft/server/PacketDataSerializer.java
@@ -48,7 +48,7 @@ public class PacketDataSerializer extends ByteBuf {
 
     // Paper start
     public byte[] a() {
-        return readByteArray(Short.MAX_VALUE);
+        return readByteArray(Short.MAX_VALUE * 1024);
     }
 
     public byte[]readByteArray(int limit) {
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
index a0021fb9..84eef109 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -19,7 +20,6 @@ public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
         this.b = chunk.locZ;
         this.d = flag;
         this.c = chunk.getChunkMap(flag, i); // PaperSpigot
-        chunk.world.spigotConfig.antiXrayInstance.obfuscateSync(chunk.locX, chunk.locZ, c.b, c.a, chunk.world);
     }
 
     public void a(PacketDataSerializer packetdataserializer) throws IOException {
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
index 00c05385..3d7a48fd 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutMapChunkBulk.java
@@ -70,7 +70,6 @@ public class PacketPlayOutMapChunkBulk implements Packet<PacketListenerPlayOut>
         }
 
         for (i = 0; i < this.a.length; ++i) {
-            world.spigotConfig.antiXrayInstance.obfuscate(this.a[i], this.b[i], this.c[i].b, this.c[i].a, world); // Spigot
             packetdataserializer.writeBytes(this.c[i].a);
         }
 
diff --git a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
index b03ba857..1a9adee9 100644
--- a/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
+++ b/src/main/java/net/minecraft/server/PathfinderGoalSelector.java
@@ -1,13 +1,16 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import org.potionspigot.PotionSpigot;
+
 import java.util.Iterator;
 import java.util.List;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 import org.bukkit.craftbukkit.util.UnsafeList; // CraftBukkit
 
+
 public class PathfinderGoalSelector {
 
     private static final Logger a = LogManager.getLogger();
@@ -22,6 +25,10 @@ public class PathfinderGoalSelector {
     }
 
     public void a(int i, PathfinderGoal pathfindergoal) {
+        if (!PotionSpigot.INSTANCE.getConfig().isMobAIEnabled() && !(pathfindergoal instanceof PathfinderGoalBreed)) {
+            return;
+        }
+
         this.b.add(new PathfinderGoalSelector.PathfinderGoalSelectorItem(i, pathfindergoal));
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index 4391ad7e..9ff74380 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -1,29 +1,35 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.handler.MovementHandler;
+import org.potionspigot.handler.PacketHandler;
+import org.potionspigot.util.NotchUtil;
+
+import co.aikar.timings.SpigotTimings;
+
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Floats;
-import com.google.common.util.concurrent.Futures;
+
 import io.netty.buffer.Unpooled;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Callable;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.HashSet;
 
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftInventoryView;
@@ -31,8 +37,6 @@ import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.LazyPlayerSet;
 import org.bukkit.craftbukkit.util.Waitable;
-
-import org.bukkit.Location;
 import org.bukkit.entity.Player;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
@@ -47,8 +51,8 @@ import org.bukkit.event.player.AsyncPlayerChatEvent;
 import org.bukkit.event.player.PlayerAnimationEvent;
 import org.bukkit.event.player.PlayerChatEvent;
 import org.bukkit.event.player.PlayerCommandPreprocessEvent;
-import org.bukkit.event.player.PlayerInteractEntityEvent;
 import org.bukkit.event.player.PlayerInteractAtEntityEvent;
+import org.bukkit.event.player.PlayerInteractEntityEvent;
 import org.bukkit.event.player.PlayerItemHeldEvent;
 import org.bukkit.event.player.PlayerKickEvent;
 import org.bukkit.event.player.PlayerMoveEvent;
@@ -60,2221 +64,2197 @@ import org.bukkit.event.player.PlayerToggleSprintEvent;
 import org.bukkit.inventory.CraftingInventory;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.util.NumberConversions;
-import co.aikar.timings.SpigotTimings; // Spigot
-// CraftBukkit end
-
-import org.github.paperspigot.PaperSpigotConfig; // PaperSpigot
+import org.github.paperspigot.PaperSpigotConfig;
 
 public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerListBox {
 
-    private static final Logger c = LogManager.getLogger();
-    public final NetworkManager networkManager;
-    private final MinecraftServer minecraftServer;
-    public EntityPlayer player;
-    private int e;
-    private int f;
-    private int g;
-    private boolean h;
-    private int i;
-    private long j;
-    private long k;
-    // CraftBukkit start - multithreaded fields
-    private volatile int chatThrottle;
-    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
-    // CraftBukkit end
-    private int m;
-    private IntHashMap<Short> n = new IntHashMap();
-    private double o;
-    private double p;
-    private double q;
-    private boolean checkMovement = true;
-    private boolean processedDisconnect; // CraftBukkit - added
-
-    public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
-        this.minecraftServer = minecraftserver;
-        this.networkManager = networkmanager;
-        networkmanager.a((PacketListener) this);
-        this.player = entityplayer;
-        entityplayer.playerConnection = this;
-
-        // CraftBukkit start - add fields and methods
-        this.server = minecraftserver.server;
-    }
-
-    private final org.bukkit.craftbukkit.CraftServer server;
-    private int lastTick = MinecraftServer.currentTick;
-    private int lastDropTick = MinecraftServer.currentTick;
-    private int dropCount = 0;
-    private static final int SURVIVAL_PLACE_DISTANCE_SQUARED = 6 * 6;
-    private static final int CREATIVE_PLACE_DISTANCE_SQUARED = 7 * 7;
-
-    // Get position of last block hit for BlockDamageLevel.STOPPED
-    private double lastPosX = Double.MAX_VALUE;
-    private double lastPosY = Double.MAX_VALUE;
-    private double lastPosZ = Double.MAX_VALUE;
-    private float lastPitch = Float.MAX_VALUE;
-    private float lastYaw = Float.MAX_VALUE;
-    private boolean justTeleported = false;
-    private boolean hasMoved; // Spigot
-
-    public CraftPlayer getPlayer() {
-        return (this.player == null) ? null : (CraftPlayer) this.player.getBukkitEntity();
-    }
-    private final static HashSet<Integer> invalidItems = new HashSet<Integer>(java.util.Arrays.asList(8, 9, 10, 11, 26, 34, 36, 43, 51, 52, 55, 59, 60, 62, 63, 64, 68, 71, 74, 75, 83, 90, 92, 93, 94, 104, 105, 115, 117, 118, 119, 125, 127, 132, 140, 141, 142, 144)); // TODO: Check after every update.
-    // CraftBukkit end
-
-    public void c() {
-        this.h = false;
-        ++this.e;
-        this.minecraftServer.methodProfiler.a("keepAlive");
-        if ((long) this.e - this.k > 40L) {
-            this.k = (long) this.e;
-            this.j = this.d();
-            this.i = (int) this.j;
-            this.sendPacket(new PacketPlayOutKeepAlive(this.i));
-        }
-
-        this.minecraftServer.methodProfiler.b();
-        // CraftBukkit start
-        for (int spam; (spam = this.chatThrottle) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
-        /* Use thread-safe field access instead
-        if (this.chatThrottle > 0) {
-            --this.chatThrottle;
-        }
-        */
-        // CraftBukkit end
-
-        if (this.m > 0) {
-            --this.m;
-        }
-
-        if (this.player.D() > 0L && this.minecraftServer.getIdleTimeout() > 0 && MinecraftServer.az() - this.player.D() > (long) (this.minecraftServer.getIdleTimeout() * 1000 * 60)) {
-            this.player.resetIdleTimer(); // CraftBukkit - SPIGOT-854
-            this.disconnect("You have been idle for too long!");
-        }
-
-    }
-
-    public NetworkManager a() {
-        return this.networkManager;
-    }
-
-    public void disconnect(String s) {
-        // CraftBukkit start - fire PlayerKickEvent
-        String leaveMessage = EnumChatFormat.YELLOW + this.player.getName() + " left the game.";
-
-        PlayerKickEvent event = new PlayerKickEvent(this.server.getPlayer(this.player), s, leaveMessage);
-
-        if (this.server.getServer().isRunning()) {
-            this.server.getPluginManager().callEvent(event);
-        }
-
-        if (event.isCancelled()) {
-            // Do not kick the player
-            return;
-        }
-        // Send the possibly modified leave message
-        s = event.getReason();
-        // CraftBukkit end
-        final ChatComponentText chatcomponenttext = new ChatComponentText(s);
-
-        this.networkManager.a(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener() {
-            public void operationComplete(Future future) throws Exception { // CraftBukkit - fix decompile error
-                PlayerConnection.this.networkManager.close(chatcomponenttext);
-            }
-        }, new GenericFutureListener[0]);
-        this.a(chatcomponenttext); // CraftBukkit - fire quit instantly
-        this.networkManager.k();
-        // CraftBukkit - Don't wait
-        this.minecraftServer.postToMainThread(new Runnable() {
-             public void run() {
-                 PlayerConnection.this.networkManager.l();
-            }
-        });
-    }
-
-    public void a(PacketPlayInSteerVehicle packetplayinsteervehicle) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinsteervehicle, this, this.player.u());
-        this.player.a(packetplayinsteervehicle.a(), packetplayinsteervehicle.b(), packetplayinsteervehicle.c(), packetplayinsteervehicle.d());
-    }
-
-    private boolean b(PacketPlayInFlying packetplayinflying) {
-        return !Doubles.isFinite(packetplayinflying.a()) || !Doubles.isFinite(packetplayinflying.b()) || !Doubles.isFinite(packetplayinflying.c()) || !Floats.isFinite(packetplayinflying.e()) || !Floats.isFinite(packetplayinflying.d());
-    }
-
-    public void a(PacketPlayInFlying packetplayinflying) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinflying, this, this.player.u());
-        if (this.b(packetplayinflying)) {
-            this.disconnect("Invalid move packet received");
-        } else {
-            WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
-
-            this.h = true;
-            if (!this.player.viewingCredits) {
-                double d0 = this.player.locX;
-                double d1 = this.player.locY;
-                double d2 = this.player.locZ;
-                double d3 = 0.0D;
-                double d4 = packetplayinflying.a() - this.o;
-                double d5 = packetplayinflying.b() - this.p;
-                double d6 = packetplayinflying.c() - this.q;
-
-                if (packetplayinflying.g()) {
-                    d3 = d4 * d4 + d5 * d5 + d6 * d6;
-                    if (!this.checkMovement && d3 < 0.25D) {
-                        this.checkMovement = true;
-                    }
-                }
-                // CraftBukkit start - fire PlayerMoveEvent
-                Player player = this.getPlayer();
-                // Spigot Start
-                if ( !hasMoved )
-                {
-                    Location curPos = player.getLocation();
-                    lastPosX = curPos.getX();
-                    lastPosY = curPos.getY();
-                    lastPosZ = curPos.getZ();
-                    lastYaw = curPos.getYaw();
-                    lastPitch = curPos.getPitch();
-                    hasMoved = true;
-                }
-                // Spigot End
-                Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch); // Get the Players previous Event location.
-                Location to = player.getLocation().clone(); // Start off the To location as the Players current location.
-
-                // If the packet contains movement information then we update the To location with the correct XYZ.
-                if (packetplayinflying.hasPos && !(packetplayinflying.hasPos && packetplayinflying.y == -999.0D)) {
-                    to.setX(packetplayinflying.x);
-                    to.setY(packetplayinflying.y);
-                    to.setZ(packetplayinflying.z);
-                }
-
-                // If the packet contains look information then we update the To location with the correct Yaw & Pitch.
-                if (packetplayinflying.hasLook) {
-                    to.setYaw(packetplayinflying.yaw);
-                    to.setPitch(packetplayinflying.pitch);
-                }
-
-                // Prevent 40 event-calls for less than a single pixel of movement >.>
-                double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
-                float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
-
-                if ((delta > 1f / 256 || deltaAngle > 10f) && (this.checkMovement && !this.player.dead)) {
-                    this.lastPosX = to.getX();
-                    this.lastPosY = to.getY();
-                    this.lastPosZ = to.getZ();
-                    this.lastYaw = to.getYaw();
-                    this.lastPitch = to.getPitch();
-
-                    // Skip the first time we do this
-                    if (true) { // Spigot - don't skip any move events
-                        Location oldTo = to.clone();
-                        PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
-                        this.server.getPluginManager().callEvent(event);
-
-                        // If the event is cancelled we move the player back to their old location.
-                        if (event.isCancelled()) {
-                            this.player.playerConnection.sendPacket(new PacketPlayOutPosition(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch(), Collections.<PacketPlayOutPosition.EnumPlayerTeleportFlags>emptySet()));
-                            return;
-                        }
-
-                        /* If a Plugin has changed the To destination then we teleport the Player
-                        there to avoid any 'Moved wrongly' or 'Moved too quickly' errors.
-                        We only do this if the Event was not cancelled. */
-                        if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
-                            this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
-                            return;
-                        }
-
-                        /* Check to see if the Players Location has some how changed during the call of the event.
-                        This can happen due to a plugin teleporting the player instead of using .setTo() */
-                        if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
-                            this.justTeleported = false;
-                            return;
-                        }
-                    }
-                }
-
-                if (this.checkMovement && !this.player.dead) {
-                    // CraftBukkit end
-                    this.f = this.e;
-                    double d7;
-                    double d8;
-                    double d9;
-
-                    if (this.player.vehicle != null) {
-                        float f = this.player.yaw;
-                        float f1 = this.player.pitch;
-
-                        this.player.vehicle.al();
-                        d7 = this.player.locX;
-                        d8 = this.player.locY;
-                        d9 = this.player.locZ;
-                        if (packetplayinflying.h()) {
-                            f = packetplayinflying.d();
-                            f1 = packetplayinflying.e();
-                        }
-
-                        this.player.onGround = packetplayinflying.f();
-                        this.player.l();
-                        this.player.setLocation(d7, d8, d9, f, f1);
-                        if (this.player.vehicle != null) {
-                            this.player.vehicle.al();
-                        }
-
-                        this.minecraftServer.getPlayerList().d(this.player);
-                        if (this.player.vehicle != null) {
-                            this.player.vehicle.ai = true; // CraftBukkit - moved from below
-                            if (d3 > 4.0D) {
-                                Entity entity = this.player.vehicle;
-
-                                this.player.playerConnection.sendPacket(new PacketPlayOutEntityTeleport(entity));
-                                this.a(this.player.locX, this.player.locY, this.player.locZ, this.player.yaw, this.player.pitch);
-                            }
-
-                            // this.player.vehicle.ai = true; // CraftBukkit - moved up
-                        }
-
-                        if (this.checkMovement) {
-                            this.o = this.player.locX;
-                            this.p = this.player.locY;
-                            this.q = this.player.locZ;
-                        }
-
-                        worldserver.g(this.player);
-                        return;
-                    }
-
-                    if (this.player.isSleeping()) {
-                        this.player.l();
-                        this.player.setLocation(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
-                        worldserver.g(this.player);
-                        return;
-                    }
-
-                    double d10 = this.player.locY;
-
-                    this.o = this.player.locX;
-                    this.p = this.player.locY;
-                    this.q = this.player.locZ;
-                    d7 = this.player.locX;
-                    d8 = this.player.locY;
-                    d9 = this.player.locZ;
-                    float f2 = this.player.yaw;
-                    float f3 = this.player.pitch;
-
-                    if (packetplayinflying.g() && packetplayinflying.b() == -999.0D) {
-                        packetplayinflying.a(false);
-                    }
-
-                    if (packetplayinflying.g()) {
-                        d7 = packetplayinflying.a();
-                        d8 = packetplayinflying.b();
-                        d9 = packetplayinflying.c();
-                        if (Math.abs(packetplayinflying.a()) > 3.0E7D || Math.abs(packetplayinflying.c()) > 3.0E7D) {
-                            this.disconnect("Illegal position");
-                            return;
-                        }
-                    }
-
-                    if (packetplayinflying.h()) {
-                        f2 = packetplayinflying.d();
-                        f3 = packetplayinflying.e();
-                    }
-
-                    this.player.l();
-                    this.player.setLocation(this.o, this.p, this.q, f2, f3);
-                    if (!this.checkMovement) {
-                        return;
-                    }
-
-                    double d11 = d7 - this.player.locX;
-                    double d12 = d8 - this.player.locY;
-                    double d13 = d9 - this.player.locZ;
-                    double d14 = this.player.motX * this.player.motX + this.player.motY * this.player.motY + this.player.motZ * this.player.motZ;
-                    double d15 = d11 * d11 + d12 * d12 + d13 * d13;
-
-                    // Spigot: make "moved too quickly" limit configurable
-                    if (d15 - d14 > org.spigotmc.SpigotConfig.movedTooQuicklyThreshold && this.checkMovement && (!this.minecraftServer.T() || !this.minecraftServer.S().equals(this.player.getName()))) { // CraftBukkit - Added this.checkMovement condition to solve this check being triggered by teleports
-                        PlayerConnection.c.warn(this.player.getName() + " moved too quickly! " + d11 + "," + d12 + "," + d13 + " (" + d11 + ", " + d12 + ", " + d13 + ")");
-                        this.a(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
-                        return;
-                    }
-
-                    float f4 = 0.0625F;
-                    boolean flag = worldserver.getCubes(this.player, this.player.getBoundingBox().shrink((double) f4, (double) f4, (double) f4)).isEmpty();
-
-                    if (this.player.onGround && !packetplayinflying.f() && d12 > 0.0D) {
-                        this.player.bF();
-                    }
-
-                    this.player.move(d11, d12, d13);
-                    this.player.onGround = packetplayinflying.f();
-                    double d16 = d12;
-
-                    d11 = d7 - this.player.locX;
-                    d12 = d8 - this.player.locY;
-                    if (d12 > -0.5D || d12 < 0.5D) {
-                        d12 = 0.0D;
-                    }
-
-                    d13 = d9 - this.player.locZ;
-                    d15 = d11 * d11 + d12 * d12 + d13 * d13;
-                    boolean flag1 = false;
-
-                    // Spigot: make "moved wrongly" limit configurable
-                    if (d15 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.playerInteractManager.isCreative()) {
-                        flag1 = true;
-                        PlayerConnection.c.warn(this.player.getName() + " moved wrongly!");
-                    }
-
-                    this.player.setLocation(d7, d8, d9, f2, f3);
-                    this.player.checkMovement(this.player.locX - d0, this.player.locY - d1, this.player.locZ - d2);
-                    if (!this.player.noclip) {
-                        boolean flag2 = worldserver.getCubes(this.player, this.player.getBoundingBox().shrink((double) f4, (double) f4, (double) f4)).isEmpty();
-
-                        if (flag && (flag1 || !flag2) && !this.player.isSleeping()) {
-                            this.a(this.o, this.p, this.q, f2, f3);
-                            return;
-                        }
-                    }
-
-                    AxisAlignedBB axisalignedbb = this.player.getBoundingBox().grow((double) f4, (double) f4, (double) f4).a(0.0D, -0.55D, 0.0D);
-
-                    if (!this.minecraftServer.getAllowFlight() && !this.player.abilities.canFly && !worldserver.c(axisalignedbb)) {
-                        if (d16 >= -0.03125D) {
-                            ++this.g;
-                            if (this.g > 80) {
-                                PlayerConnection.c.warn(this.player.getName() + " was kicked for floating too long!");
-                                this.disconnect("Flying is not enabled on this server");
-                                return;
-                            }
-                        }
-                    } else {
-                        this.g = 0;
-                    }
-
-                    this.player.onGround = packetplayinflying.f();
-                    this.minecraftServer.getPlayerList().d(this.player);
-                    this.player.a(this.player.locY - d10, packetplayinflying.f());
-                } else if (this.e - this.f > 20) {
-                    this.a(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
-                }
-            }
-
-        }
-    }
-
-    public void a(double d0, double d1, double d2, float f, float f1) {
-        this.a(d0, d1, d2, f, f1, Collections.<PacketPlayOutPosition.EnumPlayerTeleportFlags>emptySet()); // CraftBukkit fix decompile errors
-    }
-
-    public void a(double d0, double d1, double d2, float f, float f1, Set<PacketPlayOutPosition.EnumPlayerTeleportFlags> set) {
-        // CraftBukkit start - Delegate to teleport(Location)
-        Player player = this.getPlayer();
-        Location from = player.getLocation();
-
-        double x = d0;
-        double y = d1;
-        double z = d2;
-        float yaw = f;
-        float pitch = f1;
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X)) {
-            x += from.getX();
-        }
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y)) {
-            y += from.getY();
-        }
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Z)) {
-            z += from.getZ();
-        }
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y_ROT)) {
-            yaw += from.getYaw();
-        }
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X_ROT)) {
-            pitch += from.getPitch();
-        }
-
-
-        Location to = new Location(this.getPlayer().getWorld(), x, y, z, yaw, pitch);
-        PlayerTeleportEvent event = new PlayerTeleportEvent(player, from.clone(), to.clone(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
-        this.server.getPluginManager().callEvent(event);
-
-        if (event.isCancelled() || to.equals(event.getTo())) {
-            set.clear(); // Can't relative teleport
-            to = event.isCancelled() ? event.getFrom() : event.getTo();
-            d0 = to.getX();
-            d1 = to.getY();
-            d2 = to.getZ();
-            f = to.getYaw();
-            f1 = to.getPitch();
-        }
-
-        this.internalTeleport(d0, d1, d2, f, f1, set);
-    }
-
-    public void teleport(Location dest) {
-        internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.emptySet());
-    }
-
-    private void internalTeleport(double d0, double d1, double d2, float f, float f1, Set set) {
-        if (Float.isNaN(f)) {
-            f = 0;
-        }
-
-        if (Float.isNaN(f1)) {
-            f1 = 0;
-        }
-        this.justTeleported = true;
-        // CraftBukkit end
-        this.checkMovement = false;
-        this.o = d0;
-        this.p = d1;
-        this.q = d2;
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X)) {
-            this.o += this.player.locX;
-        }
-
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y)) {
-            this.p += this.player.locY;
-        }
-
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Z)) {
-            this.q += this.player.locZ;
-        }
-
-        float f2 = f;
-        float f3 = f1;
-
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y_ROT)) {
-            f2 = f + this.player.yaw;
-        }
-
-        if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X_ROT)) {
-            f3 = f1 + this.player.pitch;
-        }
-
-        // CraftBukkit start - update last location
-        this.lastPosX = this.o;
-        this.lastPosY = this.p;
-        this.lastPosZ = this.q;
-        this.lastYaw = f2;
-        this.lastPitch = f3;
-        // CraftBukkit end
-
-        this.player.setLocation(this.o, this.p, this.q, f2, f3);
-        this.player.playerConnection.sendPacket(new PacketPlayOutPosition(d0, d1, d2, f, f1, set));
-    }
-
-    public void a(PacketPlayInBlockDig packetplayinblockdig) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinblockdig, this, this.player.u());
-        if (this.player.dead) return; // CraftBukkit
-        WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
-        BlockPosition blockposition = packetplayinblockdig.a();
-
-        this.player.resetIdleTimer();
-        // CraftBukkit start
-        switch (PlayerConnection.SyntheticClass_1.a[packetplayinblockdig.c().ordinal()]) {
-        case 1: // DROP_ITEM
-            if (!this.player.isSpectator()) {
-                // limit how quickly items can be dropped
-                // If the ticks aren't the same then the count starts from 0 and we update the lastDropTick.
-                if (this.lastDropTick != MinecraftServer.currentTick) {
-                    this.dropCount = 0;
-                    this.lastDropTick = MinecraftServer.currentTick;
-                } else {
-                    // Else we increment the drop count and check the amount.
-                    this.dropCount++;
-                    if (this.dropCount >= 20) {
-                        this.c.warn(this.player.getName() + " dropped their items too quickly!");
-                        this.disconnect("You dropped your items too quickly (Hacking?)");
-                        return;
-                    }
-                }
-                // CraftBukkit end
-                this.player.a(false);
-            }
-
-            return;
-
-        case 2: // DROP_ALL_ITEMS
-            if (!this.player.isSpectator()) {
-                this.player.a(true);
-            }
-
-            return;
-
-        case 3: // RELEASE_USE_ITEM
-            this.player.bU();
-            return;
-
-        case 4: // START_DESTROY_BLOCK
-        case 5: // ABORT_DESTROY_BLOCK
-        case 6: // STOP_DESTROY_BLOCK
-            double d0 = this.player.locX - ((double) blockposition.getX() + 0.5D);
-            double d1 = this.player.locY - ((double) blockposition.getY() + 0.5D) + 1.5D;
-            double d2 = this.player.locZ - ((double) blockposition.getZ() + 0.5D);
-            double d3 = d0 * d0 + d1 * d1 + d2 * d2;
-
-            if (d3 > 36.0D) {
-                return;
-            } else if (blockposition.getY() >= this.minecraftServer.getMaxBuildHeight()) {
-                return;
-            } else {
-                if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK) {
-                    if (!this.minecraftServer.a(worldserver, blockposition, this.player) && worldserver.getWorldBorder().a(blockposition)) {
-                        this.player.playerInteractManager.a(blockposition, packetplayinblockdig.b());
-                    } else {
-                        // CraftBukkit start - fire PlayerInteractEvent
-                        CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, blockposition, packetplayinblockdig.b(), this.player.inventory.getItemInHand());
-                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
-                        // Update any tile entity data for this block
-                        TileEntity tileentity = worldserver.getTileEntity(blockposition);
-                        if (tileentity != null) {
-                            this.player.playerConnection.sendPacket(tileentity.getUpdatePacket());
-                        }
-                        // CraftBukkit end
-                    }
-                } else {
-                    if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.STOP_DESTROY_BLOCK) {
-                        this.player.playerInteractManager.a(blockposition);
-                    } else if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.ABORT_DESTROY_BLOCK) {
-                        this.player.playerInteractManager.e();
-                    }
-
-                    if (worldserver.getType(blockposition).getBlock().getMaterial() != Material.AIR) {
-                        this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
-                    }
-                }
-
-                return;
-            }
-
-        default:
-            throw new IllegalArgumentException("Invalid player action");
-        }
-        // CraftBukkit end
-    }
-
-    // Spigot start - limit place/interactions
-    private long lastPlace = -1;
-    private int packets = 0;
-
-    public void a(PacketPlayInBlockPlace packetplayinblockplace) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinblockplace, this, this.player.u());
-        WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
-        boolean throttled = false;
-        // PaperSpigot - Allow disabling the player interaction limiter
-        if (org.github.paperspigot.PaperSpigotConfig.interactLimitEnabled && lastPlace != -1 && packetplayinblockplace.timestamp - lastPlace < 30 && packets++ >= 4) {
-            throttled = true;
-        } else if ( packetplayinblockplace.timestamp - lastPlace >= 30 || lastPlace == -1 )
-        {
-            lastPlace = packetplayinblockplace.timestamp;
-            packets = 0;
-        }
-    // Spigot end
-
-        // CraftBukkit start
-        if (this.player.dead) return;
-
-        // CraftBukkit - if rightclick decremented the item, always send the update packet. */
-        // this is not here for CraftBukkit's own functionality; rather it is to fix
-        // a notch bug where the item doesn't update correctly.
-        boolean always = false;
-        // CraftBukkit end
-
-        ItemStack itemstack = this.player.inventory.getItemInHand();
-        boolean flag = false;
-        BlockPosition blockposition = packetplayinblockplace.a();
-        EnumDirection enumdirection = EnumDirection.fromType1(packetplayinblockplace.getFace());
-
-        this.player.resetIdleTimer();
-        if (packetplayinblockplace.getFace() == 255) {
-            if (itemstack == null) {
-                return;
-            }
-
-            // CraftBukkit start
-            int itemstackAmount = itemstack.count;
-            // Spigot start - skip the event if throttled
-            if (!throttled) {            
-            // Raytrace to look for 'rogue armswings'
-            float f1 = this.player.pitch;
-            float f2 = this.player.yaw;
-            double d0 = this.player.locX;
-            double d1 = this.player.locY + (double) this.player.getHeadHeight();
-            double d2 = this.player.locZ;
-            Vec3D vec3d = new Vec3D(d0, d1, d2);
-
-            float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
-            float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
-            float f5 = -MathHelper.cos(-f1 * 0.017453292F);
-            float f6 = MathHelper.sin(-f1 * 0.017453292F);
-            float f7 = f4 * f5;
-            float f8 = f3 * f5;
-            double d3 = player.playerInteractManager.getGameMode() == WorldSettings.EnumGamemode.CREATIVE ? 5.0D : 4.5D;
-            Vec3D vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
-            MovingObjectPosition movingobjectposition = this.player.world.rayTrace(vec3d, vec3d1, false);
-
-            boolean cancelled = false;
-            if (movingobjectposition == null || movingobjectposition.type != MovingObjectPosition.EnumMovingObjectType.BLOCK) {
-                org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemstack);
-                cancelled = event.useItemInHand() == Event.Result.DENY;
-            } else {
-                if (player.playerInteractManager.firedInteract) {
-                    player.playerInteractManager.firedInteract = false;
-                    cancelled = player.playerInteractManager.interactResult;
-                } else {
-                    org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(player, Action.RIGHT_CLICK_BLOCK, movingobjectposition.a(), movingobjectposition.direction, itemstack, true);
-                    cancelled = event.useItemInHand() == Event.Result.DENY;
-                }
-            }
-
-            if (!cancelled) {
-                this.player.playerInteractManager.useItem(this.player, this.player.world, itemstack);
-            }
-            }
-            // Spigot end
-
-            // CraftBukkit - notch decrements the counter by 1 in the above method with food,
-            // snowballs and so forth, but he does it in a place that doesn't cause the
-            // inventory update packet to get sent
-            always = (itemstack.count != itemstackAmount) || itemstack.getItem() == Item.getItemOf(Blocks.WATERLILY);
-            // CraftBukkit end
-        } else if (blockposition.getY() >= this.minecraftServer.getMaxBuildHeight() - 1 && (enumdirection == EnumDirection.UP || blockposition.getY() >= this.minecraftServer.getMaxBuildHeight())) {
-            ChatMessage chatmessage = new ChatMessage("build.tooHigh", new Object[] { Integer.valueOf(this.minecraftServer.getMaxBuildHeight())});
-
-            chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
-            this.player.playerConnection.sendPacket(new PacketPlayOutChat(chatmessage));
-            flag = true;
-        } else {
-            // CraftBukkit start - Check if we can actually do something over this large a distance
-            Location eyeLoc = this.getPlayer().getEyeLocation();
-            double reachDistance = NumberConversions.square(eyeLoc.getX() - blockposition.getX()) + NumberConversions.square(eyeLoc.getY() - blockposition.getY()) + NumberConversions.square(eyeLoc.getZ() - blockposition.getZ());
-            if (reachDistance > (this.getPlayer().getGameMode() == org.bukkit.GameMode.CREATIVE ? CREATIVE_PLACE_DISTANCE_SQUARED : SURVIVAL_PLACE_DISTANCE_SQUARED)) {
-                return;
-            }
-
-            if (!worldserver.getWorldBorder().a(blockposition)) {
-                return;
-            }
-
-            if (this.checkMovement && this.player.e((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D) < 64.0D && !this.minecraftServer.a(worldserver, blockposition, this.player) && worldserver.getWorldBorder().a(blockposition)) {
-                always = throttled || !this.player.playerInteractManager.interact(this.player, worldserver, itemstack, blockposition, enumdirection, packetplayinblockplace.d(), packetplayinblockplace.e(), packetplayinblockplace.f());
-            }
-
-            flag = true;
-        }
-
-        if (flag) {
-            this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
-            this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition.shift(enumdirection)));
-        }
-
-        itemstack = this.player.inventory.getItemInHand();
-        if (itemstack != null && itemstack.count == 0) {
-            this.player.inventory.items[this.player.inventory.itemInHandIndex] = null;
-            itemstack = null;
-        }
-
-        if (itemstack == null || itemstack.l() == 0) {
-            this.player.g = true;
-            this.player.inventory.items[this.player.inventory.itemInHandIndex] = ItemStack.b(this.player.inventory.items[this.player.inventory.itemInHandIndex]);
-            Slot slot = this.player.activeContainer.getSlot(this.player.inventory, this.player.inventory.itemInHandIndex);
-
-            this.player.activeContainer.b();
-            this.player.g = false;
-            // CraftBukkit - TODO CHECK IF NEEDED -- new if structure might not need 'always'. Kept it in for now, but may be able to remove in future
-            if (!ItemStack.matches(this.player.inventory.getItemInHand(), packetplayinblockplace.getItemStack()) || always) {
-                this.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, slot.rawSlotIndex, this.player.inventory.getItemInHand()));
-            }
-        }
-
-    }
-
-    public void a(PacketPlayInSpectate packetplayinspectate) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinspectate, this, this.player.u());
-        if (this.player.isSpectator()) {
-            Entity entity = null;
-            WorldServer[] aworldserver = this.minecraftServer.worldServer;
-            int i = aworldserver.length;
-
-            // CraftBukkit - use the worlds array list
-            for (WorldServer worldserver : minecraftServer.worlds) {
-
-                if (worldserver != null) {
-                    entity = packetplayinspectate.a(worldserver);
-                    if (entity != null) {
-                        break;
-                    }
-                }
-            }
-
-            if (entity != null) {
-                this.player.setSpectatorTarget(this.player);
-                this.player.mount((Entity) null);
-
-                /* CraftBukkit start - replace with bukkit handling for multi-world
-                if (entity.world != this.player.world) {
-                    WorldServer worldserver1 = this.player.u();
-                    WorldServer worldserver2 = (WorldServer) entity.world;
-
-                    this.player.dimension = entity.dimension;
-                    this.sendPacket(new PacketPlayOutRespawn(this.player.dimension, worldserver1.getDifficulty(), worldserver1.getWorldData().getType(), this.player.playerInteractManager.getGameMode()));
-                    worldserver1.removeEntity(this.player);
-                    this.player.dead = false;
-                    this.player.setPositionRotation(entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
-                    if (this.player.isAlive()) {
-                        worldserver1.entityJoinedWorld(this.player, false);
-                        worldserver2.addEntity(this.player);
-                        worldserver2.entityJoinedWorld(this.player, false);
-                    }
-
-                    this.player.spawnIn(worldserver2);
-                    this.minecraftServer.getPlayerList().a(this.player, worldserver1);
-                    this.player.enderTeleportTo(entity.locX, entity.locY, entity.locZ);
-                    this.player.playerInteractManager.a(worldserver2);
-                    this.minecraftServer.getPlayerList().b(this.player, worldserver2);
-                    this.minecraftServer.getPlayerList().updateClient(this.player);
-                } else {
-                    this.player.enderTeleportTo(entity.locX, entity.locY, entity.locZ);
-                }
-                */
-                this.player.getBukkitEntity().teleport(entity.getBukkitEntity(), PlayerTeleportEvent.TeleportCause.SPECTATE);
-                // CraftBukkit end
-            }
-        }
-
-    }
-
-    // CraftBukkit start
-    public void a(PacketPlayInResourcePackStatus packetplayinresourcepackstatus) {
-        this.server.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(getPlayer(), PlayerResourcePackStatusEvent.Status.values()[packetplayinresourcepackstatus.b.ordinal()]));
-    }
-    // CraftBukkit end
-
-    public void a(IChatBaseComponent ichatbasecomponent) {
-        // CraftBukkit start - Rarely it would send a disconnect line twice
-        if (this.processedDisconnect) {
-            return;
-        } else {
-            this.processedDisconnect = true;
-        }
-        // CraftBukkit end
-        PlayerConnection.c.info(this.player.getName() + " lost connection: " + ichatbasecomponent.c()); // CraftBukkit: Don't toString(). // PAIL: Rename
-        // CraftBukkit start - Replace vanilla quit message handling with our own.
-        /*
-        this.minecraftServer.aH();
-        ChatMessage chatmessage = new ChatMessage("multiplayer.player.left", new Object[] { this.player.getScoreboardDisplayName()});
-
-        chatmessage.getChatModifier().setColor(EnumChatFormat.YELLOW);
-        this.minecraftServer.getPlayerList().sendMessage(chatmessage);
-        */
-
-        this.player.q();
-        String quitMessage = this.minecraftServer.getPlayerList().disconnect(this.player);
-        if ((quitMessage != null) && (quitMessage.length() > 0)) {
-            this.minecraftServer.getPlayerList().sendMessage(CraftChatMessage.fromString(quitMessage));
-        }
-        // CraftBukkit end
-        if (this.minecraftServer.T() && this.player.getName().equals(this.minecraftServer.S())) {
-            PlayerConnection.c.info("Stopping singleplayer server as player logged out");
-            this.minecraftServer.safeShutdown();
-        }
-
-    }
-
-    public void sendPacket(final Packet packet) {
-        if (packet instanceof PacketPlayOutChat) {
-            PacketPlayOutChat packetplayoutchat = (PacketPlayOutChat) packet;
-            EntityHuman.EnumChatVisibility entityhuman_enumchatvisibility = this.player.getChatFlags();
-
-            if (entityhuman_enumchatvisibility == EntityHuman.EnumChatVisibility.HIDDEN) {
-                return;
-            }
-
-            if (entityhuman_enumchatvisibility == EntityHuman.EnumChatVisibility.SYSTEM && !packetplayoutchat.b()) {
-                return;
-            }
-        }
-
-        // CraftBukkit start
-        if (packet == null || this.processedDisconnect) { // Spigot
-            return;
-        } else if (packet instanceof PacketPlayOutSpawnPosition) {
-            PacketPlayOutSpawnPosition packet6 = (PacketPlayOutSpawnPosition) packet;
-            this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(), packet6.position.getY(), packet6.position.getZ());
-        }
-        // CraftBukkit end
-
-        try {
-            this.networkManager.handle(packet);
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Sending packet");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Packet being sent");
-
-            crashreportsystemdetails.a("Packet class", new Callable() {
-                public String a() throws Exception {
-                    return packet.getClass().getCanonicalName();
-                }
-
-                public Object call() throws Exception {
-                    return this.a();
-                }
-            });
-            throw new ReportedException(crashreport);
-        }
-    }
-
-    public void a(PacketPlayInHeldItemSlot packetplayinhelditemslot) {
-        // CraftBukkit start
-        if (this.player.dead) return;
-        PlayerConnectionUtils.ensureMainThread(packetplayinhelditemslot, this, this.player.u());
-        if (packetplayinhelditemslot.a() >= 0 && packetplayinhelditemslot.a() < PlayerInventory.getHotbarSize()) {
-            PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getPlayer(), this.player.inventory.itemInHandIndex, packetplayinhelditemslot.a());
-            this.server.getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                this.sendPacket(new PacketPlayOutHeldItemSlot(this.player.inventory.itemInHandIndex));
-                this.player.resetIdleTimer();
-                return;
-            }
-            // CraftBukkit end
-            this.player.inventory.itemInHandIndex = packetplayinhelditemslot.a();
-            this.player.resetIdleTimer();
-        } else {
-            PlayerConnection.c.warn(this.player.getName() + " tried to set an invalid carried item");
-            this.disconnect("Invalid hotbar selection (Hacking?)"); // CraftBukkit //Spigot "Nope" -> Descriptive reason
-        }
-    }
-
-    public void a(PacketPlayInChat packetplayinchat) {
-        // CraftBukkit start - async chat
-        boolean isSync = packetplayinchat.a().startsWith("/");
-        if (packetplayinchat.a().startsWith("/")) {
-            PlayerConnectionUtils.ensureMainThread(packetplayinchat, this, this.player.u());
-        }
-        // CraftBukkit end
-        if (this.player.dead || this.player.getChatFlags() == EntityHuman.EnumChatVisibility.HIDDEN) { // CraftBukkit - dead men tell no tales
-            ChatMessage chatmessage = new ChatMessage("chat.cannotSend", new Object[0]);
-
-            chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
-            this.sendPacket(new PacketPlayOutChat(chatmessage));
-        } else {
-            this.player.resetIdleTimer();
-            String s = packetplayinchat.a();
-
-            s = StringUtils.normalizeSpace(s);
-
-            for (int i = 0; i < s.length(); ++i) {
-                if (!SharedConstants.isAllowedChatCharacter(s.charAt(i))) {
-                    // CraftBukkit start - threadsafety
-                    if (!isSync) {
-                        Waitable waitable = new Waitable() {
-                            @Override
-                            protected Object evaluate() {
-                                PlayerConnection.this.disconnect("Illegal characters in chat");
-                                return null;
-                            }
-                        };
-
-                        this.minecraftServer.processQueue.add(waitable);
-
-                        try {
-                            waitable.get();
-                        } catch (InterruptedException e) {
-                            Thread.currentThread().interrupt();
-                        } catch (ExecutionException e) {
-                            throw new RuntimeException(e);
-                        }
-                    } else {
-                        this.disconnect("Illegal characters in chat");
-                    }
-                    // CraftBukkit end
-                    return;
-                }
-            }
-
-            // CraftBukkit start
-            if (isSync) {
-                try {
-                    this.minecraftServer.server.playerCommandState = true;
-                    this.handleCommand(s);
-                } finally {
-                    this.minecraftServer.server.playerCommandState = false;
-                }
-            } else if (s.isEmpty()) {
-                c.warn(this.player.getName() + " tried to send an empty message");
-            } else if (getPlayer().isConversing()) {
-                // Spigot start
-                final String message = s;
-                this.minecraftServer.processQueue.add( new Waitable()
-                {
-                    @Override
-                    protected Object evaluate()
-                    {
-                        getPlayer().acceptConversationInput( message );
-                        return null;
-                    }
-                } );
-                // Spigot end
-            } else if (this.player.getChatFlags() == EntityHuman.EnumChatVisibility.SYSTEM) { // Re-add "Command Only" flag check
-                ChatMessage chatmessage = new ChatMessage("chat.cannotSend", new Object[0]);
-
-                chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
-                this.sendPacket(new PacketPlayOutChat(chatmessage));
-            } else if (true) {
-                this.chat(s, true);
-                // CraftBukkit end - the below is for reference. :)
-            } else {
-                ChatMessage chatmessage1 = new ChatMessage("chat.type.text", new Object[] { this.player.getScoreboardDisplayName(), s});
-
-                this.minecraftServer.getPlayerList().sendMessage(chatmessage1, false);
-            }
-
-            // Spigot start - spam exclusions
-            boolean counted = true;
-            for ( String exclude : org.spigotmc.SpigotConfig.spamExclusions )
-            {
-                if ( exclude != null && s.startsWith( exclude ) )
-                {
-                    counted = false;
-                    break;
-                }
-            }
-            // Spigot end
-            // CraftBukkit start - replaced with thread safe throttle
-            // this.chatThrottle += 20;
-            if (counted && chatSpamField.addAndGet(this, 20) > 200 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) { // Spigot
-                if (!isSync) {
-                    Waitable waitable = new Waitable() {
-                        @Override
-                        protected Object evaluate() {
-                            PlayerConnection.this.disconnect("disconnect.spam");
-                            return null;
-                        }
-                    };
-
-                    this.minecraftServer.processQueue.add(waitable);
-
-                    try {
-                        waitable.get();
-                    } catch (InterruptedException e) {
-                        Thread.currentThread().interrupt();
-                    } catch (ExecutionException e) {
-                        throw new RuntimeException(e);
-                    }
-                } else {
-                    this.disconnect("disconnect.spam");
-                }
-                // CraftBukkit end
-            }
-
-        }
-    }
-
-    // CraftBukkit start - add method
-    public void chat(String s, boolean async) {
-        if (s.isEmpty() || this.player.getChatFlags() == EntityHuman.EnumChatVisibility.HIDDEN) {
-            return;
-        }
-
-        if (!async && s.startsWith("/")) {
-            // PaperSpigot Start
-            if (!org.bukkit.Bukkit.isPrimaryThread()) {
-                final String fCommandLine = s;
-                MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Command Dispatched Async: " + fCommandLine);
-                MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Please notify author of plugin causing this execution to fix this bug! see: http://bit.ly/1oSiM6C", new Throwable());
-                Waitable wait = new Waitable() {
-                    @Override
-                    protected Object evaluate() {
-                        chat(fCommandLine, false);
-                        return null;
-                    }
-                };
-                minecraftServer.processQueue.add(wait);
-                try {
-                    wait.get();
-                    return;
-                } catch (InterruptedException e) {
-                    Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
-                } catch (Exception e) {
-                    throw new RuntimeException("Exception processing chat command", e.getCause());
-                }
-            }
-            // PaperSpigot End
-            this.handleCommand(s);
-        } else if (this.player.getChatFlags() == EntityHuman.EnumChatVisibility.SYSTEM) {
-            // Do nothing, this is coming from a plugin
-        } else {
-            Player player = this.getPlayer();
-            AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet());
-            this.server.getPluginManager().callEvent(event);
-
-            if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
-                // Evil plugins still listening to deprecated event
-                final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
-                queueEvent.setCancelled(event.isCancelled());
-                Waitable waitable = new Waitable() {
-                    @Override
-                    protected Object evaluate() {
-                        org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
-
-                        if (queueEvent.isCancelled()) {
-                            return null;
-                        }
-
-                        String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
-                        PlayerConnection.this.minecraftServer.console.sendMessage(message);
-                        if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
-                            for (Object player : PlayerConnection.this.minecraftServer.getPlayerList().players) {
-                                ((EntityPlayer) player).sendMessage(CraftChatMessage.fromString(message));
-                            }
-                        } else {
-                            for (Player player : queueEvent.getRecipients()) {
-                                player.sendMessage(message);
-                            }
-                        }
-                        return null;
-                    }};
-                if (async) {
-                    minecraftServer.processQueue.add(waitable);
-                } else {
-                    waitable.run();
-                }
-                try {
-                    waitable.get();
-                } catch (InterruptedException e) {
-                    Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
-                } catch (ExecutionException e) {
-                    throw new RuntimeException("Exception processing chat event", e.getCause());
-                }
-            } else {
-                if (event.isCancelled()) {
-                    return;
-                }
-
-                s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
-                minecraftServer.console.sendMessage(s);
-                if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
-                    for (Object recipient : minecraftServer.getPlayerList().players) {
-                        ((EntityPlayer) recipient).sendMessage(CraftChatMessage.fromString(s));
-                    }
-                } else {
-                    for (Player recipient : event.getRecipients()) {
-                        recipient.sendMessage(s);
-                    }
-                }
-            }
-        }
-    }
-    // CraftBukkit end
-
-   private void handleCommand(String s) {
-        SpigotTimings.playerCommandTimer.startTiming(); // Spigot
-       // CraftBukkit start - whole method
-        if ( org.spigotmc.SpigotConfig.logCommands ) // Spigot
-        this.c.info(this.player.getName() + " issued server command: " + s);
-
-        CraftPlayer player = this.getPlayer();
-
-        PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, s, new LazyPlayerSet());
-        this.server.getPluginManager().callEvent(event);
-
-        if (event.isCancelled()) {
-            SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
-            return;
-        }
-
-        try {
-            if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
-                SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
-                return;
-            }
-        } catch (org.bukkit.command.CommandException ex) {
-            player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
-            java.util.logging.Logger.getLogger(PlayerConnection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
-            SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
-            return;
-        }
-        SpigotTimings.playerCommandTimer.stopTiming(); // Spigot
-        // this.minecraftServer.getCommandHandler().a(this.player, s);
-        // CraftBukkit end
-    }
-
-    public void a(PacketPlayInArmAnimation packetplayinarmanimation) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayinarmanimation, this, this.player.u());
-        this.player.resetIdleTimer();
-        // CraftBukkit start - Raytrace to look for 'rogue armswings'
-        float f1 = this.player.pitch;
-        float f2 = this.player.yaw;
-        double d0 = this.player.locX;
-        double d1 = this.player.locY + (double) this.player.getHeadHeight();
-        double d2 = this.player.locZ;
-        Vec3D vec3d = new Vec3D(d0, d1, d2);
-
-        float f3 = MathHelper.cos(-f2 * 0.017453292F - 3.1415927F);
-        float f4 = MathHelper.sin(-f2 * 0.017453292F - 3.1415927F);
-        float f5 = -MathHelper.cos(-f1 * 0.017453292F);
-        float f6 = MathHelper.sin(-f1 * 0.017453292F);
-        float f7 = f4 * f5;
-        float f8 = f3 * f5;
-        double d3 = player.playerInteractManager.getGameMode() == WorldSettings.EnumGamemode.CREATIVE ? 5.0D : 4.5D;
-        Vec3D vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
-        MovingObjectPosition movingobjectposition = this.player.world.rayTrace(vec3d, vec3d1, false);
-
-        if (movingobjectposition == null || movingobjectposition.type != MovingObjectPosition.EnumMovingObjectType.BLOCK) {
-            CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_AIR, this.player.inventory.getItemInHand());
-        }
-
-        // Arm swing animation
-        PlayerAnimationEvent event = new PlayerAnimationEvent(this.getPlayer());
-        this.server.getPluginManager().callEvent(event);
-
-        if (event.isCancelled()) return;
-        // CraftBukkit end
-        this.player.bw();
-    }
-
-    public void a(PacketPlayInEntityAction packetplayinentityaction) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinentityaction, this, this.player.u());
-        // CraftBukkit start
-        if (this.player.dead) return;
-        switch (packetplayinentityaction.b()) {
-            case START_SNEAKING:
-            case STOP_SNEAKING:
-                PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getPlayer(), packetplayinentityaction.b() == PacketPlayInEntityAction.EnumPlayerAction.START_SNEAKING);
-                this.server.getPluginManager().callEvent(event);
-
-                if (event.isCancelled()) {
-                    return;
-                }
-                break;
-            case START_SPRINTING:
-            case STOP_SPRINTING:
-                PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getPlayer(), packetplayinentityaction.b() == PacketPlayInEntityAction.EnumPlayerAction.START_SPRINTING);
-                this.server.getPluginManager().callEvent(e2);
-
-                if (e2.isCancelled()) {
-                    return;
-                }
-                break;
-        }
-        // CraftBukkit end
-        this.player.resetIdleTimer();
-        switch (PlayerConnection.SyntheticClass_1.b[packetplayinentityaction.b().ordinal()]) {
-        case 1:
-            this.player.setSneaking(true);
-            break;
-
-        case 2:
-            this.player.setSneaking(false);
-            break;
-
-        case 3:
-            this.player.setSprinting(true);
-            break;
-
-        case 4:
-            this.player.setSprinting(false);
-            break;
-
-        case 5:
-            this.player.a(false, true, true);
-            // this.checkMovement = false; // CraftBukkit - this is handled in teleport
-            break;
-
-        case 6:
-            if (this.player.vehicle instanceof EntityHorse) {
-                ((EntityHorse) this.player.vehicle).v(packetplayinentityaction.c());
-            }
-            break;
-
-        case 7:
-            if (this.player.vehicle instanceof EntityHorse) {
-                ((EntityHorse) this.player.vehicle).g((EntityHuman) this.player);
-            }
-            break;
-
-        default:
-            throw new IllegalArgumentException("Invalid client command!");
-        }
-
-    }
-
-    public void a(PacketPlayInUseEntity packetplayinuseentity) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayinuseentity, this, this.player.u());
-        WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
-        Entity entity = packetplayinuseentity.a((World) worldserver);
-        // Spigot Start
-        if ( entity == player && !player.isSpectator() )
-        {
-            disconnect( "Cannot interact with self!" );
-            return;
-        }
-        // Spigot End
-
-        this.player.resetIdleTimer();
-        if (entity != null) {
-            boolean flag = this.player.hasLineOfSight(entity);
-            double d0 = 36.0D;
-
-            if (!flag) {
-                d0 = 9.0D;
-            }
-
-            if (this.player.h(entity) < d0) {
-                ItemStack itemInHand = this.player.inventory.getItemInHand(); // CraftBukkit
-
-                if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT
-                        || packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
-                    // CraftBukkit start
-                    boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof EntityInsentient;
-                    Item origItem = this.player.inventory.getItemInHand() == null ? null : this.player.inventory.getItemInHand().getItem();
-                    PlayerInteractEntityEvent event;
-                    if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT) {
-                        event = new PlayerInteractEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity());
-                    } else {
-                        Vec3D target = packetplayinuseentity.b();
-                        event = new PlayerInteractAtEntityEvent((Player) this.getPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(target.a, target.b, target.c));
-                    }
-                    this.server.getPluginManager().callEvent(event);
-
-                    if (triggerLeashUpdate && (event.isCancelled() || this.player.inventory.getItemInHand() == null || this.player.inventory.getItemInHand().getItem() != Items.LEAD)) {
-                        // Refresh the current leash state
-                        this.sendPacket(new PacketPlayOutAttachEntity(1, entity, ((EntityInsentient) entity).getLeashHolder()));
-                    }
-
-                    if (event.isCancelled() || this.player.inventory.getItemInHand() == null || this.player.inventory.getItemInHand().getItem() != origItem) {
-                        // Refresh the current entity metadata
-                        this.sendPacket(new PacketPlayOutEntityMetadata(entity.getId(), entity.datawatcher, true));
-                    }
-
-                    if (event.isCancelled()) {
-                        return;
-                    }
-                    // CraftBukkit end
-                }
-                if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT) {
-                    this.player.u(entity);
-
-                    // CraftBukkit start
-                    if (itemInHand != null && itemInHand.count <= -1) {
-                        this.player.updateInventory(this.player.activeContainer);
-                    }
-                    // CraftBukkit end
-                } else if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
-                    entity.a((EntityHuman) this.player, packetplayinuseentity.b());
-
-                    // CraftBukkit start
-                    if (itemInHand != null && itemInHand.count <= -1) {
-                        this.player.updateInventory(this.player.activeContainer);
-                    }
-                    // CraftBukkit end
-                } else if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.ATTACK) {
-                    if (entity instanceof EntityItem || entity instanceof EntityExperienceOrb || entity instanceof EntityArrow || (entity == this.player && !player.isSpectator())) { // CraftBukkit
-                        this.disconnect("Attempting to attack an invalid entity");
-                        this.minecraftServer.warning("Player " + this.player.getName() + " tried to attack an invalid entity");
-                        return;
-                    }
-
-                    this.player.attack(entity);
-
-                    // CraftBukkit start
-                    if (itemInHand != null && itemInHand.count <= -1) {
-                        this.player.updateInventory(this.player.activeContainer);
-                    }
-                    // CraftBukkit end
-                }
-            }
-        }
-
-    }
-
-    public void a(PacketPlayInClientCommand packetplayinclientcommand) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinclientcommand, this, this.player.u());
-        this.player.resetIdleTimer();
-        PacketPlayInClientCommand.EnumClientCommand packetplayinclientcommand_enumclientcommand = packetplayinclientcommand.a();
-
-        switch (PlayerConnection.SyntheticClass_1.c[packetplayinclientcommand_enumclientcommand.ordinal()]) {
-        case 1:
-            if (this.player.viewingCredits) {
-                // this.player = this.minecraftServer.getPlayerList().moveToWorld(this.player, 0, true);
-                this.minecraftServer.getPlayerList().changeDimension(this.player, 0, PlayerTeleportEvent.TeleportCause.END_PORTAL); // CraftBukkit - reroute logic through custom portal management
-            } else if (this.player.u().getWorldData().isHardcore()) {
-                if (this.minecraftServer.T() && this.player.getName().equals(this.minecraftServer.S())) {
-                    this.player.playerConnection.disconnect("You have died. Game over, man, it\'s game over!");
-                    this.minecraftServer.aa();
-                } else {
-                    GameProfileBanEntry gameprofilebanentry = new GameProfileBanEntry(this.player.getProfile(), (Date) null, "(You just lost the game)", (Date) null, "Death in Hardcore");
-
-                    this.minecraftServer.getPlayerList().getProfileBans().add(gameprofilebanentry);
-                    this.player.playerConnection.disconnect("You have died. Game over, man, it\'s game over!");
-                }
-            } else {
-                if (this.player.getHealth() > 0.0F) {
-                    return;
-                }
-
-                this.player = this.minecraftServer.getPlayerList().moveToWorld(this.player, 0, false);
-            }
-            break;
-
-        case 2:
-            this.player.getStatisticManager().a(this.player);
-            break;
-
-        case 3:
-            this.player.b((Statistic) AchievementList.f);
-        }
-
-    }
-
-    public void a(PacketPlayInCloseWindow packetplayinclosewindow) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayinclosewindow, this, this.player.u());
-
-        CraftEventFactory.handleInventoryCloseEvent(this.player); // CraftBukkit
-
-        this.player.p();
-    }
-
-    public void a(PacketPlayInWindowClick packetplayinwindowclick) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayinwindowclick, this, this.player.u());
-        this.player.resetIdleTimer();
-        if (this.player.activeContainer.windowId == packetplayinwindowclick.a() && this.player.activeContainer.c(this.player)) {
-            boolean cancelled = this.player.isSpectator(); // CraftBukkit - see below if
-            if (false) { // this.player.isSpectator()) {
-                ArrayList arraylist = Lists.newArrayList();
-
-                for (int i = 0; i < this.player.activeContainer.c.size(); ++i) {
-                    arraylist.add(((Slot) this.player.activeContainer.c.get(i)).getItem());
-                }
-
-                this.player.a(this.player.activeContainer, (List) arraylist);
-            } else {
-                // ItemStack itemstack = this.player.activeContainer.clickItem(packetplayinwindowclick.b(), packetplayinwindowclick.c(), packetplayinwindowclick.f(), this.player);
-                // CraftBukkit start - Call InventoryClickEvent
-                if (packetplayinwindowclick.b() < -1 && packetplayinwindowclick.b() != -999) {
-                    return;
-                }
-
-                InventoryView inventory = this.player.activeContainer.getBukkitView();
-                SlotType type = CraftInventoryView.getSlotType(inventory, packetplayinwindowclick.b());
-
-                InventoryClickEvent event = null;
-                ClickType click = ClickType.UNKNOWN;
-                InventoryAction action = InventoryAction.UNKNOWN;
-
-                ItemStack itemstack = null;
-
-                if (packetplayinwindowclick.b() == -1) {
-                    type = SlotType.OUTSIDE; // override
-                    click = packetplayinwindowclick.c() == 0 ? ClickType.WINDOW_BORDER_LEFT : ClickType.WINDOW_BORDER_RIGHT;
-                    action = InventoryAction.NOTHING;
-                } else if (packetplayinwindowclick.f() == 0) {
-                    if (packetplayinwindowclick.c() == 0) {
-                        click = ClickType.LEFT;
-                    } else if (packetplayinwindowclick.c() == 1) {
-                        click = ClickType.RIGHT;
-                    }
-                    if (packetplayinwindowclick.c() == 0 || packetplayinwindowclick.c() == 1) {
-                        action = InventoryAction.NOTHING; // Don't want to repeat ourselves
-                        if (packetplayinwindowclick.b() == -999) {
-                            if (player.inventory.getCarried() != null) {
-                                action = packetplayinwindowclick.c() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
-                            }
-                        } else {
-                            Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                            if (slot != null) {
-                                ItemStack clickedItem = slot.getItem();
-                                ItemStack cursor = player.inventory.getCarried();
-                                if (clickedItem == null) {
-                                    if (cursor != null) {
-                                        action = packetplayinwindowclick.c() == 0 ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE;
-                                    }
-                                } else if (slot.isAllowed(player)) {
-                                    if (cursor == null) {
-                                        action = packetplayinwindowclick.c() == 0 ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF;
-                                    } else if (slot.isAllowed(cursor)) {
-                                        if (clickedItem.doMaterialsMatch(cursor) && ItemStack.equals(clickedItem, cursor)) {
-                                            int toPlace = packetplayinwindowclick.c() == 0 ? cursor.count : 1;
-                                            toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.count);
-                                            toPlace = Math.min(toPlace, slot.inventory.getMaxStackSize() - clickedItem.count);
-                                            if (toPlace == 1) {
-                                                action = InventoryAction.PLACE_ONE;
-                                            } else if (toPlace == cursor.count) {
-                                                action = InventoryAction.PLACE_ALL;
-                                            } else if (toPlace < 0) {
-                                                action = toPlace != -1 ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE; // this happens with oversized stacks
-                                            } else if (toPlace != 0) {
-                                                action = InventoryAction.PLACE_SOME;
-                                            }
-                                        } else if (cursor.count <= slot.getMaxStackSize()) {
-                                            action = InventoryAction.SWAP_WITH_CURSOR;
-                                        }
-                                    } else if (cursor.getItem() == clickedItem.getItem() && (!cursor.usesData() || cursor.getData() == clickedItem.getData()) && ItemStack.equals(cursor, clickedItem)) {
-                                        if (clickedItem.count >= 0) {
-                                            if (clickedItem.count + cursor.count <= cursor.getMaxStackSize()) {
-                                                // As of 1.5, this is result slots only
-                                                action = InventoryAction.PICKUP_ALL;
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                } else if (packetplayinwindowclick.f() == 1) {
-                    if (packetplayinwindowclick.c() == 0) {
-                        click = ClickType.SHIFT_LEFT;
-                    } else if (packetplayinwindowclick.c() == 1) {
-                        click = ClickType.SHIFT_RIGHT;
-                    }
-                    if (packetplayinwindowclick.c() == 0 || packetplayinwindowclick.c() == 1) {
-                        if (packetplayinwindowclick.b() < 0) {
-                            action = InventoryAction.NOTHING;
-                        } else {
-                            Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                            if (slot != null && slot.isAllowed(this.player) && slot.hasItem()) {
-                                action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
-                            } else {
-                                action = InventoryAction.NOTHING;
-                            }
-                        }
-                    }
-                } else if (packetplayinwindowclick.f() == 2) {
-                    if (packetplayinwindowclick.c() >= 0 && packetplayinwindowclick.c() < 9) {
-                        click = ClickType.NUMBER_KEY;
-                        Slot clickedSlot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                        if (clickedSlot.isAllowed(player)) {
-                            ItemStack hotbar = this.player.inventory.getItem(packetplayinwindowclick.c());
-                            boolean canCleanSwap = hotbar == null || (clickedSlot.inventory == player.inventory && clickedSlot.isAllowed(hotbar)); // the slot will accept the hotbar item
-                            if (clickedSlot.hasItem()) {
-                                if (canCleanSwap) {
-                                    action = InventoryAction.HOTBAR_SWAP;
-                                } else {
-                                    int firstEmptySlot = player.inventory.getFirstEmptySlotIndex();
-                                    if (firstEmptySlot > -1) {
-                                        action = InventoryAction.HOTBAR_MOVE_AND_READD;
-                                    } else {
-                                        action = InventoryAction.NOTHING; // This is not sane! Mojang: You should test for other slots of same type
-                                    }
-                                }
-                            } else if (!clickedSlot.hasItem() && hotbar != null && clickedSlot.isAllowed(hotbar)) {
-                                action = InventoryAction.HOTBAR_SWAP;
-                            } else {
-                                action = InventoryAction.NOTHING;
-                            }
-                        } else {
-                            action = InventoryAction.NOTHING;
-                        }
-                        // Special constructor for number key
-                        event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
-                    }
-                } else if (packetplayinwindowclick.f() == 3) {
-                    if (packetplayinwindowclick.c() == 2) {
-                        click = ClickType.MIDDLE;
-                        if (packetplayinwindowclick.b() == -999) {
-                            action = InventoryAction.NOTHING;
-                        } else {
-                            Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                            if (slot != null && slot.hasItem() && player.abilities.canInstantlyBuild && player.inventory.getCarried() == null) {
-                                action = InventoryAction.CLONE_STACK;
-                            } else {
-                                action = InventoryAction.NOTHING;
-                            }
-                        }
-                    } else {
-                        click = ClickType.UNKNOWN;
-                        action = InventoryAction.UNKNOWN;
-                    }
-                } else if (packetplayinwindowclick.f() == 4) {
-                    if (packetplayinwindowclick.b() >= 0) {
-                        if (packetplayinwindowclick.c() == 0) {
-                            click = ClickType.DROP;
-                            Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                            if (slot != null && slot.hasItem() && slot.isAllowed(player) && slot.getItem() != null && slot.getItem().getItem() != Item.getItemOf(Blocks.AIR)) {
-                                action = InventoryAction.DROP_ONE_SLOT;
-                            } else {
-                                action = InventoryAction.NOTHING;
-                            }
-                        } else if (packetplayinwindowclick.c() == 1) {
-                            click = ClickType.CONTROL_DROP;
-                            Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
-                            if (slot != null && slot.hasItem() && slot.isAllowed(player) && slot.getItem() != null && slot.getItem().getItem() != Item.getItemOf(Blocks.AIR)) {
-                                action = InventoryAction.DROP_ALL_SLOT;
-                            } else {
-                                action = InventoryAction.NOTHING;
-                            }
-                        }
-                    } else {
-                        // Sane default (because this happens when they are holding nothing. Don't ask why.)
-                        click = ClickType.LEFT;
-                        if (packetplayinwindowclick.c() == 1) {
-                            click = ClickType.RIGHT;
-                        }
-                        action = InventoryAction.NOTHING;
-                    }
-                } else if (packetplayinwindowclick.f() == 5) {
-                    itemstack = this.player.activeContainer.clickItem(packetplayinwindowclick.b(), packetplayinwindowclick.c(), 5, this.player);
-                } else if (packetplayinwindowclick.f() == 6) {
-                    click = ClickType.DOUBLE_CLICK;
-                    action = InventoryAction.NOTHING;
-                    if (packetplayinwindowclick.b() >= 0 && this.player.inventory.getCarried() != null) {
-                        ItemStack cursor = this.player.inventory.getCarried();
-                        action = InventoryAction.NOTHING;
-                        // Quick check for if we have any of the item
-                        if (inventory.getTopInventory().contains(org.bukkit.Material.getMaterial(Item.getId(cursor.getItem()))) || inventory.getBottomInventory().contains(org.bukkit.Material.getMaterial(Item.getId(cursor.getItem())))) {
-                            action = InventoryAction.COLLECT_TO_CURSOR;
-                        }
-                    }
-                }
-                // TODO check on updates
-
-                if (packetplayinwindowclick.f() != 5) {
-                    if (click == ClickType.NUMBER_KEY) {
-                        event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
-                    } else {
-                        event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action);
-                    }
-
-                    org.bukkit.inventory.Inventory top = inventory.getTopInventory();
-                    if (packetplayinwindowclick.b() == 0 && top instanceof CraftingInventory) {
-                        org.bukkit.inventory.Recipe recipe = ((CraftingInventory) top).getRecipe();
-                        if (recipe != null) {
-                            if (click == ClickType.NUMBER_KEY) {
-                                event = new CraftItemEvent(recipe, inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
-                            } else {
-                                event = new CraftItemEvent(recipe, inventory, type, packetplayinwindowclick.b(), click, action);
-                            }
-                        }
-                    }
-
-                    event.setCancelled(cancelled);
-                    server.getPluginManager().callEvent(event);
-
-                    switch (event.getResult()) {
-                        case ALLOW:
-                        case DEFAULT:
-                            itemstack = this.player.activeContainer.clickItem(packetplayinwindowclick.b(), packetplayinwindowclick.c(), packetplayinwindowclick.f(), this.player);
-                            // PaperSpigot start - Stackable Buckets
-                            if (itemstack != null &&
-                                    ((itemstack.getItem() == Items.LAVA_BUCKET && PaperSpigotConfig.stackableLavaBuckets) ||
-                                            (itemstack.getItem() == Items.WATER_BUCKET && PaperSpigotConfig.stackableWaterBuckets) ||
-                                            (itemstack.getItem() == Items.MILK_BUCKET && PaperSpigotConfig.stackableMilkBuckets))) {
-                                if (action == InventoryAction.MOVE_TO_OTHER_INVENTORY) {
-                                    this.player.updateInventory(this.player.activeContainer);
-                                } else {
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
-                                }
-                            }
-                            // PaperSpigot end
-                            break;
-                        case DENY:
-                            /* Needs enum constructor in InventoryAction
-                            if (action.modifiesOtherSlots()) {
-
-                            } else {
-                                if (action.modifiesCursor()) {
-                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(-1, -1, this.player.inventory.getCarried()));
-                                }
-                                if (action.modifiesClicked()) {
-                                    this.player.playerConnection.sendPacket(new Packet103SetSlot(this.player.activeContainer.windowId, packet102windowclick.slot, this.player.activeContainer.getSlot(packet102windowclick.slot).getItem()));
-                                }
-                            }*/
-                            switch (action) {
-                                // Modified other slots
-                                case PICKUP_ALL:
-                                case MOVE_TO_OTHER_INVENTORY:
-                                case HOTBAR_MOVE_AND_READD:
-                                case HOTBAR_SWAP:
-                                case COLLECT_TO_CURSOR:
-                                case UNKNOWN:
-                                    this.player.updateInventory(this.player.activeContainer);
-                                    break;
-                                // Modified cursor and clicked
-                                case PICKUP_SOME:
-                                case PICKUP_HALF:
-                                case PICKUP_ONE:
-                                case PLACE_ALL:
-                                case PLACE_SOME:
-                                case PLACE_ONE:
-                                case SWAP_WITH_CURSOR:
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
-                                    break;
-                                // Modified clicked only
-                                case DROP_ALL_SLOT:
-                                case DROP_ONE_SLOT:
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
-                                    break;
-                                // Modified cursor only
-                                case DROP_ALL_CURSOR:
-                                case DROP_ONE_CURSOR:
-                                case CLONE_STACK:
-                                    this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
-                                    break;
-                                // Nothing
-                                case NOTHING:
-                                    break;
-                            }
-                            return;
-                    }
-
-                    if (event instanceof CraftItemEvent) {
-                        // Need to update the inventory on crafting to
-                        // correctly support custom recipes
-                        player.updateInventory(player.activeContainer);
-                    }
-                }
-                // CraftBukkit end
-
-                if (ItemStack.matches(packetplayinwindowclick.e(), itemstack)) {
-                    this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), true));
-                    this.player.g = true;
-                    this.player.activeContainer.b();
-                    this.player.broadcastCarriedItem();
-                    this.player.g = false;
-                } else {
-                    this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
-                    this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), false));
-                    this.player.activeContainer.a(this.player, false);
-                    ArrayList arraylist1 = Lists.newArrayList();
-
-                    for (int j = 0; j < this.player.activeContainer.c.size(); ++j) {
-                        arraylist1.add(((Slot) this.player.activeContainer.c.get(j)).getItem());
-                    }
-
-                    this.player.a(this.player.activeContainer, (List) arraylist1);
-                }
-            }
-        }
-
-    }
-
-    public void a(PacketPlayInEnchantItem packetplayinenchantitem) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinenchantitem, this, this.player.u());
-        this.player.resetIdleTimer();
-        if (this.player.activeContainer.windowId == packetplayinenchantitem.a() && this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
-            this.player.activeContainer.a(this.player, packetplayinenchantitem.b());
-            this.player.activeContainer.b();
-        }
-
-    }
-
-    public void a(PacketPlayInSetCreativeSlot packetplayinsetcreativeslot) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinsetcreativeslot, this, this.player.u());
-        if (this.player.playerInteractManager.isCreative()) {
-            boolean flag = packetplayinsetcreativeslot.a() < 0;
-            ItemStack itemstack = packetplayinsetcreativeslot.getItemStack();
-
-            if (itemstack != null && itemstack.hasTag() && itemstack.getTag().hasKeyOfType("BlockEntityTag", 10)) {
-                NBTTagCompound nbttagcompound = itemstack.getTag().getCompound("BlockEntityTag");
-
-                if (nbttagcompound.hasKey("x") && nbttagcompound.hasKey("y") && nbttagcompound.hasKey("z")) {
-                    BlockPosition blockposition = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
-                    TileEntity tileentity = this.player.world.getTileEntity(blockposition);
-
-                    if (tileentity != null) {
-                        NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-
-                        tileentity.b(nbttagcompound1);
-                        nbttagcompound1.remove("x");
-                        nbttagcompound1.remove("y");
-                        nbttagcompound1.remove("z");
-                        itemstack.a("BlockEntityTag", (NBTBase) nbttagcompound1);
-                    }
-                }
-            }
-
-            boolean flag1 = packetplayinsetcreativeslot.a() >= 1 && packetplayinsetcreativeslot.a() < 36 + PlayerInventory.getHotbarSize();
-            // CraftBukkit - Add invalidItems check
-            boolean flag2 = itemstack == null || itemstack.getItem() != null && (!invalidItems.contains(Item.getId(itemstack.getItem())) || !org.spigotmc.SpigotConfig.filterCreativeItems); // Spigot
-            boolean flag3 = itemstack == null || itemstack.getData() >= 0 && itemstack.count <= 64 && itemstack.count > 0;
-            // CraftBukkit start - Call click event
-            if (flag || (flag1 && !ItemStack.matches(this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem(), packetplayinsetcreativeslot.getItemStack()))) { // Insist on valid slot
-
-                org.bukkit.entity.HumanEntity player = this.player.getBukkitEntity();
-                InventoryView inventory = new CraftInventoryView(player, player.getInventory(), this.player.defaultContainer);
-                org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packetplayinsetcreativeslot.getItemStack());
-
-                SlotType type = SlotType.QUICKBAR;
-                if (flag) {
-                    type = SlotType.OUTSIDE;
-                } else if (packetplayinsetcreativeslot.a() < 36) {
-                    if (packetplayinsetcreativeslot.a() >= 5 && packetplayinsetcreativeslot.a() < 9) {
-                        type = SlotType.ARMOR;
-                    } else {
-                        type = SlotType.CONTAINER;
-                    }
-                }
-                InventoryCreativeEvent event = new InventoryCreativeEvent(inventory, type, flag ? -999 : packetplayinsetcreativeslot.a(), item);
-                server.getPluginManager().callEvent(event);
-
-                itemstack = CraftItemStack.asNMSCopy(event.getCursor());
-
-                switch (event.getResult()) {
-                case ALLOW:
-                    // Plugin cleared the id / stacksize checks
-                    flag2 = flag3 = true;
-                    break;
-                case DEFAULT:
-                    break;
-                case DENY:
-                    // Reset the slot
-                    if (packetplayinsetcreativeslot.a() >= 0) {
-                        this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.defaultContainer.windowId, packetplayinsetcreativeslot.a(), this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem()));
-                        this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, null));
-                    }
-                    return;
-                }
-            }
-            // CraftBukkit end
-
-            if (flag1 && flag2 && flag3) {
-                if (itemstack == null) {
-                    this.player.defaultContainer.setItem(packetplayinsetcreativeslot.a(), (ItemStack) null);
-                } else {
-                    this.player.defaultContainer.setItem(packetplayinsetcreativeslot.a(), itemstack);
-                }
-
-                this.player.defaultContainer.a(this.player, true);
-            } else if (flag && flag2 && flag3 && this.m < 200) {
-                this.m += 20;
-                EntityItem entityitem = this.player.drop(itemstack, true);
-
-                if (entityitem != null) {
-                    entityitem.j();
-                }
-            }
-        }
-
-    }
-
-    public void a(PacketPlayInTransaction packetplayintransaction) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayintransaction, this, this.player.u());
-        Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
-
-        if (oshort != null && packetplayintransaction.b() == oshort.shortValue() && this.player.activeContainer.windowId == packetplayintransaction.a() && !this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
-            this.player.activeContainer.a(this.player, true);
-        }
-
-    }
-
-    public void a(PacketPlayInUpdateSign packetplayinupdatesign) {
-        if (this.player.dead) return; // CraftBukkit
-        PlayerConnectionUtils.ensureMainThread(packetplayinupdatesign, this, this.player.u());
-        this.player.resetIdleTimer();
-        WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
-        BlockPosition blockposition = packetplayinupdatesign.a();
-
-        if (worldserver.isLoaded(blockposition)) {
-            TileEntity tileentity = worldserver.getTileEntity(blockposition);
-
-            if (!(tileentity instanceof TileEntitySign)) {
-                return;
-            }
-
-            TileEntitySign tileentitysign = (TileEntitySign) tileentity;
-
-            if (!tileentitysign.b() || tileentitysign.c() != this.player) {
-                this.minecraftServer.warning("Player " + this.player.getName() + " just tried to change non-editable sign");
-                this.sendPacket(new PacketPlayOutUpdateSign(tileentity.world, packetplayinupdatesign.a(), tileentitysign.lines)); // CraftBukkit
-                return;
-            }
-
-            IChatBaseComponent[] aichatbasecomponent = packetplayinupdatesign.b();
-
-            // CraftBukkit start
-            Player player = this.server.getPlayer(this.player);
-            int x = packetplayinupdatesign.a().getX();
-            int y = packetplayinupdatesign.a().getY();
-            int z = packetplayinupdatesign.a().getZ();
-            String[] lines = new String[4];
-
-            for (int i = 0; i < aichatbasecomponent.length; ++i) {
-                lines[i] = EnumChatFormat.a(aichatbasecomponent[i].c());
-            }
-            SignChangeEvent event = new SignChangeEvent((org.bukkit.craftbukkit.block.CraftBlock) player.getWorld().getBlockAt(x, y, z), this.server.getPlayer(this.player), lines);
-            this.server.getPluginManager().callEvent(event);
-
-            if (!event.isCancelled()) {
-                System.arraycopy(org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines()), 0, tileentitysign.lines, 0, 4);
-                tileentitysign.isEditable = false;
-             }
-            // CraftBukkit end
-
-            tileentitysign.update();
-            worldserver.notify(blockposition);
-        }
-
-    }
-
-    public void a(PacketPlayInKeepAlive packetplayinkeepalive) {
-        if (packetplayinkeepalive.a() == this.i) {
-            int i = (int) (this.d() - this.j);
-
-            this.player.ping = (this.player.ping * 3 + i) / 4;
-        }
-
-    }
-
-    private long d() {
-        return System.nanoTime() / 1000000L;
-    }
-
-    public void a(PacketPlayInAbilities packetplayinabilities) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinabilities, this, this.player.u());
-        // CraftBukkit start
-        if (this.player.abilities.canFly && this.player.abilities.isFlying != packetplayinabilities.isFlying()) {
-            PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.server.getPlayer(this.player), packetplayinabilities.isFlying());
-            this.server.getPluginManager().callEvent(event);
-            if (!event.isCancelled()) {
-                this.player.abilities.isFlying = packetplayinabilities.isFlying(); // Actually set the player's flying status
-            } else {
-                this.player.updateAbilities(); // Tell the player their ability was reverted
-            }
-        }
-        // CraftBukkit end
-    }
-
-    public void a(PacketPlayInTabComplete packetplayintabcomplete) {
-        PlayerConnectionUtils.ensureMainThread(packetplayintabcomplete, this, this.player.u());
-        // CraftBukkit start
-        if (chatSpamField.addAndGet(this, 10) > 500 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) {
-            this.disconnect("disconnect.spam");
-            return;
-        }
-        // CraftBukkit end
-        ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.minecraftServer.tabCompleteCommand(this.player, packetplayintabcomplete.a(), packetplayintabcomplete.b()).iterator();
-
-        while (iterator.hasNext()) {
-            String s = (String) iterator.next();
-
-            arraylist.add(s);
-        }
-
-        this.player.playerConnection.sendPacket(new PacketPlayOutTabComplete((String[]) arraylist.toArray(new String[arraylist.size()])));
-    }
-
-    public void a(PacketPlayInSettings packetplayinsettings) {
-        PlayerConnectionUtils.ensureMainThread(packetplayinsettings, this, this.player.u());
-        this.player.a(packetplayinsettings);
-    }
-
-    public void a(PacketPlayInCustomPayload packetplayincustompayload) {
-        PlayerConnectionUtils.ensureMainThread(packetplayincustompayload, this, this.player.u());
-        PacketDataSerializer packetdataserializer;
-        ItemStack itemstack;
-        ItemStack itemstack1;
-
-        try { // CraftBukkit
-        if ("MC|BEdit".equals(packetplayincustompayload.a())) {
-            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
-
-            try {
-                itemstack = packetdataserializer.i();
-                if (itemstack == null) {
-                    return;
-                }
-
-                if (!ItemBookAndQuill.b(itemstack.getTag())) {
-                    throw new IOException("Invalid book tag!");
-                }
-
-                itemstack1 = this.player.inventory.getItemInHand();
-                if (itemstack1 != null) {
-                    if (itemstack.getItem() == Items.WRITABLE_BOOK && itemstack.getItem() == itemstack1.getItem()) {
-                        itemstack1 = new ItemStack(Items.WRITABLE_BOOK); // CraftBukkit
-                        itemstack1.a("pages", (NBTBase) itemstack.getTag().getList("pages", 8));
-                        CraftEventFactory.handleEditBookEvent(player, itemstack1); // CraftBukkit
-                    }
-
-                    return;
-                }
-            } catch (Exception exception) {
-                PlayerConnection.c.error("Couldn\'t handle book info", exception);
-                this.disconnect("Invalid book data!"); // CraftBukkit
-                return;
-            } finally {
-                packetdataserializer.release();
-            }
-
-            return;
-        } else if ("MC|BSign".equals(packetplayincustompayload.a())) {
-            packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
-
-            try {
-                itemstack = packetdataserializer.i();
-                if (itemstack == null) {
-                    return;
-                }
-
-                if (!ItemWrittenBook.b(itemstack.getTag())) {
-                    throw new IOException("Invalid book tag!");
-                }
-
-                itemstack1 = this.player.inventory.getItemInHand();
-                if (itemstack1 != null) {
-                    if (itemstack.getItem() == Items.WRITTEN_BOOK && itemstack1.getItem() == Items.WRITABLE_BOOK) {
-                        // CraftBukkit start
-                        itemstack1 = new ItemStack(Items.WRITTEN_BOOK);
-                        itemstack1.a("author", (NBTBase) (new NBTTagString(this.player.getName())));
-                        itemstack1.a("title", (NBTBase) (new NBTTagString(itemstack.getTag().getString("title"))));
-                        itemstack1.a("pages", (NBTBase) itemstack.getTag().getList("pages", 8));
-                        itemstack1.setItem(Items.WRITTEN_BOOK);
-                        CraftEventFactory.handleEditBookEvent(player, itemstack1);
-                        // CraftBukkit end
-                    }
-
-                    return;
-                }
-            } catch (Exception exception1) {
-                PlayerConnection.c.error("Couldn\'t sign book", exception1);
-                this.disconnect("Invalid book data!"); // CraftBukkit
-                return;
-            } finally {
-                packetdataserializer.release();
-            }
-
-            return;
-        } else if ("MC|TrSel".equals(packetplayincustompayload.a())) {
-            try {
-                int i = packetplayincustompayload.b().readInt();
-                Container container = this.player.activeContainer;
-
-                if (container instanceof ContainerMerchant) {
-                    ((ContainerMerchant) container).d(i);
-                }
-            } catch (Exception exception2) {
-                PlayerConnection.c.error("Couldn\'t select trade", exception2);
-                this.disconnect("Invalid trade data!"); // CraftBukkit
-            }
-        } else if ("MC|AdvCdm".equals(packetplayincustompayload.a())) {
-            if (!this.minecraftServer.getEnableCommandBlock()) {
-                this.player.sendMessage(new ChatMessage("advMode.notEnabled", new Object[0]));
-            } else if (this.player.getBukkitEntity().isOp() && this.player.abilities.canInstantlyBuild) { // CraftBukkit - Change to Bukkit OP versus Vanilla OP
-                packetdataserializer = packetplayincustompayload.b();
-
-                try {
-                    byte b0 = packetdataserializer.readByte();
-                    CommandBlockListenerAbstract commandblocklistenerabstract = null;
-
-                    if (b0 == 0) {
-                        TileEntity tileentity = this.player.world.getTileEntity(new BlockPosition(packetdataserializer.readInt(), packetdataserializer.readInt(), packetdataserializer.readInt()));
-
-                        if (tileentity instanceof TileEntityCommand) {
-                            commandblocklistenerabstract = ((TileEntityCommand) tileentity).getCommandBlock();
-                        }
-                    } else if (b0 == 1) {
-                        Entity entity = this.player.world.a(packetdataserializer.readInt());
-
-                        if (entity instanceof EntityMinecartCommandBlock) {
-                            commandblocklistenerabstract = ((EntityMinecartCommandBlock) entity).getCommandBlock();
-                        }
-                    }
-
-                    String s = packetdataserializer.c(packetdataserializer.readableBytes());
-                    boolean flag = packetdataserializer.readBoolean();
-
-                    if (commandblocklistenerabstract != null) {
-                        commandblocklistenerabstract.setCommand(s);
-                        commandblocklistenerabstract.a(flag);
-                        if (!flag) {
-                            commandblocklistenerabstract.b((IChatBaseComponent) null);
-                        }
-
-                        commandblocklistenerabstract.h();
-                        this.player.sendMessage(new ChatMessage("advMode.setCommand.success", new Object[] { s}));
-                    }
-                } catch (Exception exception3) {
-                    PlayerConnection.c.error("Couldn\'t set command block", exception3);
-                    this.disconnect("Invalid CommandBlock data!"); // CraftBukkit
-                } finally {
-                    packetdataserializer.release();
-                }
-            } else {
-                this.player.sendMessage(new ChatMessage("advMode.notAllowed", new Object[0]));
-            }
-        } else if ("MC|Beacon".equals(packetplayincustompayload.a())) {
-            if (this.player.activeContainer instanceof ContainerBeacon) {
-                try {
-                    packetdataserializer = packetplayincustompayload.b();
-                    int j = packetdataserializer.readInt();
-                    int k = packetdataserializer.readInt();
-                    ContainerBeacon containerbeacon = (ContainerBeacon) this.player.activeContainer;
-                    Slot slot = containerbeacon.getSlot(0);
-
-                    if (slot.hasItem()) {
-                        slot.a(1);
-                        IInventory iinventory = containerbeacon.e();
-
-                        iinventory.b(1, j);
-                        iinventory.b(2, k);
-                        iinventory.update();
-                    }
-                } catch (Exception exception4) {
-                    PlayerConnection.c.error("Couldn\'t set beacon", exception4);
-                    this.disconnect("Invalid beacon data!"); // CraftBukkit
-                }
-            }
-        } else if ("MC|ItemName".equals(packetplayincustompayload.a()) && this.player.activeContainer instanceof ContainerAnvil) {
-            ContainerAnvil containeranvil = (ContainerAnvil) this.player.activeContainer;
-
-            if (packetplayincustompayload.b() != null && packetplayincustompayload.b().readableBytes() >= 1) {
-                String s1 = SharedConstants.a(packetplayincustompayload.b().c(32767));
-
-                if (s1.length() <= 30) {
-                    containeranvil.a(s1);
-                }
-            } else {
-                containeranvil.a("");
-            }
-        }
-        // CraftBukkit start
-        else if (packetplayincustompayload.a().equals("REGISTER")) {
-            String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
-            for (String channel : channels.split("\0")) {
-                getPlayer().addChannel(channel);
-            }
-        } else if (packetplayincustompayload.a().equals("UNREGISTER")) {
-            String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
-            for (String channel : channels.split("\0")) {
-                getPlayer().removeChannel(channel);
-            }
-        } else {
-            byte[] data = new byte[packetplayincustompayload.b().readableBytes()];
-            packetplayincustompayload.b().readBytes(data);
-            server.getMessenger().dispatchIncomingMessage(player.getBukkitEntity(), packetplayincustompayload.a(), data);
-        }
-        // CraftBukkit end
-        // CraftBukkit start
-        } finally {
-            if (packetplayincustompayload.b().refCnt() > 0) {
-                packetplayincustompayload.b().release();
-            }
-        }
-        // CraftBukkit end
-    }
-
-    // CraftBukkit start - Add "isDisconnected" method
-    public boolean isDisconnected() { // Spigot
-        return !this.player.joining && !this.networkManager.channel.config().isAutoRead();
-    }
-
-    static class SyntheticClass_1 {
-
-        static final int[] a;
-        static final int[] b;
-        static final int[] c = new int[PacketPlayInClientCommand.EnumClientCommand.values().length];
-
-        static {
-            try {
-                PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.PERFORM_RESPAWN.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.REQUEST_STATS.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror1) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.OPEN_INVENTORY_ACHIEVEMENT.ordinal()] = 3;
-            } catch (NoSuchFieldError nosuchfielderror2) {
-                ;
-            }
-
-            b = new int[PacketPlayInEntityAction.EnumPlayerAction.values().length];
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.START_SNEAKING.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror3) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SNEAKING.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror4) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.START_SPRINTING.ordinal()] = 3;
-            } catch (NoSuchFieldError nosuchfielderror5) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SPRINTING.ordinal()] = 4;
-            } catch (NoSuchFieldError nosuchfielderror6) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SLEEPING.ordinal()] = 5;
-            } catch (NoSuchFieldError nosuchfielderror7) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.RIDING_JUMP.ordinal()] = 6;
-            } catch (NoSuchFieldError nosuchfielderror8) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.OPEN_INVENTORY.ordinal()] = 7;
-            } catch (NoSuchFieldError nosuchfielderror9) {
-                ;
-            }
-
-            a = new int[PacketPlayInBlockDig.EnumPlayerDigType.values().length];
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.DROP_ITEM.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror10) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.DROP_ALL_ITEMS.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror11) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.RELEASE_USE_ITEM.ordinal()] = 3;
-            } catch (NoSuchFieldError nosuchfielderror12) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK.ordinal()] = 4;
-            } catch (NoSuchFieldError nosuchfielderror13) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.ABORT_DESTROY_BLOCK.ordinal()] = 5;
-            } catch (NoSuchFieldError nosuchfielderror14) {
-                ;
-            }
-
-            try {
-                PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.STOP_DESTROY_BLOCK.ordinal()] = 6;
-            } catch (NoSuchFieldError nosuchfielderror15) {
-                ;
-            }
-
-        }
-    }
+	private static final Logger c = LogManager.getLogger();
+	public final NetworkManager networkManager;
+	private final MinecraftServer minecraftServer;
+	public EntityPlayer player;
+	private int e;
+	private int f;
+	private int g;
+	private boolean h;
+	private int i;
+	private long j;
+	private long k;
+	private volatile int chatThrottle;
+	private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
+	private int m;
+	private IntHashMap<Short> n = new IntHashMap();
+	private double o;
+	private double p;
+	private double q;
+	public boolean checkMovement = true;
+	private int lastSwingTick;
+	private int swings;
+	private int sequentialSwingRateLimits;
+	private int lastSequentialSwingTick;
+	private int forwardSwingTick;
+	private boolean processedDisconnect;
+
+	public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
+		this.minecraftServer = minecraftserver;
+		this.networkManager = networkmanager;
+
+		networkmanager.a(this);
+
+		this.player = entityplayer;
+
+		entityplayer.playerConnection = this;
+
+		this.server = minecraftserver.server;
+	}
+
+	private final org.bukkit.craftbukkit.CraftServer server;
+	private int lastTick = MinecraftServer.currentTick;
+	private int lastDropTick = MinecraftServer.currentTick;
+	private int dropCount = 0;
+	private static final int SURVIVAL_PLACE_DISTANCE_SQUARED = 6 * 6;
+	private static final int CREATIVE_PLACE_DISTANCE_SQUARED = 7 * 7;
+
+	private double lastPosX = Double.MAX_VALUE;
+	private double lastPosY = Double.MAX_VALUE;
+	private double lastPosZ = Double.MAX_VALUE;
+	private float lastPitch = Float.MAX_VALUE;
+	private float lastYaw = Float.MAX_VALUE;
+	private boolean justTeleported = false;
+	private boolean hasMoved;
+
+	public CraftPlayer getPlayer() {
+		return (this.player == null) ? null : this.player.getBukkitEntity();
+	}
+
+	private final static HashSet<Integer> invalidItems = new HashSet<>(java.util.Arrays.asList(8, 9, 10, 11, 26, 34, 36, 43, 51, 52, 55, 59, 60, 62, 63, 64, 68, 71, 74, 75, 83, 90, 92, 93, 94, 104, 105, 115, 117, 118, 119, 125, 127, 132, 140, 141, 142, 144)); // TODO: Check after every update.
+
+	public void c() {
+		this.h = false;
+
+		++this.e;
+
+		this.minecraftServer.methodProfiler.a("keepAlive");
+
+		if ((long) this.e - this.k > 40L) {
+			this.k = (long) this.e;
+			this.j = this.d();
+			this.i = (int) this.j;
+			this.sendPacket(new PacketPlayOutKeepAlive(this.i));
+		}
+
+		this.minecraftServer.methodProfiler.b();
+
+		for (int spam; (spam = this.chatThrottle) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
+
+		if (this.m > 0) {
+			--this.m;
+		}
+
+		if (this.player.D() > 0L && this.minecraftServer.getIdleTimeout() > 0 && MinecraftServer.az() - this.player.D() > (long) (this.minecraftServer.getIdleTimeout() * 1000 * 60)) {
+			this.player.resetIdleTimer();
+			this.disconnect("You have been idle for too long!");
+		}
+	}
+
+	public NetworkManager a() {
+		return this.networkManager;
+	}
+
+	public void disconnect(String s) {
+		String leaveMessage = EnumChatFormat.YELLOW + this.player.getName() + " left the game.";
+
+		PlayerKickEvent event = new PlayerKickEvent(this.server.getPlayer(this.player), s, leaveMessage);
+
+		if (this.server.getServer().isRunning()) {
+			this.server.getPluginManager().callEvent(event);
+		}
+
+		if (event.isCancelled()) {
+			return;
+		}
+
+		s = event.getReason();
+
+		final ChatComponentText chatcomponenttext = new ChatComponentText(s);
+
+		this.networkManager.a(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener() {
+			public void operationComplete(Future future) throws Exception { // CraftBukkit - fix decompile error
+				PlayerConnection.this.networkManager.close(chatcomponenttext);
+			}
+		}, new GenericFutureListener[0]);
+
+		this.a(chatcomponenttext);
+		this.networkManager.k();
+
+		this.minecraftServer.postToMainThread(new Runnable() {
+			public void run() {
+				PlayerConnection.this.networkManager.l();
+			}
+		});
+	}
+
+	public void a(PacketPlayInSteerVehicle packetplayinsteervehicle) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinsteervehicle, this, this.player.u());
+		this.player.a(packetplayinsteervehicle.a(), packetplayinsteervehicle.b(), packetplayinsteervehicle.c(), packetplayinsteervehicle.d());
+	}
+
+	private boolean b(PacketPlayInFlying packetplayinflying) {
+		return !Doubles.isFinite(packetplayinflying.a()) || !Doubles.isFinite(packetplayinflying.b()) || !Doubles.isFinite(packetplayinflying.c()) || !Floats.isFinite(packetplayinflying.e()) || !Floats.isFinite(packetplayinflying.d());
+	}
+
+	public void a(PacketPlayInFlying packetplayinflying) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinflying, this, this.player.u());
+
+		if (this.b(packetplayinflying)) {
+			this.disconnect("Invalid move packet received");
+		} else {
+			WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
+
+			this.h = true;
+			if (!this.player.viewingCredits) {
+				double d0 = this.player.locX;
+				double d1 = this.player.locY;
+				double d2 = this.player.locZ;
+				double d3 = 0.0D;
+				double d4 = packetplayinflying.a() - this.o;
+				double d5 = packetplayinflying.b() - this.p;
+				double d6 = packetplayinflying.c() - this.q;
+
+				if (packetplayinflying.g()) {
+					d3 = d4 * d4 + d5 * d5 + d6 * d6;
+					if (!this.checkMovement && d3 < 0.25D) {
+						this.checkMovement = true;
+					}
+				}
+
+				Player player = this.getPlayer();
+
+				if (!hasMoved) {
+					Location curPos = player.getLocation();
+					lastPosX = curPos.getX();
+					lastPosY = curPos.getY();
+					lastPosZ = curPos.getZ();
+					lastYaw = curPos.getYaw();
+					lastPitch = curPos.getPitch();
+					hasMoved = true;
+				}
+
+				Location from = new Location(player.getWorld(), lastPosX, lastPosY, lastPosZ, lastYaw, lastPitch);
+				Location to = player.getLocation().clone();
+
+				if (packetplayinflying.hasPos && !(packetplayinflying.hasPos && packetplayinflying.y == -999.0D)) {
+					to.setX(packetplayinflying.x);
+					to.setY(packetplayinflying.y);
+					to.setZ(packetplayinflying.z);
+				}
+
+				if (packetplayinflying.hasLook) {
+					to.setYaw(packetplayinflying.yaw);
+					to.setPitch(packetplayinflying.pitch);
+				}
+
+				double delta = Math.pow(this.lastPosX - to.getX(), 2) + Math.pow(this.lastPosY - to.getY(), 2) + Math.pow(this.lastPosZ - to.getZ(), 2);
+				float deltaAngle = Math.abs(this.lastYaw - to.getYaw()) + Math.abs(this.lastPitch - to.getPitch());
+
+				if (packetplayinflying.hasPos && delta > 0.0D && this.checkMovement && !this.player.dead) {
+					for (MovementHandler handler : PotionSpigot.INSTANCE.getMovementHandlers()) {
+						try {
+							handler.handleUpdateLocation(player, to, from, packetplayinflying);
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					}
+				}
+
+				if (packetplayinflying.hasLook && deltaAngle > 0.0F && this.checkMovement && !this.player.dead) {
+					for (MovementHandler handler : PotionSpigot.INSTANCE.getMovementHandlers()) {
+						try {
+							handler.handleUpdateRotation(player, to, from, packetplayinflying);
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					}
+				}
+
+				if (((packetplayinflying.hasPos && delta > 0.0D) || (packetplayinflying.hasLook && deltaAngle > 0.0F)) && (this.checkMovement && !this.player.dead)) {
+					this.lastPosX = to.getX();
+					this.lastPosY = to.getY();
+					this.lastPosZ = to.getZ();
+					this.lastYaw = to.getYaw();
+					this.lastPitch = to.getPitch();
+
+					if (PotionSpigot.INSTANCE.getConfig().isFirePlayerMoveEvent()) {
+						Location oldTo = to.clone();
+						PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+						this.server.getPluginManager().callEvent(event);
+
+						if (event.isCancelled()) {
+							this.player.playerConnection.sendPacket(new PacketPlayOutPosition(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch(), Collections.<PacketPlayOutPosition.EnumPlayerTeleportFlags>emptySet()));
+							return;
+						}
+
+						if (!oldTo.equals(event.getTo()) && !event.isCancelled()) {
+							this.player.getBukkitEntity().teleport(event.getTo(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
+							return;
+						}
+
+						if (!from.equals(this.getPlayer().getLocation()) && this.justTeleported) {
+							this.justTeleported = false;
+							return;
+						}
+					}
+				}
+
+				if (this.checkMovement && !this.player.dead) {
+					this.f = this.e;
+					double d7;
+					double d8;
+					double d9;
+
+					if (this.player.vehicle != null) {
+						float f = this.player.yaw;
+						float f1 = this.player.pitch;
+
+						this.player.vehicle.al();
+
+						d7 = this.player.locX;
+						d8 = this.player.locY;
+						d9 = this.player.locZ;
+
+						if (packetplayinflying.h()) {
+							f = packetplayinflying.d();
+							f1 = packetplayinflying.e();
+						}
+
+						this.player.onGround = packetplayinflying.f();
+						this.player.l();
+						this.player.setLocation(d7, d8, d9, f, f1);
+
+						if (this.player.vehicle != null) {
+							this.player.vehicle.al();
+						}
+
+						this.minecraftServer.getPlayerList().d(this.player);
+
+						if (this.player.vehicle != null) {
+							this.player.vehicle.ai = true;
+
+							if (d3 > 4.0D) {
+								Entity entity = this.player.vehicle;
+
+								this.player.playerConnection.sendPacket(new PacketPlayOutEntityTeleport(entity));
+								this.a(this.player.locX, this.player.locY, this.player.locZ, this.player.yaw, this.player.pitch);
+							}
+						}
+
+						if (this.checkMovement) {
+							this.o = this.player.locX;
+							this.p = this.player.locY;
+							this.q = this.player.locZ;
+						}
+
+						worldserver.g(this.player);
+
+						return;
+					}
+
+					if (this.player.isSleeping()) {
+						this.player.l();
+						this.player.setLocation(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
+						worldserver.g(this.player);
+						return;
+					}
+
+					double d10 = this.player.locY;
+
+					this.o = this.player.locX;
+					this.p = this.player.locY;
+					this.q = this.player.locZ;
+					d7 = this.player.locX;
+					d8 = this.player.locY;
+					d9 = this.player.locZ;
+					float f2 = this.player.yaw;
+					float f3 = this.player.pitch;
+
+					if (packetplayinflying.g() && packetplayinflying.b() == -999.0D) {
+						packetplayinflying.a(false);
+					}
+
+					if (packetplayinflying.g()) {
+						d7 = packetplayinflying.a();
+						d8 = packetplayinflying.b();
+						d9 = packetplayinflying.c();
+						if (Math.abs(packetplayinflying.a()) > 3.0E7D || Math.abs(packetplayinflying.c()) > 3.0E7D) {
+							this.disconnect("Illegal position");
+							return;
+						}
+					}
+
+					EntityPlayer entityPlayer = ((CraftPlayer) player).getHandle();
+					if (packetplayinflying.h() && !entityPlayer.isFakingDeath() && entityPlayer.getDataWatcher().getFloat(6) > 0.0F) {
+						f2 = packetplayinflying.d();
+						f3 = packetplayinflying.e();
+					}
+
+					this.player.l();
+					this.player.setLocation(this.o, this.p, this.q, f2, f3);
+					if (!this.checkMovement) {
+						return;
+					}
+
+					double d11 = d7 - this.player.locX;
+					double d12 = d8 - this.player.locY;
+					double d13 = d9 - this.player.locZ;
+					double d14 = this.player.motX * this.player.motX + this.player.motY * this.player.motY + this.player.motZ * this.player.motZ;
+					double d15 = d11 * d11 + d12 * d12 + d13 * d13;
+
+					if (d15 - d14 > org.spigotmc.SpigotConfig.movedTooQuicklyThreshold && this.checkMovement && (!this.minecraftServer.T() || !this.minecraftServer.S().equals(this.player.getName()))) { // CraftBukkit - Added this.checkMovement condition to solve this check being triggered by teleports
+						PlayerConnection.c.warn(this.player.getName() + " moved too quickly! " + d11 + "," + d12 + "," + d13 + " (" + d11 + ", " + d12 + ", " + d13 + ")");
+						this.a(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
+						return;
+					}
+
+					float f4 = 0.0625F;
+					boolean flag = worldserver.getCubes(this.player, this.player.getBoundingBox().shrink((double) f4, (double) f4, (double) f4)).isEmpty();
+
+					if (this.player.onGround && !packetplayinflying.f() && d12 > 0.0D) {
+						this.player.bF();
+					}
+
+					this.player.move(d11, d12, d13);
+					this.player.onGround = packetplayinflying.f();
+					double d16 = d12;
+
+					d11 = d7 - this.player.locX;
+					d12 = d8 - this.player.locY;
+
+					if (d12 > -0.5D || d12 < 0.5D) {
+						d12 = 0.0D;
+					}
+
+					d13 = d9 - this.player.locZ;
+					d15 = d11 * d11 + d12 * d12 + d13 * d13;
+					boolean flag1 = false;
+
+					if (d15 > org.spigotmc.SpigotConfig.movedWronglyThreshold && !this.player.isSleeping() && !this.player.playerInteractManager.isCreative()) {
+						flag1 = true;
+						PlayerConnection.c.warn(this.player.getName() + " moved wrongly!");
+					}
+
+					this.player.setLocation(d7, d8, d9, f2, f3);
+					this.player.checkMovement(this.player.locX - d0, this.player.locY - d1, this.player.locZ - d2);
+
+					if (!this.player.noclip) {
+						boolean flag2 = worldserver.getCubes(this.player, this.player.getBoundingBox().shrink((double) f4, (double) f4, (double) f4)).isEmpty();
+
+						if (flag && (flag1 || !flag2) && !this.player.isSleeping()) {
+							this.a(this.o, this.p, this.q, f2, f3);
+							return;
+						}
+					}
+
+					AxisAlignedBB axisalignedbb = this.player.getBoundingBox().grow((double) f4, (double) f4, (double) f4).a(0.0D, -0.55D, 0.0D);
+
+					if (!this.minecraftServer.getAllowFlight() && !this.player.abilities.canFly && !worldserver.c(axisalignedbb)) {
+						if (d16 >= -0.03125D) {
+							++this.g;
+
+							if (this.g > 80) {
+								PlayerConnection.c.warn(this.player.getName() + " was kicked for floating too long!");
+								this.disconnect("Flying is not enabled on this server");
+								return;
+							}
+						}
+					} else {
+						this.g = 0;
+					}
+
+					this.player.onGround = packetplayinflying.f();
+					this.minecraftServer.getPlayerList().d(this.player);
+					this.player.a(this.player.locY - d10, packetplayinflying.f());
+				} else if (this.e - this.f > 20) {
+					this.a(this.o, this.p, this.q, this.player.yaw, this.player.pitch);
+				}
+			}
+
+		}
+	}
+
+	public void a(double d0, double d1, double d2, float f, float f1) {
+		this.a(d0, d1, d2, f, f1, Collections.emptySet());
+	}
+
+	public void a(double d0, double d1, double d2, float f, float f1, Set<PacketPlayOutPosition.EnumPlayerTeleportFlags> set) {
+		Player player = this.getPlayer();
+		Location from = player.getLocation();
+
+		double x = d0;
+		double y = d1;
+		double z = d2;
+		float yaw = f;
+		float pitch = f1;
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X)) {
+			x += from.getX();
+		}
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y)) {
+			y += from.getY();
+		}
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Z)) {
+			z += from.getZ();
+		}
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y_ROT)) {
+			yaw += from.getYaw();
+		}
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X_ROT)) {
+			pitch += from.getPitch();
+		}
+
+
+		Location to = new Location(this.getPlayer().getWorld(), x, y, z, yaw, pitch);
+		PlayerTeleportEvent event = new PlayerTeleportEvent(player, from.clone(), to.clone(), PlayerTeleportEvent.TeleportCause.UNKNOWN);
+		this.server.getPluginManager().callEvent(event);
+
+		if (event.isCancelled() || to.equals(event.getTo())) {
+			set.clear();
+			to = event.isCancelled() ? event.getFrom() : event.getTo();
+			d0 = to.getX();
+			d1 = to.getY();
+			d2 = to.getZ();
+			f = to.getYaw();
+			f1 = to.getPitch();
+		}
+
+		this.internalTeleport(d0, d1, d2, f, f1, set);
+	}
+
+	public void teleport(Location dest) {
+		internalTeleport(dest.getX(), dest.getY(), dest.getZ(), dest.getYaw(), dest.getPitch(), Collections.emptySet());
+	}
+
+	private void internalTeleport(double d0, double d1, double d2, float f, float f1, Set set) {
+		if (Float.isNaN(f)) {
+			f = 0;
+		}
+
+		if (Float.isNaN(f1)) {
+			f1 = 0;
+		}
+
+		this.justTeleported = true;
+		this.checkMovement = false;
+		this.o = d0;
+		this.p = d1;
+		this.q = d2;
+
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X)) {
+			this.o += this.player.locX;
+		}
+
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y)) {
+			this.p += this.player.locY;
+		}
+
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Z)) {
+			this.q += this.player.locZ;
+		}
+
+		float f2 = f;
+		float f3 = f1;
+
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.Y_ROT)) {
+			f2 = f + this.player.yaw;
+		}
+
+		if (set.contains(PacketPlayOutPosition.EnumPlayerTeleportFlags.X_ROT)) {
+			f3 = f1 + this.player.pitch;
+		}
+
+		this.lastPosX = this.o;
+		this.lastPosY = this.p;
+		this.lastPosZ = this.q;
+		this.lastYaw = f2;
+		this.lastPitch = f3;
+
+		this.player.setLocation(this.o, this.p, this.q, f2, f3);
+		this.player.playerConnection.sendPacket(new PacketPlayOutPosition(d0, d1, d2, f, f1, set));
+	}
+
+	public void a(PacketPlayInBlockDig packetplayinblockdig) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinblockdig, this, this.player.u());
+		if (this.player.dead) return;
+		WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
+		BlockPosition blockposition = packetplayinblockdig.a();
+
+		this.player.resetIdleTimer();
+
+		switch (PlayerConnection.SyntheticClass_1.a[packetplayinblockdig.c().ordinal()]) {
+			case 1: // DROP_ITEM
+				if (!this.player.isSpectator()) {
+					if (this.lastDropTick != MinecraftServer.currentTick) {
+						this.dropCount = 0;
+						this.lastDropTick = MinecraftServer.currentTick;
+					} else {
+						this.dropCount++;
+
+						if (this.dropCount >= 20) {
+							this.c.warn(this.player.getName() + " dropped their items too quickly!");
+							this.disconnect("You dropped your items too quickly (Hacking?)");
+							return;
+						}
+					}
+
+					this.player.a(false);
+				}
+
+				return;
+
+			case 2: // DROP_ALL_ITEMS
+				if (!this.player.isSpectator()) {
+					this.player.a(true);
+				}
+
+				return;
+
+			case 3: // RELEASE_USE_ITEM
+				this.player.bU();
+				return;
+
+			case 4: // START_DESTROY_BLOCK
+			case 5: // ABORT_DESTROY_BLOCK
+			case 6: // STOP_DESTROY_BLOCK
+				double d0 = this.player.locX - ((double) blockposition.getX() + 0.5D);
+				double d1 = this.player.locY - ((double) blockposition.getY() + 0.5D) + 1.5D;
+				double d2 = this.player.locZ - ((double) blockposition.getZ() + 0.5D);
+				double d3 = d0 * d0 + d1 * d1 + d2 * d2;
+
+				if (d3 > 36.0D) {
+					this.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
+					return;
+				} else if (blockposition.getY() >= this.minecraftServer.getMaxBuildHeight()) {
+					return;
+				} else {
+					if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK) {
+						if (!this.minecraftServer.a(worldserver, blockposition, this.player) && worldserver.getWorldBorder().a(blockposition)) {
+							this.player.playerInteractManager.a(blockposition, packetplayinblockdig.b());
+						} else {
+							if (PotionSpigot.INSTANCE.getConfig().isFireLeftClickBlock()) {
+								CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, blockposition, packetplayinblockdig.b(), this.player.inventory.getItemInHand());
+							}
+
+							this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
+
+							TileEntity tileentity = worldserver.getTileEntity(blockposition);
+
+							if (tileentity != null) {
+								this.player.playerConnection.sendPacket(tileentity.getUpdatePacket());
+							}
+						}
+					} else {
+						if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.STOP_DESTROY_BLOCK) {
+							this.player.playerInteractManager.a(blockposition);
+						} else if (packetplayinblockdig.c() == PacketPlayInBlockDig.EnumPlayerDigType.ABORT_DESTROY_BLOCK) {
+							this.player.playerInteractManager.e();
+						}
+
+						if (worldserver.getType(blockposition).getBlock().getMaterial() != Material.AIR) {
+							this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
+						}
+					}
+
+					return;
+				}
+
+			default:
+				throw new IllegalArgumentException("Invalid player action");
+		}
+	}
+
+	private long lastPlace = -1;
+	private int packets = 0;
+
+	public void a(PacketPlayInBlockPlace packetplayinblockplace) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinblockplace, this, this.player.u());
+		WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
+		boolean throttled = false;
+
+		if (org.github.paperspigot.PaperSpigotConfig.interactLimitEnabled && lastPlace != -1 && packetplayinblockplace.timestamp - lastPlace < 30 && packets++ >= 4) {
+			throttled = true;
+		} else if (packetplayinblockplace.timestamp - lastPlace >= 30 || lastPlace == -1) {
+			lastPlace = packetplayinblockplace.timestamp;
+			packets = 0;
+		}
+
+		if (this.player.dead) return;
+
+		boolean always = false;
+
+		ItemStack itemstack = this.player.inventory.getItemInHand();
+		boolean flag = false;
+		BlockPosition blockposition = packetplayinblockplace.a();
+		EnumDirection enumdirection = EnumDirection.fromType1(packetplayinblockplace.getFace());
+
+		this.player.resetIdleTimer();
+		if (packetplayinblockplace.getFace() == 255) {
+			if (itemstack == null) {
+				return;
+			}
+
+			int itemstackAmount = itemstack.count;
+
+			if (!throttled) {
+				boolean cancelled = false;
+
+				if (packetplayinblockplace.getFace() == 255) {
+					org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemstack);
+					cancelled = event.useItemInHand() == Event.Result.DENY;
+				} else {
+					if (player.playerInteractManager.firedInteract) {
+						player.playerInteractManager.firedInteract = false;
+						cancelled = player.playerInteractManager.interactResult;
+					} else {
+						EnumDirection enumDirection = NotchUtil.getDirection(
+								this.player.pitch,
+								this.player.yaw,
+								this.player.locX,
+								this.player.locY + this.player.getHeadHeight(),
+								this.player.locZ,
+								player.playerInteractManager.getGameMode()
+						);
+
+						org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(player, Action.RIGHT_CLICK_BLOCK,
+								packetplayinblockplace.a(), itemstack, true, enumDirection);
+						cancelled = event.useItemInHand() == Event.Result.DENY;
+					}
+				}
+
+				if (!cancelled) {
+					this.player.playerInteractManager.useItem(this.player, this.player.world, itemstack);
+				}
+			}
+
+			always = (itemstack.count != itemstackAmount) || itemstack.getItem() == Item.getItemOf(Blocks.WATERLILY);
+		} else if (blockposition.getY() >= this.minecraftServer.getMaxBuildHeight() - 1 && (enumdirection == EnumDirection.UP || blockposition.getY() >= this.minecraftServer.getMaxBuildHeight())) {
+			ChatMessage chatmessage = new ChatMessage("build.tooHigh", this.minecraftServer.getMaxBuildHeight());
+
+			chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
+			this.player.playerConnection.sendPacket(new PacketPlayOutChat(chatmessage));
+
+			flag = true;
+		} else {
+			Location eyeLoc = this.getPlayer().getEyeLocation();
+			double reachDistance = NumberConversions.square(eyeLoc.getX() - blockposition.getX()) + NumberConversions.square(eyeLoc.getY() - blockposition.getY()) + NumberConversions.square(eyeLoc.getZ() - blockposition.getZ());
+
+			if (reachDistance > (this.getPlayer().getGameMode() == org.bukkit.GameMode.CREATIVE ? CREATIVE_PLACE_DISTANCE_SQUARED : SURVIVAL_PLACE_DISTANCE_SQUARED)) {
+				return;
+			}
+
+			if (!worldserver.getWorldBorder().a(blockposition)) {
+				return;
+			}
+
+			if (this.checkMovement && this.player.e((double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D) < 64.0D && !this.minecraftServer.a(worldserver, blockposition, this.player) && worldserver.getWorldBorder().a(blockposition)) {
+				always = throttled || !this.player.playerInteractManager.interact(this.player, worldserver, itemstack, blockposition, enumdirection, packetplayinblockplace.d(), packetplayinblockplace.e(), packetplayinblockplace.f());
+			}
+
+			flag = true;
+		}
+
+		if (flag) {
+			this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition));
+			this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(worldserver, blockposition.shift(enumdirection)));
+		}
+
+		itemstack = this.player.inventory.getItemInHand();
+
+		if (itemstack != null && itemstack.count == 0) {
+			this.player.inventory.items[this.player.inventory.itemInHandIndex] = null;
+
+			itemstack = null;
+		}
+
+		if (itemstack == null || itemstack.l() == 0) {
+			this.player.g = true;
+			this.player.inventory.items[this.player.inventory.itemInHandIndex] = ItemStack.b(this.player.inventory.items[this.player.inventory.itemInHandIndex]);
+			Slot slot = this.player.activeContainer.getSlot(this.player.inventory, this.player.inventory.itemInHandIndex);
+
+			this.player.activeContainer.b();
+
+			this.player.g = false;
+
+			if (!ItemStack.matches(this.player.inventory.getItemInHand(), packetplayinblockplace.getItemStack()) || always) {
+				this.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, slot.rawSlotIndex, this.player.inventory.getItemInHand()));
+			}
+		}
+
+	}
+
+	public void a(PacketPlayInSpectate packetplayinspectate) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinspectate, this, this.player.u());
+
+		if (this.player.isSpectator()) {
+			Entity entity = null;
+
+			for (WorldServer worldserver : minecraftServer.worlds) {
+				if (worldserver != null) {
+					entity = packetplayinspectate.a(worldserver);
+					if (entity != null) {
+						break;
+					}
+				}
+			}
+
+			if (entity != null) {
+				this.player.setSpectatorTarget(this.player);
+				this.player.mount(null);
+				this.player.getBukkitEntity().teleport(entity.getBukkitEntity(), PlayerTeleportEvent.TeleportCause.SPECTATE);
+			}
+		}
+
+	}
+
+	public void a(PacketPlayInResourcePackStatus packetplayinresourcepackstatus) {
+		this.server.getPluginManager().callEvent(new PlayerResourcePackStatusEvent(getPlayer(), PlayerResourcePackStatusEvent.Status.values()[packetplayinresourcepackstatus.b.ordinal()]));
+	}
+
+	public void a(IChatBaseComponent ichatbasecomponent) {
+		if (this.processedDisconnect) {
+			return;
+		} else {
+			this.processedDisconnect = true;
+		}
+
+		PlayerConnection.c.info(this.player.getName() + " lost connection: " + ichatbasecomponent.c());
+		this.player.q();
+
+		String quitMessage = this.minecraftServer.getPlayerList().disconnect(this.player);
+
+		if ((quitMessage != null) && (quitMessage.length() > 0)) {
+			this.minecraftServer.getPlayerList().sendMessage(CraftChatMessage.fromString(quitMessage));
+		}
+
+		if (this.minecraftServer.T() && this.player.getName().equals(this.minecraftServer.S())) {
+			this.minecraftServer.safeShutdown();
+		}
+
+	}
+
+	public void sendPacket(final Packet packet) {
+		if (packet instanceof PacketPlayOutChat) {
+			PacketPlayOutChat packetplayoutchat = (PacketPlayOutChat) packet;
+			EntityHuman.EnumChatVisibility chatVisibility = this.player.getChatFlags();
+
+			if (chatVisibility == EntityHuman.EnumChatVisibility.HIDDEN) {
+				return;
+			}
+
+			if (chatVisibility == EntityHuman.EnumChatVisibility.SYSTEM && !packetplayoutchat.b()) {
+				return;
+			}
+		}
+
+		if (packet == null || this.processedDisconnect) {
+			return;
+		} else if (packet instanceof PacketPlayOutSpawnPosition) {
+			PacketPlayOutSpawnPosition packet6 = (PacketPlayOutSpawnPosition) packet;
+			this.player.compassTarget = new Location(this.getPlayer().getWorld(), packet6.position.getX(), packet6.position.getY(), packet6.position.getZ());
+		}
+
+		try {
+			this.networkManager.handle(packet);
+
+			for (PacketHandler handler : PotionSpigot.INSTANCE.getPacketHandlers()) {
+				try {
+					handler.handleSentPacket(this, packet);
+				} catch (Exception e) {
+					e.printStackTrace();
+				}
+			}
+		} catch (Throwable throwable) {
+			CrashReport crashreport = CrashReport.a(throwable, "Sending packet");
+			CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Packet being sent");
+
+			crashreportsystemdetails.a("Packet class", new Callable() {
+				public String a() throws Exception {
+					return packet.getClass().getCanonicalName();
+				}
+
+				public Object call() throws Exception {
+					return this.a();
+				}
+			});
+			throw new ReportedException(crashreport);
+		}
+	}
+
+	public void a(PacketPlayInHeldItemSlot packetplayinhelditemslot) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayinhelditemslot, this, this.player.u());
+
+		if (packetplayinhelditemslot.a() >= 0 && packetplayinhelditemslot.a() < PlayerInventory.getHotbarSize()) {
+			PlayerItemHeldEvent event = new PlayerItemHeldEvent(this.getPlayer(), this.player.inventory.itemInHandIndex, packetplayinhelditemslot.a());
+			this.server.getPluginManager().callEvent(event);
+
+			if (event.isCancelled()) {
+				this.sendPacket(new PacketPlayOutHeldItemSlot(this.player.inventory.itemInHandIndex));
+				this.player.resetIdleTimer();
+				return;
+			}
+
+			this.player.inventory.itemInHandIndex = packetplayinhelditemslot.a();
+			this.player.resetIdleTimer();
+		} else {
+			PlayerConnection.c.warn(this.player.getName() + " tried to set an invalid carried item");
+			this.disconnect("Invalid hotbar selection (Hacking?)");
+		}
+	}
+
+	public void a(PacketPlayInChat packetplayinchat) {
+		boolean isSync = packetplayinchat.a().startsWith("/");
+
+		if (packetplayinchat.a().startsWith("/")) {
+			PlayerConnectionUtils.ensureMainThread(packetplayinchat, this, this.player.u());
+		}
+
+		if (this.player.dead || this.player.getChatFlags() == EntityHuman.EnumChatVisibility.HIDDEN) {
+			ChatMessage chatmessage = new ChatMessage("chat.cannotSend", new Object[0]);
+
+			chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
+			this.sendPacket(new PacketPlayOutChat(chatmessage));
+		} else {
+			this.player.resetIdleTimer();
+			String s = packetplayinchat.a();
+
+			s = StringUtils.normalizeSpace(s);
+
+			for (int i = 0; i < s.length(); ++i) {
+				if (!SharedConstants.isAllowedChatCharacter(s.charAt(i))) {
+					if (!isSync) {
+						Waitable waitable = new Waitable() {
+							@Override
+							protected Object evaluate() {
+								PlayerConnection.this.disconnect("Illegal characters in chat");
+								return null;
+							}
+						};
+
+						this.minecraftServer.processQueue.add(waitable);
+
+						try {
+							waitable.get();
+						} catch (InterruptedException e) {
+							Thread.currentThread().interrupt();
+						} catch (ExecutionException e) {
+							throw new RuntimeException(e);
+						}
+					} else {
+						this.disconnect("Illegal characters in chat");
+					}
+
+					return;
+				}
+			}
+
+			if (isSync) {
+				try {
+					this.minecraftServer.server.playerCommandState = true;
+					this.handleCommand(s);
+				} finally {
+					this.minecraftServer.server.playerCommandState = false;
+				}
+			} else if (s.isEmpty()) {
+				c.warn(this.player.getName() + " tried to send an empty message");
+			} else if (getPlayer().isConversing()) {
+				final String message = s;
+				this.minecraftServer.processQueue.add(new Waitable() {
+					@Override
+					protected Object evaluate() {
+						getPlayer().acceptConversationInput(message);
+						return null;
+					}
+				});
+			} else if (this.player.getChatFlags() == EntityHuman.EnumChatVisibility.SYSTEM) {
+				ChatMessage chatmessage = new ChatMessage("chat.cannotSend", new Object[0]);
+
+				chatmessage.getChatModifier().setColor(EnumChatFormat.RED);
+				this.sendPacket(new PacketPlayOutChat(chatmessage));
+			} else if (true) {
+				this.chat(s, true);
+			} else {
+				ChatMessage chatmessage1 = new ChatMessage("chat.type.text", new Object[]{this.player.getScoreboardDisplayName(), s});
+
+				this.minecraftServer.getPlayerList().sendMessage(chatmessage1, false);
+			}
+
+			boolean counted = true;
+
+			for (String exclude : org.spigotmc.SpigotConfig.spamExclusions) {
+				if (exclude != null && s.startsWith(exclude)) {
+					counted = false;
+					break;
+				}
+			}
+
+			if (counted && chatSpamField.addAndGet(this, 20) > 60 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) { // Spigot
+				if (!isSync) {
+					Waitable waitable = new Waitable() {
+						@Override
+						protected Object evaluate() {
+							PlayerConnection.this.disconnect("disconnect.spam");
+							return null;
+						}
+					};
+
+					this.minecraftServer.processQueue.add(waitable);
+
+					try {
+						waitable.get();
+					} catch (InterruptedException e) {
+						Thread.currentThread().interrupt();
+					} catch (ExecutionException e) {
+						throw new RuntimeException(e);
+					}
+				} else {
+					this.disconnect("disconnect.spam");
+				}
+			}
+		}
+	}
+
+	public void chat(String s, boolean async) {
+		if (s.isEmpty() || this.player.getChatFlags() == EntityHuman.EnumChatVisibility.HIDDEN) {
+			return;
+		}
+
+		if (!async && s.startsWith("/")) {
+			if (!org.bukkit.Bukkit.isPrimaryThread()) {
+				final String fCommandLine = s;
+
+				MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Command Dispatched Async: " + fCommandLine);
+				MinecraftServer.LOGGER.log(org.apache.logging.log4j.Level.ERROR, "Please notify author of plugin causing this execution to fix this bug! see: http://bit.ly/1oSiM6C", new Throwable());
+
+				Waitable wait = new Waitable() {
+					@Override
+					protected Object evaluate() {
+						chat(fCommandLine, false);
+						return null;
+					}
+				};
+
+				minecraftServer.processQueue.add(wait);
+
+				try {
+					wait.get();
+					return;
+				} catch (InterruptedException e) {
+					Thread.currentThread().interrupt();
+				} catch (Exception e) {
+					throw new RuntimeException("Exception processing chat command", e.getCause());
+				}
+			}
+
+			this.handleCommand(s);
+		} else if (this.player.getChatFlags() == EntityHuman.EnumChatVisibility.SYSTEM) {
+
+		} else {
+			Player player = this.getPlayer();
+			AsyncPlayerChatEvent event = new AsyncPlayerChatEvent(async, player, s, new LazyPlayerSet());
+			this.server.getPluginManager().callEvent(event);
+
+			if (PlayerChatEvent.getHandlerList().getRegisteredListeners().length != 0) {
+				final PlayerChatEvent queueEvent = new PlayerChatEvent(player, event.getMessage(), event.getFormat(), event.getRecipients());
+
+				queueEvent.setCancelled(event.isCancelled());
+
+				Waitable waitable = new Waitable() {
+					@Override
+					protected Object evaluate() {
+						org.bukkit.Bukkit.getPluginManager().callEvent(queueEvent);
+
+						if (queueEvent.isCancelled()) {
+							return null;
+						}
+
+						String message = String.format(queueEvent.getFormat(), queueEvent.getPlayer().getDisplayName(), queueEvent.getMessage());
+						PlayerConnection.this.minecraftServer.console.sendMessage(message);
+						if (((LazyPlayerSet) queueEvent.getRecipients()).isLazy()) {
+							for (Object player : PlayerConnection.this.minecraftServer.getPlayerList().players) {
+								((EntityPlayer) player).sendMessage(CraftChatMessage.fromString(message));
+							}
+						} else {
+							for (Player player : queueEvent.getRecipients()) {
+								player.sendMessage(message);
+							}
+						}
+						return null;
+					}
+				};
+
+				if (async) {
+					minecraftServer.processQueue.add(waitable);
+				} else {
+					waitable.run();
+				}
+
+				try {
+					waitable.get();
+				} catch (InterruptedException e) {
+					Thread.currentThread().interrupt();
+				} catch (ExecutionException e) {
+					throw new RuntimeException("Exception processing chat event", e.getCause());
+				}
+			} else {
+				if (event.isCancelled()) {
+					return;
+				}
+
+				s = String.format(event.getFormat(), event.getPlayer().getDisplayName(), event.getMessage());
+				minecraftServer.console.sendMessage(s);
+				if (((LazyPlayerSet) event.getRecipients()).isLazy()) {
+					for (Object recipient : minecraftServer.getPlayerList().players) {
+						((EntityPlayer) recipient).sendMessage(CraftChatMessage.fromString(s));
+					}
+				} else {
+					for (Player recipient : event.getRecipients()) {
+						recipient.sendMessage(s);
+					}
+				}
+			}
+		}
+	}
+
+	private void handleCommand(String s) {
+		SpigotTimings.playerCommandTimer.startTiming();
+		if (org.spigotmc.SpigotConfig.logCommands)
+			this.c.info(this.player.getName() + " issued server command: " + s);
+
+		CraftPlayer player = this.getPlayer();
+
+		PlayerCommandPreprocessEvent event = new PlayerCommandPreprocessEvent(player, s, new LazyPlayerSet());
+		this.server.getPluginManager().callEvent(event);
+
+		if (event.isCancelled()) {
+			SpigotTimings.playerCommandTimer.stopTiming();
+			return;
+		}
+
+		try {
+			if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1))) {
+				SpigotTimings.playerCommandTimer.stopTiming();
+				return;
+			}
+		} catch (org.bukkit.command.CommandException ex) {
+			player.sendMessage(org.bukkit.ChatColor.RED + "An internal error occurred while attempting to perform this command");
+			java.util.logging.Logger.getLogger(PlayerConnection.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
+			SpigotTimings.playerCommandTimer.stopTiming();
+			return;
+		}
+
+		SpigotTimings.playerCommandTimer.stopTiming();
+	}
+
+	public void a(PacketPlayInArmAnimation packetplayinarmanimation) {
+		if (this.player.dead) {
+			return;
+		}
+
+		if (PotionSpigot.INSTANCE.getConfig().isInvalidArmAnimationKick()) {
+			if (lastSwingTick != MinecraftServer.currentTick) {
+				swings = 0;
+				lastSwingTick = MinecraftServer.currentTick;
+			} else {
+				if (swings > 5) {
+					if (MinecraftServer.currentTick - 1 == lastSequentialSwingTick) {
+						sequentialSwingRateLimits++;
+					} else if (MinecraftServer.currentTick != lastSequentialSwingTick) {
+						sequentialSwingRateLimits = 0;
+					} else if (75 < sequentialSwingRateLimits) {
+						this.disconnect("Invalid arm animations");
+					}
+					lastSequentialSwingTick = MinecraftServer.currentTick;
+					return;
+				}
+				swings++;
+			}
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayinarmanimation, this, this.player.u());
+
+		this.player.resetIdleTimer();
+
+		if (PotionSpigot.INSTANCE.getConfig().isFireLeftClickAir()) {
+			float pitch = this.player.pitch;
+			float yaw = this.player.yaw;
+			double locX = this.player.locX;
+			double locY = this.player.locY + (double) this.player.getHeadHeight();
+			double locZ = this.player.locZ;
+			Vec3D vec3d = new Vec3D(locX, locY, locZ);
+			float f3 = MathHelper.cos(-yaw * 0.017453292F - 3.1415927F);
+			float f4 = (float) MathHelper.sin(-yaw * 0.017453292F - 3.1415927F);
+			float f5 = -MathHelper.cos(-pitch * 0.017453292F);
+			float f6 = (float) MathHelper.sin(-pitch * 0.017453292F);
+			float f7 = f4 * f5;
+			float f8 = f3 * f5;
+			double d3 = player.playerInteractManager.getGameMode() == WorldSettings.EnumGamemode.CREATIVE ? 5.0D : 4.5D;
+			Vec3D vec3d1 = vec3d.add((double) f7 * d3, (double) f6 * d3, (double) f8 * d3);
+
+			MovingObjectPosition movingobjectposition = this.player.world.rayTrace(vec3d, vec3d1, false);
+
+			if (movingobjectposition == null || movingobjectposition.type != MovingObjectPosition.EnumMovingObjectType.BLOCK) {
+				CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_AIR, this.player.inventory.getItemInHand());
+			}
+		}
+
+		PlayerAnimationEvent event = new PlayerAnimationEvent(this.getPlayer());
+
+		this.server.getPluginManager().callEvent(event);
+
+		if (event.isCancelled()) {
+			return;
+		}
+
+		if (MinecraftServer.currentTick >= this.forwardSwingTick) {
+			this.player.bw();
+			this.forwardSwingTick = MinecraftServer.currentTick + 5;
+		}
+
+		if (this.player.isBlocking()) {
+			this.player.bU();
+		}
+	}
+
+	public void a(PacketPlayInEntityAction packetplayinentityaction) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinentityaction, this, this.player.u());
+
+		if (this.player.dead) {
+			return;
+		}
+
+		switch (packetplayinentityaction.b()) {
+			case START_SNEAKING:
+			case STOP_SNEAKING:
+				PlayerToggleSneakEvent event = new PlayerToggleSneakEvent(this.getPlayer(), packetplayinentityaction.b() == PacketPlayInEntityAction.EnumPlayerAction.START_SNEAKING);
+
+				this.server.getPluginManager().callEvent(event);
+
+				if (event.isCancelled()) {
+					return;
+				}
+
+				break;
+			case START_SPRINTING:
+			case STOP_SPRINTING:
+				PlayerToggleSprintEvent e2 = new PlayerToggleSprintEvent(this.getPlayer(), packetplayinentityaction.b() == PacketPlayInEntityAction.EnumPlayerAction.START_SPRINTING);
+
+				this.server.getPluginManager().callEvent(e2);
+
+				if (e2.isCancelled()) {
+					return;
+				}
+
+				break;
+		}
+
+		this.player.resetIdleTimer();
+		switch (PlayerConnection.SyntheticClass_1.b[packetplayinentityaction.b().ordinal()]) {
+			case 1:
+				this.player.setSneaking(true);
+				break;
+			case 2:
+				this.player.setSneaking(false);
+				break;
+			case 3:
+				this.player.setSprinting(true);
+				this.player.setSneaking(false);
+				break;
+			case 4:
+				this.player.setSprinting(false);
+				break;
+			case 5:
+				this.player.a(false, true, true);
+				break;
+
+			case 6:
+				if (this.player.vehicle instanceof EntityHorse) {
+					((EntityHorse) this.player.vehicle).v(packetplayinentityaction.c());
+				}
+				break;
+
+			case 7:
+				if (this.player.vehicle instanceof EntityHorse) {
+					((EntityHorse) this.player.vehicle).g(this.player);
+				}
+				break;
+
+			default:
+				throw new IllegalArgumentException("Invalid client command!");
+		}
+
+	}
+
+	public void a(PacketPlayInUseEntity packetplayinuseentity) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayinuseentity, this, this.player.u());
+
+		WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
+		Entity entity = packetplayinuseentity.a(worldserver);
+
+		if (entity == player && !player.isSpectator()) {
+			disconnect("Cannot interact with self!");
+			return;
+		}
+
+		this.player.resetIdleTimer();
+
+		if (entity != null) {
+			double d0 = 36.0D;
+
+			if (this.player.h(entity) < d0) {
+				ItemStack itemInHand = this.player.inventory.getItemInHand();
+
+				if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT || packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+					boolean triggerLeashUpdate = itemInHand != null && itemInHand.getItem() == Items.LEAD && entity instanceof EntityInsentient;
+					Item origItem = this.player.inventory.getItemInHand() == null ? null : this.player.inventory.getItemInHand().getItem();
+					PlayerInteractEntityEvent event;
+
+					if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT) {
+						event = new PlayerInteractEntityEvent(this.getPlayer(), entity.getBukkitEntity());
+					} else {
+						Vec3D target = packetplayinuseentity.b();
+						event = new PlayerInteractAtEntityEvent(this.getPlayer(), entity.getBukkitEntity(), new org.bukkit.util.Vector(target.a, target.b, target.c));
+					}
+
+					this.server.getPluginManager().callEvent(event);
+
+					if (triggerLeashUpdate && (event.isCancelled() || this.player.inventory.getItemInHand() == null || this.player.inventory.getItemInHand().getItem() != Items.LEAD)) {
+						this.sendPacket(new PacketPlayOutAttachEntity(1, entity, ((EntityInsentient) entity).getLeashHolder()));
+					}
+
+					if (event.isCancelled() || this.player.inventory.getItemInHand() == null || this.player.inventory.getItemInHand().getItem() != origItem) {
+						this.sendPacket(new PacketPlayOutEntityMetadata(entity.getId(), entity.datawatcher, true));
+					}
+
+					if (event.isCancelled()) {
+						return;
+					}
+				}
+
+				if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT) {
+					this.player.u(entity);
+
+					if (itemInHand != null && itemInHand.count <= -1) {
+						this.player.updateInventory(this.player.activeContainer);
+					}
+				} else if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.INTERACT_AT) {
+					entity.a(this.player, packetplayinuseentity.b());
+
+					if (itemInHand != null && itemInHand.count <= -1) {
+						this.player.updateInventory(this.player.activeContainer);
+					}
+				} else if (packetplayinuseentity.a() == PacketPlayInUseEntity.EnumEntityUseAction.ATTACK) {
+					if (entity instanceof EntityItem || entity instanceof EntityExperienceOrb || entity instanceof EntityArrow || (entity == this.player && !player.isSpectator())) { // CraftBukkit
+						this.disconnect("Attempting to attack an invalid entity");
+						this.minecraftServer.warning("Player " + this.player.getName() + " tried to attack an invalid entity");
+						return;
+					}
+
+					this.player.attack(entity);
+
+					if (itemInHand != null && itemInHand.count <= -1) {
+						this.player.updateInventory(this.player.activeContainer);
+					}
+				}
+			}
+		}
+	}
+
+	public void a(PacketPlayInClientCommand packetplayinclientcommand) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinclientcommand, this, this.player.u());
+
+		this.player.resetIdleTimer();
+
+		PacketPlayInClientCommand.EnumClientCommand clientCommand = packetplayinclientcommand.a();
+
+		switch (PlayerConnection.SyntheticClass_1.c[clientCommand.ordinal()]) {
+			case 1:
+				if (this.player.viewingCredits) {
+					this.minecraftServer.getPlayerList().changeDimension(this.player, 0, PlayerTeleportEvent.TeleportCause.END_PORTAL);
+				} else if (this.player.u().getWorldData().isHardcore()) {
+					if (this.minecraftServer.T() && this.player.getName().equals(this.minecraftServer.S())) {
+						this.player.playerConnection.disconnect("You have died. Game over, man, it\'s game over!");
+						this.minecraftServer.aa();
+					} else {
+						GameProfileBanEntry gameprofilebanentry = new GameProfileBanEntry(this.player.getProfile(), null, "(You just lost the game)", null, "Death in Hardcore");
+
+						this.minecraftServer.getPlayerList().getProfileBans().add(gameprofilebanentry);
+						this.player.playerConnection.disconnect("You have died. Game over, man, it\'s game over!");
+					}
+				} else {
+					if (this.player.getHealth() > 0.0F) {
+						return;
+					}
+
+					this.player = this.minecraftServer.getPlayerList().moveToWorld(this.player, 0, false);
+				}
+				break;
+
+			case 2:
+				this.player.getStatisticManager().a(this.player);
+				break;
+
+			case 3:
+				this.player.b(AchievementList.f);
+		}
+
+	}
+
+	public void a(PacketPlayInCloseWindow packetplayinclosewindow) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayinclosewindow, this, this.player.u());
+
+		CraftEventFactory.handleInventoryCloseEvent(this.player);
+
+		this.player.p();
+	}
+
+	public void a(PacketPlayInWindowClick packetplayinwindowclick) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayinwindowclick, this, this.player.u());
+
+		this.player.resetIdleTimer();
+
+		if (this.player.activeContainer.windowId == packetplayinwindowclick.a() && this.player.activeContainer.c(this.player)) {
+			boolean cancelled = this.player.isSpectator();
+
+			if (packetplayinwindowclick.b() < -1 && packetplayinwindowclick.b() != -999) {
+				return;
+			}
+
+			InventoryView inventory = this.player.activeContainer.getBukkitView();
+			SlotType type = CraftInventoryView.getSlotType(inventory, packetplayinwindowclick.b());
+			InventoryClickEvent event = null;
+			ClickType click = ClickType.UNKNOWN;
+			InventoryAction action = InventoryAction.UNKNOWN;
+			ItemStack itemstack = null;
+
+			if (packetplayinwindowclick.b() == -1) {
+				type = SlotType.OUTSIDE;
+				click = packetplayinwindowclick.c() == 0 ? ClickType.WINDOW_BORDER_LEFT : ClickType.WINDOW_BORDER_RIGHT;
+				action = InventoryAction.NOTHING;
+			} else if (packetplayinwindowclick.f() == 0) {
+				if (packetplayinwindowclick.c() == 0) {
+					click = ClickType.LEFT;
+				} else if (packetplayinwindowclick.c() == 1) {
+					click = ClickType.RIGHT;
+				}
+
+				if (packetplayinwindowclick.c() == 0 || packetplayinwindowclick.c() == 1) {
+					action = InventoryAction.NOTHING;
+
+					if (packetplayinwindowclick.b() == -999) {
+						if (player.inventory.getCarried() != null) {
+							action = packetplayinwindowclick.c() == 0 ? InventoryAction.DROP_ALL_CURSOR : InventoryAction.DROP_ONE_CURSOR;
+						}
+					} else {
+						Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+						if (slot != null) {
+							ItemStack clickedItem = slot.getItem();
+							ItemStack cursor = player.inventory.getCarried();
+
+							if (clickedItem == null) {
+								if (cursor != null) {
+									action = packetplayinwindowclick.c() == 0 ? InventoryAction.PLACE_ALL : InventoryAction.PLACE_ONE;
+								}
+							} else if (slot.isAllowed(player)) {
+								if (cursor == null) {
+									action = packetplayinwindowclick.c() == 0 ? InventoryAction.PICKUP_ALL : InventoryAction.PICKUP_HALF;
+								} else if (slot.isAllowed(cursor)) {
+									if (clickedItem.doMaterialsMatch(cursor) && ItemStack.equals(clickedItem, cursor)) {
+										int toPlace = packetplayinwindowclick.c() == 0 ? cursor.count : 1;
+										toPlace = Math.min(toPlace, clickedItem.getMaxStackSize() - clickedItem.count);
+										toPlace = Math.min(toPlace, slot.inventory.getMaxStackSize() - clickedItem.count);
+
+										if (toPlace == 1) {
+											action = InventoryAction.PLACE_ONE;
+										} else if (toPlace == cursor.count) {
+											action = InventoryAction.PLACE_ALL;
+										} else if (toPlace < 0) {
+											action = toPlace != -1 ? InventoryAction.PICKUP_SOME : InventoryAction.PICKUP_ONE;
+										} else if (toPlace != 0) {
+											action = InventoryAction.PLACE_SOME;
+										}
+									} else if (cursor.count <= slot.getMaxStackSize()) {
+										action = InventoryAction.SWAP_WITH_CURSOR;
+									}
+								} else if (cursor.getItem() == clickedItem.getItem() && (!cursor.usesData() || cursor.getData() == clickedItem.getData()) && ItemStack.equals(cursor, clickedItem)) {
+									if (clickedItem.count >= 0) {
+										if (clickedItem.count + cursor.count <= cursor.getMaxStackSize()) {
+											action = InventoryAction.PICKUP_ALL;
+										}
+									}
+								}
+							}
+						}
+					}
+				}
+			} else if (packetplayinwindowclick.f() == 1) {
+				if (packetplayinwindowclick.c() == 0) {
+					click = ClickType.SHIFT_LEFT;
+				} else if (packetplayinwindowclick.c() == 1) {
+					click = ClickType.SHIFT_RIGHT;
+				}
+				if (packetplayinwindowclick.c() == 0 || packetplayinwindowclick.c() == 1) {
+					if (packetplayinwindowclick.b() < 0) {
+						action = InventoryAction.NOTHING;
+					} else {
+						Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+						if (slot != null && slot.isAllowed(this.player) && slot.hasItem()) {
+							action = InventoryAction.MOVE_TO_OTHER_INVENTORY;
+						} else {
+							action = InventoryAction.NOTHING;
+						}
+					}
+				}
+			} else if (packetplayinwindowclick.f() == 2) {
+				if (packetplayinwindowclick.c() >= 0 && packetplayinwindowclick.c() < 9) {
+					click = ClickType.NUMBER_KEY;
+					Slot clickedSlot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+					if (clickedSlot.isAllowed(player)) {
+						ItemStack hotbar = this.player.inventory.getItem(packetplayinwindowclick.c());
+						boolean canCleanSwap = hotbar == null || (clickedSlot.inventory == player.inventory && clickedSlot.isAllowed(hotbar));
+
+						if (clickedSlot.hasItem()) {
+							if (canCleanSwap) {
+								action = InventoryAction.HOTBAR_SWAP;
+							} else {
+								int firstEmptySlot = player.inventory.getFirstEmptySlotIndex();
+
+								if (firstEmptySlot > -1) {
+									action = InventoryAction.HOTBAR_MOVE_AND_READD;
+								} else {
+									action = InventoryAction.NOTHING;
+								}
+							}
+						} else if (!clickedSlot.hasItem() && hotbar != null && clickedSlot.isAllowed(hotbar)) {
+							action = InventoryAction.HOTBAR_SWAP;
+						} else {
+							action = InventoryAction.NOTHING;
+						}
+					} else {
+						action = InventoryAction.NOTHING;
+					}
+
+					event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
+				}
+			} else if (packetplayinwindowclick.f() == 3) {
+				if (packetplayinwindowclick.c() == 2) {
+					click = ClickType.MIDDLE;
+
+					if (packetplayinwindowclick.b() == -999) {
+						action = InventoryAction.NOTHING;
+					} else {
+						Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+						if (slot != null && slot.hasItem() && player.abilities.canInstantlyBuild && player.inventory.getCarried() == null) {
+							action = InventoryAction.CLONE_STACK;
+						} else {
+							action = InventoryAction.NOTHING;
+						}
+					}
+				} else {
+					click = ClickType.UNKNOWN;
+					action = InventoryAction.UNKNOWN;
+				}
+			} else if (packetplayinwindowclick.f() == 4) {
+				if (packetplayinwindowclick.b() >= 0) {
+					if (packetplayinwindowclick.c() == 0) {
+						click = ClickType.DROP;
+						Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+						if (slot != null && slot.hasItem() && slot.isAllowed(player) && slot.getItem() != null && slot.getItem().getItem() != Item.getItemOf(Blocks.AIR)) {
+							action = InventoryAction.DROP_ONE_SLOT;
+						} else {
+							action = InventoryAction.NOTHING;
+						}
+					} else if (packetplayinwindowclick.c() == 1) {
+						click = ClickType.CONTROL_DROP;
+						Slot slot = this.player.activeContainer.getSlot(packetplayinwindowclick.b());
+
+						if (slot != null && slot.hasItem() && slot.isAllowed(player) && slot.getItem() != null && slot.getItem().getItem() != Item.getItemOf(Blocks.AIR)) {
+							action = InventoryAction.DROP_ALL_SLOT;
+						} else {
+							action = InventoryAction.NOTHING;
+						}
+					}
+				} else {
+					click = ClickType.LEFT;
+
+					if (packetplayinwindowclick.c() == 1) {
+						click = ClickType.RIGHT;
+					}
+
+					action = InventoryAction.NOTHING;
+				}
+			} else if (packetplayinwindowclick.f() == 5) {
+				itemstack = this.player.activeContainer.clickItem(packetplayinwindowclick.b(), packetplayinwindowclick.c(), 5, this.player);
+			} else if (packetplayinwindowclick.f() == 6) {
+				click = ClickType.DOUBLE_CLICK;
+				action = InventoryAction.NOTHING;
+
+				if (packetplayinwindowclick.b() >= 0 && this.player.inventory.getCarried() != null) {
+					ItemStack cursor = this.player.inventory.getCarried();
+					action = InventoryAction.NOTHING;
+
+					if (inventory.getTopInventory().contains(org.bukkit.Material.getMaterial(Item.getId(cursor.getItem()))) || inventory.getBottomInventory().contains(org.bukkit.Material.getMaterial(Item.getId(cursor.getItem())))) {
+						action = InventoryAction.COLLECT_TO_CURSOR;
+					}
+				}
+			}
+
+			if (packetplayinwindowclick.f() != 5) {
+				if (click == ClickType.NUMBER_KEY) {
+					event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
+				} else {
+					event = new InventoryClickEvent(inventory, type, packetplayinwindowclick.b(), click, action);
+				}
+
+				org.bukkit.inventory.Inventory top = inventory.getTopInventory();
+
+				if (packetplayinwindowclick.b() == 0 && top instanceof CraftingInventory) {
+					org.bukkit.inventory.Recipe recipe = ((CraftingInventory) top).getRecipe();
+
+					if (recipe != null) {
+						if (click == ClickType.NUMBER_KEY) {
+							event = new CraftItemEvent(recipe, inventory, type, packetplayinwindowclick.b(), click, action, packetplayinwindowclick.c());
+						} else {
+							event = new CraftItemEvent(recipe, inventory, type, packetplayinwindowclick.b(), click, action);
+						}
+					}
+				}
+
+				event.setCancelled(cancelled);
+				server.getPluginManager().callEvent(event);
+
+				switch (event.getResult()) {
+					case ALLOW:
+					case DEFAULT:
+						itemstack = this.player.activeContainer.clickItem(packetplayinwindowclick.b(), packetplayinwindowclick.c(), packetplayinwindowclick.f(), this.player);
+
+						if (itemstack != null &&
+								((itemstack.getItem() == Items.LAVA_BUCKET && PaperSpigotConfig.stackableLavaBuckets) ||
+										(itemstack.getItem() == Items.WATER_BUCKET && PaperSpigotConfig.stackableWaterBuckets) ||
+										(itemstack.getItem() == Items.MILK_BUCKET && PaperSpigotConfig.stackableMilkBuckets))) {
+							if (action == InventoryAction.MOVE_TO_OTHER_INVENTORY) {
+								this.player.updateInventory(this.player.activeContainer);
+							} else {
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
+							}
+						}
+						break;
+					case DENY:
+						switch (action) {
+							case PICKUP_ALL:
+							case MOVE_TO_OTHER_INVENTORY:
+							case HOTBAR_MOVE_AND_READD:
+							case HOTBAR_SWAP:
+							case COLLECT_TO_CURSOR:
+							case UNKNOWN:
+								this.player.updateInventory(this.player.activeContainer);
+								break;
+							case PICKUP_SOME:
+							case PICKUP_HALF:
+							case PICKUP_ONE:
+							case PLACE_ALL:
+							case PLACE_SOME:
+							case PLACE_ONE:
+							case SWAP_WITH_CURSOR:
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
+								break;
+							case DROP_ALL_SLOT:
+							case DROP_ONE_SLOT:
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.activeContainer.windowId, packetplayinwindowclick.b(), this.player.activeContainer.getSlot(packetplayinwindowclick.b()).getItem()));
+								break;
+							case DROP_ALL_CURSOR:
+							case DROP_ONE_CURSOR:
+							case CLONE_STACK:
+								this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.player.inventory.getCarried()));
+								break;
+							// Nothing
+							case NOTHING:
+								break;
+						}
+						return;
+				}
+
+				if (event instanceof CraftItemEvent) {
+					player.updateInventory(player.activeContainer);
+				}
+			}
+
+			if (ItemStack.matches(packetplayinwindowclick.e(), itemstack)) {
+				this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), true));
+				this.player.g = true;
+				this.player.activeContainer.b();
+				this.player.broadcastCarriedItem();
+				this.player.g = false;
+			} else {
+				this.n.a(this.player.activeContainer.windowId, packetplayinwindowclick.d());
+				this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), false));
+				this.player.activeContainer.a(this.player, false);
+				List<ItemStack> items = new ArrayList<>();
+
+				for (int j = 0; j < this.player.activeContainer.c.size(); ++j) {
+					items.add(this.player.activeContainer.c.get(j).getItem());
+				}
+
+				this.player.a(this.player.activeContainer, items);
+			}
+		}
+
+	}
+
+	public void a(PacketPlayInEnchantItem packetplayinenchantitem) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinenchantitem, this, this.player.u());
+
+		this.player.resetIdleTimer();
+
+		if (this.player.activeContainer.windowId == packetplayinenchantitem.a() && this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
+			this.player.activeContainer.a(this.player, packetplayinenchantitem.b());
+			this.player.activeContainer.b();
+		}
+
+	}
+
+	public void a(PacketPlayInSetCreativeSlot packetplayinsetcreativeslot) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinsetcreativeslot, this, this.player.u());
+
+		if (this.player.playerInteractManager.isCreative()) {
+			boolean flag = packetplayinsetcreativeslot.a() < 0;
+			ItemStack itemstack = packetplayinsetcreativeslot.getItemStack();
+
+			if (itemstack != null && itemstack.hasTag() && itemstack.getTag().hasKeyOfType("BlockEntityTag", 10)) {
+				NBTTagCompound nbttagcompound = itemstack.getTag().getCompound("BlockEntityTag");
+
+				if (nbttagcompound.hasKey("x") && nbttagcompound.hasKey("y") && nbttagcompound.hasKey("z")) {
+					BlockPosition blockposition = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
+					TileEntity tileentity = this.player.world.getTileEntity(blockposition);
+
+					if (tileentity != null) {
+						NBTTagCompound nbt = new NBTTagCompound();
+
+						tileentity.b(nbt);
+						nbt.remove("x");
+						nbt.remove("y");
+						nbt.remove("z");
+						itemstack.a("BlockEntityTag", nbt);
+					}
+				}
+			}
+
+			boolean flag1 = packetplayinsetcreativeslot.a() >= 1 && packetplayinsetcreativeslot.a() < 36 + PlayerInventory.getHotbarSize();
+
+			boolean flag2 = itemstack == null || itemstack.getItem() != null && (!invalidItems.contains(Item.getId(itemstack.getItem())) || !org.spigotmc.SpigotConfig.filterCreativeItems); // Spigot
+			boolean flag3 = itemstack == null || itemstack.getData() >= 0 && itemstack.count <= 64 && itemstack.count > 0;
+
+			if (flag || (flag1 && !ItemStack.matches(this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem(), packetplayinsetcreativeslot.getItemStack()))) { // Insist on valid slot
+
+				org.bukkit.entity.HumanEntity player = this.player.getBukkitEntity();
+				InventoryView inventory = new CraftInventoryView(player, player.getInventory(), this.player.defaultContainer);
+				org.bukkit.inventory.ItemStack item = CraftItemStack.asBukkitCopy(packetplayinsetcreativeslot.getItemStack());
+
+				SlotType type = SlotType.QUICKBAR;
+				if (flag) {
+					type = SlotType.OUTSIDE;
+				} else if (packetplayinsetcreativeslot.a() < 36) {
+					if (packetplayinsetcreativeslot.a() >= 5 && packetplayinsetcreativeslot.a() < 9) {
+						type = SlotType.ARMOR;
+					} else {
+						type = SlotType.CONTAINER;
+					}
+				}
+				InventoryCreativeEvent event = new InventoryCreativeEvent(inventory, type, flag ? -999 : packetplayinsetcreativeslot.a(), item);
+				server.getPluginManager().callEvent(event);
+
+				itemstack = CraftItemStack.asNMSCopy(event.getCursor());
+
+				switch (event.getResult()) {
+					case ALLOW:
+						flag2 = flag3 = true;
+						break;
+					case DEFAULT:
+						break;
+					case DENY:
+						if (packetplayinsetcreativeslot.a() >= 0) {
+							this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(this.player.defaultContainer.windowId, packetplayinsetcreativeslot.a(), this.player.defaultContainer.getSlot(packetplayinsetcreativeslot.a()).getItem()));
+							this.player.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, null));
+						}
+						return;
+				}
+			}
+
+			if (flag1 && flag2 && flag3) {
+				if (itemstack == null) {
+					this.player.defaultContainer.setItem(packetplayinsetcreativeslot.a(), null);
+				} else {
+					this.player.defaultContainer.setItem(packetplayinsetcreativeslot.a(), itemstack);
+				}
+
+				this.player.defaultContainer.a(this.player, true);
+			} else if (flag && flag2 && flag3 && this.m < 200) {
+				this.m += 20;
+				EntityItem entityitem = this.player.drop(itemstack, true);
+
+				if (entityitem != null) {
+					entityitem.j();
+				}
+			}
+		}
+
+	}
+
+	public void a(PacketPlayInTransaction packetplayintransaction) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(packetplayintransaction, this, this.player.u());
+
+		Short s = this.n.get(this.player.activeContainer.windowId);
+
+		if (s != null && packetplayintransaction.b() == s && this.player.activeContainer.windowId == packetplayintransaction.a() && !this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
+			this.player.activeContainer.a(this.player, true);
+		}
+
+	}
+
+	public void a(PacketPlayInUpdateSign updateSignPacket) {
+		if (this.player.dead) {
+			return;
+		}
+
+		PlayerConnectionUtils.ensureMainThread(updateSignPacket, this, this.player.u());
+
+		this.player.resetIdleTimer();
+
+		WorldServer worldserver = this.minecraftServer.getWorldServer(this.player.dimension);
+		BlockPosition blockposition = updateSignPacket.a();
+
+		if (worldserver.isLoaded(blockposition)) {
+			TileEntity tileentity = worldserver.getTileEntity(blockposition);
+
+			if (!(tileentity instanceof TileEntitySign)) {
+				return;
+			}
+
+			TileEntitySign tileentitysign = (TileEntitySign) tileentity;
+
+			if (!tileentitysign.b() || tileentitysign.c() != this.player) {
+				this.minecraftServer.warning("Player " + this.player.getName() + " just tried to change non-editable sign");
+				this.sendPacket(new PacketPlayOutUpdateSign(tileentity.world, updateSignPacket.a(), tileentitysign.lines));
+				return;
+			}
+
+			IChatBaseComponent[] baseComponent = updateSignPacket.b();
+
+			Player player = this.server.getPlayer(this.player);
+			int x = updateSignPacket.a().getX();
+			int y = updateSignPacket.a().getY();
+			int z = updateSignPacket.a().getZ();
+			String[] lines = new String[4];
+
+			for (int i = 0; i < baseComponent.length; ++i) {
+				lines[i] = EnumChatFormat.a(baseComponent[i].c());
+			}
+
+			SignChangeEvent event = new SignChangeEvent(player.getWorld().getBlockAt(x, y, z), this.server.getPlayer(this.player), lines);
+
+			this.server.getPluginManager().callEvent(event);
+
+			if (!event.isCancelled()) {
+				System.arraycopy(org.bukkit.craftbukkit.block.CraftSign.sanitizeLines(event.getLines()), 0, tileentitysign.lines, 0, 4);
+				tileentitysign.isEditable = false;
+			}
+
+			tileentitysign.update();
+			worldserver.notify(blockposition);
+		}
+
+	}
+
+	public void a(PacketPlayInKeepAlive packetplayinkeepalive) {
+		if (packetplayinkeepalive.a() == this.i) {
+			int i = (int) (this.d() - this.j);
+
+			this.player.ping = (this.player.ping * 3 + i) / 4;
+		}
+
+	}
+
+	private long d() {
+		return System.nanoTime() / 1000000L;
+	}
+
+	public void a(PacketPlayInAbilities packetplayinabilities) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinabilities, this, this.player.u());
+
+		if (this.player.abilities.canFly && this.player.abilities.isFlying != packetplayinabilities.isFlying()) {
+			PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.server.getPlayer(this.player), packetplayinabilities.isFlying());
+
+			this.server.getPluginManager().callEvent(event);
+
+			if (!event.isCancelled()) {
+				this.player.abilities.isFlying = packetplayinabilities.isFlying();
+			} else {
+				this.player.updateAbilities();
+			}
+		}
+	}
+
+	public void a(PacketPlayInTabComplete packetplayintabcomplete) {
+		PlayerConnectionUtils.ensureMainThread(packetplayintabcomplete, this, this.player.u());
+
+		if (chatSpamField.addAndGet(this, 10) > 500 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) {
+			this.disconnect("disconnect.spam");
+			return;
+		}
+
+		ArrayList arraylist = Lists.newArrayList();
+		Iterator iterator = this.minecraftServer.tabCompleteCommand(this.player, packetplayintabcomplete.a(), packetplayintabcomplete.b()).iterator();
+
+		while (iterator.hasNext()) {
+			String s = (String) iterator.next();
+
+			arraylist.add(s);
+		}
+
+		this.player.playerConnection.sendPacket(new PacketPlayOutTabComplete((String[]) arraylist.toArray(new String[arraylist.size()])));
+	}
+
+	public void a(PacketPlayInSettings packetplayinsettings) {
+		PlayerConnectionUtils.ensureMainThread(packetplayinsettings, this, this.player.u());
+		this.player.a(packetplayinsettings);
+	}
+
+	public void a(PacketPlayInCustomPayload packetplayincustompayload) {
+		PlayerConnectionUtils.ensureMainThread(packetplayincustompayload, this, this.player.u());
+		PacketDataSerializer packetdataserializer;
+		ItemStack itemstack;
+		ItemStack itemstack1;
+
+		try {
+			if ("MC|BEdit".equals(packetplayincustompayload.a())) {
+				packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
+
+				try {
+					itemstack = packetdataserializer.i();
+					if (itemstack == null) {
+						return;
+					}
+
+					if (!ItemBookAndQuill.b(itemstack.getTag())) {
+						throw new IOException("Invalid book tag!");
+					}
+
+					itemstack1 = this.player.inventory.getItemInHand();
+
+					if (itemstack1 != null) {
+						if (itemstack.getItem() == Items.WRITABLE_BOOK && itemstack.getItem() == itemstack1.getItem()) {
+							itemstack1 = new ItemStack(Items.WRITABLE_BOOK); // CraftBukkit
+							itemstack1.a("pages", itemstack.getTag().getList("pages", 8));
+							CraftEventFactory.handleEditBookEvent(player, itemstack1);
+						}
+
+						return;
+					}
+				} catch (Exception exception) {
+					PlayerConnection.c.error("Couldn\'t handle book info", exception);
+					this.disconnect("Invalid book data!");
+					return;
+				} finally {
+					packetdataserializer.release();
+				}
+
+				return;
+			} else if ("MC|BSign".equals(packetplayincustompayload.a())) {
+				packetdataserializer = new PacketDataSerializer(Unpooled.wrappedBuffer(packetplayincustompayload.b()));
+
+				try {
+					itemstack = packetdataserializer.i();
+					if (itemstack == null) {
+						return;
+					}
+
+					if (!ItemWrittenBook.b(itemstack.getTag())) {
+						throw new IOException("Invalid book tag!");
+					}
+
+					itemstack1 = this.player.inventory.getItemInHand();
+
+					if (itemstack1 != null) {
+						if (itemstack.getItem() == Items.WRITTEN_BOOK && itemstack1.getItem() == Items.WRITABLE_BOOK) {
+							itemstack1 = new ItemStack(Items.WRITTEN_BOOK);
+							itemstack1.a("author", new NBTTagString(this.player.getName()));
+							itemstack1.a("title", new NBTTagString(itemstack.getTag().getString("title")));
+							itemstack1.a("pages", itemstack.getTag().getList("pages", 8));
+							itemstack1.setItem(Items.WRITTEN_BOOK);
+							CraftEventFactory.handleEditBookEvent(player, itemstack1);
+						}
+
+						return;
+					}
+				} catch (Exception exception1) {
+					PlayerConnection.c.error("Couldn\'t sign book", exception1);
+					this.disconnect("Invalid book data!"); // CraftBukkit
+					return;
+				} finally {
+					packetdataserializer.release();
+				}
+
+				return;
+			} else if ("MC|TrSel".equals(packetplayincustompayload.a())) {
+				try {
+					int i = packetplayincustompayload.b().readInt();
+					Container container = this.player.activeContainer;
+
+					if (container instanceof ContainerMerchant) {
+						((ContainerMerchant) container).d(i);
+					}
+				} catch (Exception exception2) {
+					PlayerConnection.c.error("Couldn\'t select trade", exception2);
+					this.disconnect("Invalid trade data!");
+				}
+			} else if ("MC|AdvCdm".equals(packetplayincustompayload.a())) {
+				if (!this.minecraftServer.getEnableCommandBlock()) {
+					this.player.sendMessage(new ChatMessage("advMode.notEnabled", new Object[0]));
+				} else if (this.player.getBukkitEntity().isOp() && this.player.abilities.canInstantlyBuild) {
+					packetdataserializer = packetplayincustompayload.b();
+
+					try {
+						byte b0 = packetdataserializer.readByte();
+						CommandBlockListenerAbstract commandblocklistenerabstract = null;
+
+						if (b0 == 0) {
+							TileEntity tileentity = this.player.world.getTileEntity(new BlockPosition(packetdataserializer.readInt(), packetdataserializer.readInt(), packetdataserializer.readInt()));
+
+							if (tileentity instanceof TileEntityCommand) {
+								commandblocklistenerabstract = ((TileEntityCommand) tileentity).getCommandBlock();
+							}
+						} else if (b0 == 1) {
+							Entity entity = this.player.world.a(packetdataserializer.readInt());
+
+							if (entity instanceof EntityMinecartCommandBlock) {
+								commandblocklistenerabstract = ((EntityMinecartCommandBlock) entity).getCommandBlock();
+							}
+						}
+
+						String s = packetdataserializer.c(packetdataserializer.readableBytes());
+						boolean flag = packetdataserializer.readBoolean();
+
+						if (commandblocklistenerabstract != null) {
+							commandblocklistenerabstract.setCommand(s);
+							commandblocklistenerabstract.a(flag);
+							if (!flag) {
+								commandblocklistenerabstract.b((IChatBaseComponent) null);
+							}
+
+							commandblocklistenerabstract.h();
+							this.player.sendMessage(new ChatMessage("advMode.setCommand.success", new Object[]{s}));
+						}
+					} catch (Exception exception3) {
+						PlayerConnection.c.error("Couldn\'t set command block", exception3);
+						this.disconnect("Invalid CommandBlock data!");
+					} finally {
+						packetdataserializer.release();
+					}
+				} else {
+					this.player.sendMessage(new ChatMessage("advMode.notAllowed", new Object[0]));
+				}
+			} else if ("MC|Beacon".equals(packetplayincustompayload.a())) {
+				if (this.player.activeContainer instanceof ContainerBeacon) {
+					try {
+						packetdataserializer = packetplayincustompayload.b();
+						int j = packetdataserializer.readInt();
+						int k = packetdataserializer.readInt();
+						ContainerBeacon containerbeacon = (ContainerBeacon) this.player.activeContainer;
+						Slot slot = containerbeacon.getSlot(0);
+
+						if (slot.hasItem()) {
+							slot.a(1);
+							IInventory iinventory = containerbeacon.e();
+
+							iinventory.b(1, j);
+							iinventory.b(2, k);
+							iinventory.update();
+						}
+					} catch (Exception exception4) {
+						PlayerConnection.c.error("Couldn\'t set beacon", exception4);
+						this.disconnect("Invalid beacon data!");
+					}
+				}
+			} else if ("MC|ItemName".equals(packetplayincustompayload.a()) && this.player.activeContainer instanceof ContainerAnvil) {
+				ContainerAnvil containeranvil = (ContainerAnvil) this.player.activeContainer;
+
+				if (packetplayincustompayload.b() != null && packetplayincustompayload.b().readableBytes() >= 1) {
+					String s1 = SharedConstants.a(packetplayincustompayload.b().c(32767));
+
+					if (s1.length() <= 30) {
+						containeranvil.a(s1);
+					}
+				} else {
+					containeranvil.a("");
+				}
+			} else if (packetplayincustompayload.a().equals("REGISTER")) {
+				String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
+				for (String channel : channels.split("\0")) {
+					getPlayer().addChannel(channel);
+				}
+			} else if (packetplayincustompayload.a().equals("UNREGISTER")) {
+				String channels = packetplayincustompayload.b().toString(com.google.common.base.Charsets.UTF_8);
+				for (String channel : channels.split("\0")) {
+					getPlayer().removeChannel(channel);
+				}
+			} else {
+				byte[] data = new byte[packetplayincustompayload.b().readableBytes()];
+				packetplayincustompayload.b().readBytes(data);
+				server.getMessenger().dispatchIncomingMessage(player.getBukkitEntity(), packetplayincustompayload.a(), data);
+			}
+		} finally {
+			if (packetplayincustompayload.b().refCnt() > 0) {
+				packetplayincustompayload.b().release();
+			}
+		}
+		// CraftBukkit end
+	}
+
+	// CraftBukkit start - Add "isDisconnected" method
+	public boolean isDisconnected() { // Spigot
+		return !this.player.joining && !this.networkManager.channel.config().isAutoRead();
+	}
+
+	static class SyntheticClass_1 {
+
+		static final int[] a;
+		static final int[] b;
+		static final int[] c = new int[PacketPlayInClientCommand.EnumClientCommand.values().length];
+
+		static {
+			try {
+				PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.PERFORM_RESPAWN.ordinal()] = 1;
+			} catch (NoSuchFieldError nosuchfielderror) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.REQUEST_STATS.ordinal()] = 2;
+			} catch (NoSuchFieldError nosuchfielderror1) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.c[PacketPlayInClientCommand.EnumClientCommand.OPEN_INVENTORY_ACHIEVEMENT.ordinal()] = 3;
+			} catch (NoSuchFieldError nosuchfielderror2) {
+				;
+			}
+
+			b = new int[PacketPlayInEntityAction.EnumPlayerAction.values().length];
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.START_SNEAKING.ordinal()] = 1;
+			} catch (NoSuchFieldError nosuchfielderror3) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SNEAKING.ordinal()] = 2;
+			} catch (NoSuchFieldError nosuchfielderror4) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.START_SPRINTING.ordinal()] = 3;
+			} catch (NoSuchFieldError nosuchfielderror5) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SPRINTING.ordinal()] = 4;
+			} catch (NoSuchFieldError nosuchfielderror6) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.STOP_SLEEPING.ordinal()] = 5;
+			} catch (NoSuchFieldError nosuchfielderror7) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.RIDING_JUMP.ordinal()] = 6;
+			} catch (NoSuchFieldError nosuchfielderror8) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.b[PacketPlayInEntityAction.EnumPlayerAction.OPEN_INVENTORY.ordinal()] = 7;
+			} catch (NoSuchFieldError nosuchfielderror9) {
+				;
+			}
+
+			a = new int[PacketPlayInBlockDig.EnumPlayerDigType.values().length];
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.DROP_ITEM.ordinal()] = 1;
+			} catch (NoSuchFieldError nosuchfielderror10) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.DROP_ALL_ITEMS.ordinal()] = 2;
+			} catch (NoSuchFieldError nosuchfielderror11) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.RELEASE_USE_ITEM.ordinal()] = 3;
+			} catch (NoSuchFieldError nosuchfielderror12) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.START_DESTROY_BLOCK.ordinal()] = 4;
+			} catch (NoSuchFieldError nosuchfielderror13) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.ABORT_DESTROY_BLOCK.ordinal()] = 5;
+			} catch (NoSuchFieldError nosuchfielderror14) {
+				;
+			}
+
+			try {
+				PlayerConnection.SyntheticClass_1.a[PacketPlayInBlockDig.EnumPlayerDigType.STOP_DESTROY_BLOCK.ordinal()] = 6;
+			} catch (NoSuchFieldError nosuchfielderror15) {
+				;
+			}
+
+		}
+	}
+
 }
diff --git a/src/main/java/net/minecraft/server/PlayerInteractManager.java b/src/main/java/net/minecraft/server/PlayerInteractManager.java
index 33a0a095..beab9f6f 100644
--- a/src/main/java/net/minecraft/server/PlayerInteractManager.java
+++ b/src/main/java/net/minecraft/server/PlayerInteractManager.java
@@ -1,18 +1,16 @@
 package net.minecraft.server;
 
-// CraftBukkit start
 import org.bukkit.event.block.BlockBreakEvent;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.event.Event;
 import org.bukkit.event.block.Action;
 import org.bukkit.event.player.PlayerInteractEvent;
-// CraftBukkit end
 
 public class PlayerInteractManager {
 
     public World world;
     public EntityPlayer player;
-    private WorldSettings.EnumGamemode gamemode;
+    private WorldSettings.EnumGamemode gameMode;
     private boolean d;
     private int lastDigTick;
     private BlockPosition f;
@@ -23,42 +21,42 @@ public class PlayerInteractManager {
     private int k;
 
     public PlayerInteractManager(World world) {
-        this.gamemode = WorldSettings.EnumGamemode.NOT_SET;
+        this.gameMode = WorldSettings.EnumGamemode.NOT_SET;
         this.f = BlockPosition.ZERO;
         this.i = BlockPosition.ZERO;
         this.k = -1;
         this.world = world;
     }
 
-    public void setGameMode(WorldSettings.EnumGamemode worldsettings_enumgamemode) {
-        this.gamemode = worldsettings_enumgamemode;
-        worldsettings_enumgamemode.a(this.player.abilities);
+    public void setGameMode(WorldSettings.EnumGamemode gameMode) {
+        this.gameMode = gameMode;
+        gameMode.a(this.player.abilities);
         this.player.updateAbilities();
-        this.player.server.getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_GAME_MODE, new EntityPlayer[] { this.player}), this.player); // CraftBukkit
+        this.player.server.getPlayerList().sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_GAME_MODE, this.player), this.player); // CraftBukkit
     }
 
     public WorldSettings.EnumGamemode getGameMode() {
-        return this.gamemode;
+        return this.gameMode;
     }
 
     public boolean c() {
-        return this.gamemode.e();
+        return this.gameMode.e();
     }
 
     public boolean isCreative() {
-        return this.gamemode.d();
+        return this.gameMode.d();
     }
 
-    public void b(WorldSettings.EnumGamemode worldsettings_enumgamemode) {
-        if (this.gamemode == WorldSettings.EnumGamemode.NOT_SET) {
-            this.gamemode = worldsettings_enumgamemode;
+    public void b(WorldSettings.EnumGamemode gameMode) {
+        if (this.gameMode == WorldSettings.EnumGamemode.NOT_SET) {
+            this.gameMode = gameMode;
         }
 
-        this.setGameMode(this.gamemode);
+        this.setGameMode(this.gameMode);
     }
 
     public void a() {
-        this.currentTick = MinecraftServer.currentTick; // CraftBukkit;
+        this.currentTick = MinecraftServer.currentTick;
         float f;
         int i;
 
@@ -103,29 +101,31 @@ public class PlayerInteractManager {
     }
 
     public void a(BlockPosition blockposition, EnumDirection enumdirection) {
-        // CraftBukkit start
         PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.LEFT_CLICK_BLOCK, blockposition, enumdirection, this.player.inventory.getItemInHand());
+
         if (event.isCancelled()) {
-            // Let the client know the block still exists
-            ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
-            // Update any tile entity data for this block
+            this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
+
             TileEntity tileentity = this.world.getTileEntity(blockposition);
+
             if (tileentity != null) {
                 this.player.playerConnection.sendPacket(tileentity.getUpdatePacket());
             }
+
             return;
         }
+
         // CraftBukkit end
         if (this.isCreative()) {
-            if (!this.world.douseFire((EntityHuman) null, blockposition, enumdirection)) {
+            if (!this.world.douseFire(null, blockposition, enumdirection)) {
                 this.breakBlock(blockposition);
             }
 
         } else {
             Block block = this.world.getType(blockposition).getBlock();
 
-            if (this.gamemode.c()) {
-                if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+            if (this.gameMode.c()) {
+                if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
                     return;
                 }
 
@@ -142,48 +142,47 @@ public class PlayerInteractManager {
                 }
             }
 
-            // this.world.douseFire((EntityHuman) null, blockposition, enumdirection); // CraftBukkit - Moved down
             this.lastDigTick = this.currentTick;
             float f = 1.0F;
 
-            // CraftBukkit start - Swings at air do *NOT* exist.
             if (event.useInteractedBlock() == Event.Result.DENY) {
-                // If we denied a door from opening, we need to send a correcting update to the client, as it already opened the door.
                 IBlockData data = this.world.getType(blockposition);
+
                 if (block == Blocks.WOODEN_DOOR) {
-                    // For some reason *BOTH* the bottom/top part have to be marked updated.
                     boolean bottom = data.get(BlockDoor.HALF) == BlockDoor.EnumDoorHalf.LOWER;
-                    ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
-                    ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, bottom ? blockposition.up() : blockposition.down()));
+
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, bottom ? blockposition.up() : blockposition.down()));
                 } else if (block == Blocks.TRAPDOOR) {
-                    ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
                 }
             } else if (block.getMaterial() != Material.AIR) {
                 block.attack(this.world, blockposition, this.player);
+
                 f = block.getDamage(this.player, this.player.world, blockposition);
-                // Allow fire punching to be blocked
-                this.world.douseFire((EntityHuman) null, blockposition, enumdirection);
+
+                this.world.douseFire(null, blockposition, enumdirection);
             }
 
             if (event.useItemInHand() == Event.Result.DENY) {
-                // If we 'insta destroyed' then the client needs to be informed.
                 if (f > 1.0f) {
-                    ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
+                    this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
                 }
+
                 return;
             }
+
             org.bukkit.event.block.BlockDamageEvent blockEvent = CraftEventFactory.callBlockDamageEvent(this.player, blockposition.getX(), blockposition.getY(), blockposition.getZ(), this.player.inventory.getItemInHand(), f >= 1.0f);
 
             if (blockEvent.isCancelled()) {
                 // Let the client know the block still exists
-                ((EntityPlayer) this.player).playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
+                this.player.playerConnection.sendPacket(new PacketPlayOutBlockChange(this.world, blockposition));
                 return;
             }
 
             if (blockEvent.getInstaBreak()) {
                 f = 2.0f;
             }
-            // CraftBukkit end
 
             if (block.getMaterial() != Material.AIR && f >= 1.0F) {
                 this.breakBlock(blockposition);
@@ -195,9 +194,7 @@ public class PlayerInteractManager {
                 this.world.c(this.player.getId(), blockposition, i);
                 this.k = i;
             }
-
         }
-        world.spigotConfig.antiXrayInstance.updateNearbyBlocks(world, blockposition); // Spigot
     }
 
     public void a(BlockPosition blockposition) {
@@ -254,7 +251,7 @@ public class PlayerInteractManager {
             org.bukkit.block.Block block = this.world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
 
             // Sword + Creative mode pre-cancel
-            boolean isSwordNoBreak = this.gamemode.d() && this.player.bA() != null && this.player.bA().getItem() instanceof ItemSword;
+            boolean isSwordNoBreak = this.gameMode.d() && this.player.bA() != null && this.player.bA().getItem() instanceof ItemSword;
 
             // Tell client the block is gone immediately then process events
             // Don't tell the client if its a creative sword break because its not broken!
@@ -299,7 +296,7 @@ public class PlayerInteractManager {
                 return false;
             }
         }
-        if (false && this.gamemode.d() && this.player.bA() != null && this.player.bA().getItem() instanceof ItemSword) {
+        if (false && this.gameMode.d() && this.player.bA() != null && this.player.bA().getItem() instanceof ItemSword) {
             return false;
         } else {
             IBlockData iblockdata = this.world.getType(blockposition);
@@ -313,8 +310,8 @@ public class PlayerInteractManager {
             }
             // CraftBukkit end
 
-            if (this.gamemode.c()) {
-                if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+            if (this.gameMode.c()) {
+                if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
                     return false;
                 }
 
@@ -363,7 +360,7 @@ public class PlayerInteractManager {
     }
 
     public boolean useItem(EntityHuman entityhuman, World world, ItemStack itemstack) {
-        if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+        if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
             return false;
         } else {
             int i = itemstack.count;
@@ -401,7 +398,7 @@ public class PlayerInteractManager {
 
     public boolean interact(EntityHuman entityhuman, World world, ItemStack itemstack, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2) {
         /* CraftBukkit start - whole method
-        if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+        if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
             TileEntity tileentity = world.getTileEntity(blockposition);
 
             if (tileentity instanceof ITileInventory) {
@@ -445,13 +442,13 @@ public class PlayerInteractManager {
                 return itemstack.placeItem(entityhuman, world, blockposition, enumdirection, f, f1, f2);
             }
         }
-        // Interract event */
+        // Interact event */
         IBlockData blockdata = world.getType(blockposition);
         boolean result = false;
         if (blockdata.getBlock() != Blocks.AIR) {
             boolean cancelledBlock = false;
 
-            if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+            if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
                 TileEntity tileentity = world.getTileEntity(blockposition);
                 cancelledBlock = !(tileentity instanceof ITileInventory || tileentity instanceof IInventory);
             }
@@ -460,7 +457,7 @@ public class PlayerInteractManager {
                 cancelledBlock = true;
             }
 
-            PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(entityhuman, Action.RIGHT_CLICK_BLOCK, blockposition, enumdirection, itemstack, cancelledBlock);
+            PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(entityhuman, Action.RIGHT_CLICK_BLOCK, blockposition, itemstack, cancelledBlock, enumdirection);
             firedInteract = true;
             interactResult = event.useItemInHand() == Event.Result.DENY;
 
@@ -471,7 +468,7 @@ public class PlayerInteractManager {
                     ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutBlockChange(world, bottom ? blockposition.up() : blockposition.down()));
                 }
                 result = (event.useItemInHand() != Event.Result.ALLOW);
-            } else if (this.gamemode == WorldSettings.EnumGamemode.SPECTATOR) {
+            } else if (this.gameMode == WorldSettings.EnumGamemode.SPECTATOR) {
                 TileEntity tileentity = world.getTileEntity(blockposition);
 
                 if (tileentity instanceof ITileInventory) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 3c2d3197..46a106c5 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -1,10 +1,15 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import lombok.Getter;
+
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
+
 import io.netty.buffer.Unpooled;
+
 import java.io.File;
 import java.net.SocketAddress;
 import java.text.SimpleDateFormat;
@@ -15,14 +20,13 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-// CraftBukkit start
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
-
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.TravelAgent;
@@ -37,7 +41,6 @@ import org.bukkit.event.player.PlayerRespawnEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.util.Vector;
 import org.spigotmc.event.player.PlayerSpawnLocationEvent;
-// CraftBukkit end
 
 public abstract class PlayerList {
 
@@ -63,15 +66,14 @@ public abstract class PlayerList {
     private boolean t;
     private int u;
 
-    // CraftBukkit start
+    @Getter
     private CraftServer cserver;
-    private final Map<String,EntityPlayer> playersByName = new org.spigotmc.CaseInsensitiveMap<EntityPlayer>();
+    private final Map<String,EntityPlayer> playersByName = new org.spigotmc.CaseInsensitiveMap<>();
 
     public PlayerList(MinecraftServer minecraftserver) {
         this.cserver = minecraftserver.server = new CraftServer(minecraftserver, this);
         minecraftserver.console = org.bukkit.craftbukkit.command.ColouredConsoleSender.getInstance();
         minecraftserver.reader.addCompleter(new org.bukkit.craftbukkit.command.ConsoleCommandCompleter(minecraftserver.server));
-        // CraftBukkit end
         
         this.k = new GameProfileBanList(PlayerList.a);
         this.l = new IpBanList(PlayerList.b);
@@ -84,6 +86,10 @@ public abstract class PlayerList {
         this.maxPlayers = 8;
     }
 
+    public void setMaxPlayers(int slots) {
+        this.maxPlayers = slots;
+    }
+
     public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
         GameProfile gameprofile = entityplayer.getProfile();
         UserCache usercache = this.server.getUserCache();
@@ -330,15 +336,12 @@ public abstract class PlayerList {
         for (int i = 0; i < this.players.size(); ++i) {
             EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
 
-            if (entityplayer1.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
+            if (!PotionSpigot.INSTANCE.getConfig().isHidePlayersFromTab() || entityplayer1.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
                 entityplayer1.playerConnection.sendPacket(packet);
             }
-
-            if (!entityplayer.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
-                continue;
+            if (!PotionSpigot.INSTANCE.getConfig().isHidePlayersFromTab() || entityplayer.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
+                entityplayer.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, entityplayer1));
             }
-
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer1}));
         }
         // CraftBukkit end
 
@@ -391,11 +394,13 @@ public abstract class PlayerList {
         for (int i = 0; i < players.size(); i++) {
             EntityPlayer entityplayer2 = (EntityPlayer) this.players.get(i);
 
-            if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer2.playerConnection.sendPacket(packet);
-            } else {
-                entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
+            entityplayer2.playerConnection.sendPacket(packet);
+
+            /*
+            if (!entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
+                entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity()); // SpigotX
             }
+            */
         }
         // This removes the scoreboard (and player reference) for the specific player in the manager
         cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
@@ -803,87 +808,41 @@ public abstract class PlayerList {
         return new Location(worldserver1.getWorld(), d0, y, d1, yaw, pitch);
     }
 
-    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
     public void repositionEntity(Entity entity, Location exit, boolean portal) {
-        WorldServer worldserver = (WorldServer) entity.world;
-        WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
-        int i = worldserver.dimension;
-
-        /*
-        double d0 = entity.locX;
-        double d1 = entity.locZ;
-        double d2 = 8.0D;
-        float f = entity.yaw;
+        WorldServer currentWorldServer = (WorldServer) entity.world;
+        WorldServer exitWorldServer = ((CraftWorld) exit.getWorld()).getHandle();
+        int i = currentWorldServer.dimension;
 
-        worldserver.methodProfiler.a("moving");
-        */
         entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
         if (entity.isAlive()) {
-            worldserver.entityJoinedWorld(entity, false);
+            currentWorldServer.entityJoinedWorld(entity, false);
         }
-        /*
-        if (entity.dimension == -1) {
-            d0 = MathHelper.a(d0 / d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 / d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        } else if (entity.dimension == 0) {
-            d0 = MathHelper.a(d0 * d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 * d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        } else {
-            BlockPosition blockposition;
 
-            if (i == 1) {
-                // use default NORMAL world spawn instead of target
-                worldserver1 = this.server.worlds.get(0);
-                blockposition = worldserver1.getSpawn();
-            } else {
-                blockposition = worldserver1.getDimensionSpawn();
-            }
+        currentWorldServer.methodProfiler.b();
 
-            d0 = (double) blockposition.getX();
-            entity.locY = (double) blockposition.getY();
-            d1 = (double) blockposition.getZ();
-            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        }
-        */
-
-        worldserver.methodProfiler.b();
         if (i != 1) {
-            worldserver.methodProfiler.a("placing");
-            /*
-            d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
-            d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
-            */
+            currentWorldServer.methodProfiler.a("placing");
+
             if (entity.isAlive()) {
-                // entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-                // worldserver1.getTravelAgent().a(entity, f);
                 if (portal) {
                     Vector velocity = entity.getBukkitEntity().getVelocity();
-                    worldserver1.getTravelAgent().adjustExit(entity, exit, velocity);
+
+                    exitWorldServer.getTravelAgent().adjustExit(entity, exit, velocity);
                     entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
                     if (entity.motX != velocity.getX() || entity.motY != velocity.getY() || entity.motZ != velocity.getZ()) {
                         entity.getBukkitEntity().setVelocity(velocity);
                     }
                 }
-                worldserver1.addEntity(entity);
-                worldserver1.entityJoinedWorld(entity, false);
+                exitWorldServer.addEntity(entity);
+                exitWorldServer.entityJoinedWorld(entity, false);
             }
 
-            worldserver.methodProfiler.b();
+            currentWorldServer.methodProfiler.b();
         }
 
-        entity.spawnIn(worldserver1);
-        // CraftBukkit end
+        entity.spawnIn(exitWorldServer);
     }
 
     public void tick() {
@@ -896,19 +855,19 @@ public abstract class PlayerList {
 
     public void sendAll(Packet packet) {
         for (int i = 0; i < this.players.size(); ++i) {
-            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
+            this.players.get(i).playerConnection.sendPacket(packet);
         }
-
     }
 
-    // CraftBukkit start - add a world/entity limited version
     public void sendAll(Packet packet, EntityHuman entityhuman) {
         for (int i = 0; i < this.players.size(); ++i) {
             EntityPlayer entityplayer =  this.players.get(i);
+
             if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
                 continue;
             }
-            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
+
+            this.players.get(i).playerConnection.sendPacket(packet);
         }
     }
 
@@ -918,11 +877,10 @@ public abstract class PlayerList {
         }
 
     }
-    // CraftBukkit end
 
     public void a(Packet packet, int i) {
         for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
+            EntityPlayer entityplayer = this.players.get(j);
 
             if (entityplayer.dimension == i) {
                 entityplayer.playerConnection.sendPacket(packet);
@@ -957,7 +915,7 @@ public abstract class PlayerList {
             this.sendMessage(ichatbasecomponent);
         } else {
             for (int i = 0; i < this.players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.players.get(i);
+                EntityPlayer entityplayer = this.players.get(i);
 
                 if (entityplayer.getScoreboardTeam() != scoreboardteambase) {
                     entityplayer.sendMessage(ichatbasecomponent);
@@ -1044,22 +1002,20 @@ public abstract class PlayerList {
     }
 
     public EntityPlayer getPlayer(String s) {
-        return this.playersByName.get(s); // Spigot
+        return this.playersByName.get(s);
     }
 
     public void sendPacketNearby(double d0, double d1, double d2, double d3, int i, Packet packet) {
-        this.sendPacketNearby((EntityHuman) null, d0, d1, d2, d3, i, packet);
+        this.sendPacketNearby(null, d0, d1, d2, d3, i, packet);
     }
 
     public void sendPacketNearby(EntityHuman entityhuman, double d0, double d1, double d2, double d3, int i, Packet packet) {
         for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
+            EntityPlayer entityplayer = this.players.get(j);
 
-            // CraftBukkit start - Test if player receiving packet can see the source of the packet
             if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
                continue;
             }
-            // CraftBukkit end
 
             if (entityplayer != entityhuman && entityplayer.dimension == i) {
                 double d4 = d0 - entityplayer.locX;
@@ -1074,9 +1030,29 @@ public abstract class PlayerList {
 
     }
 
+    public void sendPacketNearbyIncludingSelf(EntityHuman entityhuman, double d0, double d1, double d2, double d3, int i, Packet packet) { // SpigotX
+        for (int j = 0; j < this.players.size(); ++j) {
+            EntityPlayer entityplayer = this.players.get(j);
+
+            if (entityhuman != null && !entityplayer.getBukkitEntity().canSeeEntity(entityhuman.getBukkitEntity())) {
+                continue;
+            }
+
+            if (entityplayer.dimension == i) {
+                double d4 = d0 - entityplayer.locX;
+                double d5 = d1 - entityplayer.locY;
+                double d6 = d2 - entityplayer.locZ;
+
+                if (d4 * d4 + d5 * d5 + d6 * d6 < d3 * d3) {
+                    entityplayer.playerConnection.sendPacket(packet);
+                }
+            }
+        }
+    }
+
     public void savePlayers() {
         for (int i = 0; i < this.players.size(); ++i) {
-            this.savePlayerFile((EntityPlayer) this.players.get(i));
+            this.savePlayerFile(this.players.get(i));
         }
 
     }
@@ -1108,26 +1084,21 @@ public abstract class PlayerList {
     public void reloadWhitelist() {}
 
     public void b(EntityPlayer entityplayer, WorldServer worldserver) {
-        WorldBorder worldborder = entityplayer.world.getWorldBorder(); // CraftBukkit
+        WorldBorder worldborder = entityplayer.world.getWorldBorder();
 
         entityplayer.playerConnection.sendPacket(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.INITIALIZE));
         entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")));
+
         if (worldserver.S()) {
-            // CraftBukkit start - handle player weather
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(1, 0.0F));
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, worldserver.j(1.0F)));
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, worldserver.h(1.0F)));
             entityplayer.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
             entityplayer.updateWeather(-worldserver.p, worldserver.p, -worldserver.r, worldserver.r);
-            // CraftBukkit end
         }
 
     }
 
     public void updateClient(EntityPlayer entityplayer) {
         entityplayer.updateInventory(entityplayer.defaultContainer);
-        // entityplayer.triggerHealthUpdate();
-        entityplayer.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
+        entityplayer.getBukkitEntity().updateScaledHealth();
         entityplayer.playerConnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
     }
 
@@ -1190,9 +1161,8 @@ public abstract class PlayerList {
 
     public void u() {
         for (int i = 0; i < this.players.size(); ++i) {
-            ((EntityPlayer) this.players.get(i)).playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+            this.players.get(i).playerConnection.disconnect(this.server.server.getShutdownMessage());
         }
-
     }
 
     // CraftBukkit start
@@ -1207,9 +1177,7 @@ public abstract class PlayerList {
         this.server.sendMessage(ichatbasecomponent);
         int i = flag ? 1 : 0;
 
-        // CraftBukkit start - we run this through our processor first so we can get web links etc
         this.sendAll(new PacketPlayOutChat(CraftChatMessage.fixComponent(ichatbasecomponent), (byte) i));
-        // CraftBukkit end
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
@@ -1218,7 +1186,7 @@ public abstract class PlayerList {
 
     public ServerStatisticManager a(EntityHuman entityhuman) {
         UUID uuid = entityhuman.getUniqueID();
-        ServerStatisticManager serverstatisticmanager = uuid == null ? null : (ServerStatisticManager) this.o.get(uuid);
+        ServerStatisticManager serverstatisticmanager = uuid == null ? null : this.o.get(uuid);
 
         if (serverstatisticmanager == null) {
             File file = new File(this.server.getWorldServer(0).getDataManager().getDirectory(), "stats");
@@ -1243,13 +1211,8 @@ public abstract class PlayerList {
     public void a(int i) {
         this.r = i;
         if (this.server.worldServer != null) {
-            WorldServer[] aworldserver = this.server.worldServer;
-            int j = aworldserver.length;
-
-            // CraftBukkit start
             for (int k = 0; k < server.worlds.size(); ++k) {
                 WorldServer worldserver = server.worlds.get(0);
-                // CraftBukkit end
 
                 if (worldserver != null) {
                     worldserver.getPlayerChunkMap().a(i);
@@ -1264,10 +1227,18 @@ public abstract class PlayerList {
     }
 
     public EntityPlayer a(UUID uuid) {
-        return (EntityPlayer) this.j.get(uuid);
+        return this.j.get(uuid);
     }
 
     public boolean f(GameProfile gameprofile) {
         return false;
     }
+
+    public void removeFromPlayerNames(String name) {
+        this.playersByName.remove(name);
+    }
+
+    public void setPlayerName(String name, EntityPlayer player) {
+        this.playersByName.put(name, player);
+    }
 }
diff --git a/src/main/java/net/minecraft/server/SecondaryWorldServer.java b/src/main/java/net/minecraft/server/SecondaryWorldServer.java
index 209eb01d..afff85e7 100644
--- a/src/main/java/net/minecraft/server/SecondaryWorldServer.java
+++ b/src/main/java/net/minecraft/server/SecondaryWorldServer.java
@@ -35,7 +35,7 @@ public class SecondaryWorldServer extends WorldServer {
                 SecondaryWorldServer.this.getWorldBorder().setDamageAmount(d0);
             }
 
-            public void c(WorldBorder worldborder, double d0) {
+            public void setServerIp(WorldBorder worldborder, double d0) {
                 SecondaryWorldServer.this.getWorldBorder().setDamageBuffer(d0);
             }
         });
diff --git a/src/main/java/net/minecraft/server/ServerConnection.java b/src/main/java/net/minecraft/server/ServerConnection.java
index f13182c1..73aac899 100644
--- a/src/main/java/net/minecraft/server/ServerConnection.java
+++ b/src/main/java/net/minecraft/server/ServerConnection.java
@@ -68,8 +68,6 @@ public class ServerConnection {
     }
 
     public void a(InetAddress inetaddress, int i) throws IOException {
-        List list = this.g;
-
         synchronized (this.g) {
             Class oclass;
             LazyInitVar lazyinitvar;
@@ -77,29 +75,28 @@ public class ServerConnection {
             if (Epoll.isAvailable() && this.f.ai()) {
                 oclass = EpollServerSocketChannel.class;
                 lazyinitvar = ServerConnection.b;
-                ServerConnection.e.info("Using epoll channel type");
             } else {
                 oclass = NioServerSocketChannel.class;
                 lazyinitvar = ServerConnection.a;
-                ServerConnection.e.info("Using default channel type");
             }
 
-            this.g.add(((ServerBootstrap) ((ServerBootstrap) (new ServerBootstrap()).channel(oclass)).childHandler(new ChannelInitializer() {
-                protected void initChannel(Channel channel) throws Exception {
-                    try {
-                        channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(true));
-                    } catch (ChannelException channelexception) {
-                        ;
-                    }
+	        this.g.add(((new ServerBootstrap().channel(oclass)).childHandler(new ChannelInitializer() {
+		        protected void initChannel(Channel channel) throws Exception {
+			        try {
+				        channel.config().setOption(ChannelOption.TCP_NODELAY, Boolean.valueOf(true));
+			        } catch (ChannelException channelexception) {
+				        ;
+			        }
 
-                    channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(ServerConnection.this)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(EnumProtocolDirection.SERVERBOUND)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(EnumProtocolDirection.CLIENTBOUND));
-                    NetworkManager networkmanager = new NetworkManager(EnumProtocolDirection.SERVERBOUND);
+			        channel.pipeline().addLast("timeout", new ReadTimeoutHandler(30)).addLast("legacy_query", new LegacyPingHandler(ServerConnection.this)).addLast("splitter", new PacketSplitter()).addLast("decoder", new PacketDecoder(EnumProtocolDirection.SERVERBOUND)).addLast("prepender", new PacketPrepender()).addLast("encoder", new PacketEncoder(EnumProtocolDirection.CLIENTBOUND));
 
-                    ServerConnection.this.h.add(networkmanager);
-                    channel.pipeline().addLast("packet_handler", networkmanager);
-                    networkmanager.a((PacketListener) (new HandshakeListener(ServerConnection.this.f, networkmanager)));
-                }
-            }).group((EventLoopGroup) lazyinitvar.c()).localAddress(inetaddress, i)).bind().syncUninterruptibly());
+			        NetworkManager networkmanager = new NetworkManager(EnumProtocolDirection.SERVERBOUND);
+
+			        ServerConnection.this.h.add(networkmanager);
+			        channel.pipeline().addLast("packet_handler", networkmanager);
+			        networkmanager.a((new HandshakeListener(ServerConnection.this.f, networkmanager)));
+		        }
+	        }).group((EventLoopGroup) lazyinitvar.c()).localAddress(inetaddress, i)).bind().syncUninterruptibly());
         }
     }
 
@@ -120,16 +117,7 @@ public class ServerConnection {
     }
 
     public void c() {
-        List list = this.h;
-
         synchronized (this.h) {
-            // Spigot Start
-            // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
-            if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
-            {
-                Collections.shuffle( this.h );
-            }
-            // Spigot End
             Iterator iterator = this.h.iterator();
 
             while (iterator.hasNext()) {
@@ -137,10 +125,10 @@ public class ServerConnection {
 
                 if (!networkmanager.h()) {
                     if (!networkmanager.g()) {
-                        // Spigot Start
-                        // Fix a race condition where a NetworkManager could be unregistered just before connection.
-                        if (networkmanager.preparing) continue;
-                        // Spigot End
+                        if (networkmanager.preparing) {
+                            continue;
+                        }
+
                         iterator.remove();
                         networkmanager.l();
                     } else {
@@ -176,11 +164,11 @@ public class ServerConnection {
                     }
                 }
             }
-
         }
     }
 
     public MinecraftServer d() {
         return this.f;
     }
+
 }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index f68b132f..b72170ad 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -1,252 +1,265 @@
 package net.minecraft.server;
 
+import org.potionspigot.util.OptimizedRemoveUtil;
+import co.aikar.timings.SpigotTimings;
+import co.aikar.timings.Timing;
 import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.concurrent.Callable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
-
-import co.aikar.timings.SpigotTimings; // Spigot
-import co.aikar.timings.Timing; // Spigot
-import org.bukkit.inventory.InventoryHolder; // CraftBukkit
+import org.bukkit.inventory.InventoryHolder;
 import org.github.paperspigot.exception.ServerInternalException;
 
-public abstract class TileEntity {
-
-    public Timing tickTimer = SpigotTimings.getTileEntityTimings(this); // Spigot
-    private static final Logger a = LogManager.getLogger();
-    private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
-    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();
-    protected World world;
-    protected BlockPosition position;
-    protected boolean d;
-    private int h;
-    protected Block e;
-
-    public TileEntity() {
-        this.position = BlockPosition.ZERO;
-        this.h = -1;
-    }
-
-    private static void a(Class<? extends TileEntity> oclass, String s) {
-        if (TileEntity.f.containsKey(s)) {
-            throw new IllegalArgumentException("Duplicate id: " + s);
-        } else {
-            TileEntity.f.put(s, oclass);
-            TileEntity.g.put(oclass, s);
-        }
-    }
-
-    public World getWorld() {
-        return this.world;
-    }
-
-    public void a(World world) {
-        this.world = world;
-    }
-
-    public boolean t() {
-        return this.world != null;
-    }
-
-    public void a(NBTTagCompound nbttagcompound) {
-        this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
-    }
-
-    public void b(NBTTagCompound nbttagcompound) {
-        String s = (String) TileEntity.g.get(this.getClass());
-
-        if (s == null) {
-            throw new RuntimeException(this.getClass() + " is missing a mapping! This is a bug!");
-        } else {
-            nbttagcompound.setString("id", s);
-            nbttagcompound.setInt("x", this.position.getX());
-            nbttagcompound.setInt("y", this.position.getY());
-            nbttagcompound.setInt("z", this.position.getZ());
-        }
-    }
-
-    public static TileEntity c(NBTTagCompound nbttagcompound) {
-        TileEntity tileentity = null;
-
-        try {
-            Class oclass = (Class) TileEntity.f.get(nbttagcompound.getString("id"));
-
-            if (oclass != null) {
-                tileentity = (TileEntity) oclass.newInstance();
-            }
-        } catch (Exception exception) {
-            exception.printStackTrace();
-            ServerInternalException.reportInternalException(exception); // Paper
-        }
-
-        if (tileentity != null) {
-            tileentity.a(nbttagcompound);
-        } else {
-            TileEntity.a.warn("Skipping BlockEntity with id " + nbttagcompound.getString("id"));
-        }
-
-        return tileentity;
-    }
-
-    public int u() {
-        if (this.h == -1) {
-            IBlockData iblockdata = this.world.getType(this.position);
-
-            this.h = iblockdata.getBlock().toLegacyData(iblockdata);
-        }
-
-        return this.h;
-    }
-
-    public void update() {
-        if (this.world != null) {
-            IBlockData iblockdata = this.world.getType(this.position);
-
-            this.h = iblockdata.getBlock().toLegacyData(iblockdata);
-            this.world.b(this.position, this);
-            if (this.w() != Blocks.AIR) {
-                this.world.updateAdjacentComparators(this.position, this.w());
-            }
-        }
-
-    }
-
-    public BlockPosition getPosition() {
-        return this.position;
-    }
-
-    public Block w() {
-        if (this.e == null) {
-            this.e = this.world.getType(this.position).getBlock();
-        }
-
-        return this.e;
-    }
-
-    public Packet getUpdatePacket() {
-        return null;
-    }
-
-    public boolean x() {
-        return this.d;
-    }
-
-    public void y() {
-        this.d = true;
-    }
-
-    public void D() {
-        this.d = false;
-    }
-
-    public boolean c(int i, int j) {
-        return false;
-    }
-
-    public void E() {
-        this.e = null;
-        this.h = -1;
-    }
-
-    public void a(CrashReportSystemDetails crashreportsystemdetails) {
-        crashreportsystemdetails.a("Name", new Callable() {
-            public String a() throws Exception {
-                return (String) TileEntity.g.get(TileEntity.this.getClass()) + " // " + TileEntity.this.getClass().getCanonicalName();
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        if (this.world != null) {
-            // PaperSpigot start - Prevent tile entity and entity crashes
-            Block block = this.w();
-            if (block != null) {
-                CrashReportSystemDetails.a(crashreportsystemdetails, this.position, this.w(), this.u());
-            }
-            // PaperSpigot end
-            crashreportsystemdetails.a("Actual block type", new Callable() {
-                public String a() throws Exception {
-                    int i = Block.getId(TileEntity.this.world.getType(TileEntity.this.position).getBlock());
-
-                    try {
-                        return String.format("ID #%d (%s // %s)", new Object[] { Integer.valueOf(i), Block.getById(i).a(), Block.getById(i).getClass().getCanonicalName()});
-                    } catch (Throwable throwable) {
-                        return "ID #" + i;
-                    }
-                }
-
-                public Object call() throws Exception {
-                    return this.a();
-                }
-            });
-            crashreportsystemdetails.a("Actual block data value", new Callable() {
-                public String a() throws Exception {
-                    IBlockData iblockdata = TileEntity.this.world.getType(TileEntity.this.position);
-                    int i = iblockdata.getBlock().toLegacyData(iblockdata);
-
-                    if (i < 0) {
-                        return "Unknown? (Got " + i + ")";
-                    } else {
-                        String s = String.format("%4s", new Object[] { Integer.toBinaryString(i)}).replace(" ", "0");
-
-                        return String.format("%1$d / 0x%1$X / 0b%2$s", new Object[] { Integer.valueOf(i), s});
-                    }
-                }
-
-                public Object call() throws Exception {
-                    return this.a();
-                }
-            });
-        }
-    }
-
-    public void a(BlockPosition blockposition) {
-        this.position = blockposition;
-    }
-
-    public boolean F() {
-        return false;
-    }
-
-    static {
-        a(TileEntityFurnace.class, "Furnace");
-        a(TileEntityChest.class, "Chest");
-        a(TileEntityEnderChest.class, "EnderChest");
-        a(BlockJukeBox.TileEntityRecordPlayer.class, "RecordPlayer");
-        a(TileEntityDispenser.class, "Trap");
-        a(TileEntityDropper.class, "Dropper");
-        a(TileEntitySign.class, "Sign");
-        a(TileEntityMobSpawner.class, "MobSpawner");
-        a(TileEntityNote.class, "Music");
-        a(TileEntityPiston.class, "Piston");
-        a(TileEntityBrewingStand.class, "Cauldron");
-        a(TileEntityEnchantTable.class, "EnchantTable");
-        a(TileEntityEnderPortal.class, "Airportal");
-        a(TileEntityCommand.class, "Control");
-        a(TileEntityBeacon.class, "Beacon");
-        a(TileEntitySkull.class, "Skull");
-        a(TileEntityLightDetector.class, "DLDetector");
-        a(TileEntityHopper.class, "Hopper");
-        a(TileEntityComparator.class, "Comparator");
-        a(TileEntityFlowerPot.class, "FlowerPot");
-        a(TileEntityBanner.class, "Banner");
-    }
-
-    // CraftBukkit start - add method
-    public InventoryHolder getOwner() {
-        if (world == null) return null;
-        // Spigot start
-        org.bukkit.block.Block block = world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ());
-        if (block == null) {
-            org.bukkit.Bukkit.getLogger().log(java.util.logging.Level.WARNING, "No block for owner at %s %d %d %d", new Object[]{world.getWorld(), position.getX(), position.getY(), position.getZ()});
-            return null;
-        }
-        // Spigot end
-        org.bukkit.block.BlockState state = block.getState();
-        if (state instanceof InventoryHolder) return (InventoryHolder) state;
-        return null;
-    }
-    // CraftBukkit end
+public abstract class TileEntity implements OptimizedRemoveUtil.Marker {
+
+	public Timing tickTimer = SpigotTimings.getTileEntityTimings(this); // Spigot
+	private static final Logger a = LogManager.getLogger();
+	private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
+	private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();
+	protected World world;
+	protected BlockPosition position;
+	protected boolean d;
+	private int h;
+	protected Block e;
+
+	private boolean needsRemoval = false;
+
+	public TileEntity() {
+		this.position = BlockPosition.ZERO;
+		this.h = -1;
+	}
+
+	private static void a(Class<? extends TileEntity> oclass, String s) {
+		if (TileEntity.f.containsKey(s)) {
+			throw new IllegalArgumentException("Duplicate id: " + s);
+		} else {
+			TileEntity.f.put(s, oclass);
+			TileEntity.g.put(oclass, s);
+		}
+	}
+
+	public World getWorld() {
+		return this.world;
+	}
+
+	public void a(World world) {
+		this.world = world;
+	}
+
+	public boolean t() {
+		return this.world != null;
+	}
+
+	public void a(NBTTagCompound nbttagcompound) {
+		this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
+	}
+
+	public void b(NBTTagCompound nbttagcompound) {
+		String s = (String) TileEntity.g.get(this.getClass());
+
+		if (s == null) {
+			throw new RuntimeException(this.getClass() + " is missing a mapping! This is a bug!");
+		} else {
+			nbttagcompound.setString("id", s);
+			nbttagcompound.setInt("x", this.position.getX());
+			nbttagcompound.setInt("y", this.position.getY());
+			nbttagcompound.setInt("z", this.position.getZ());
+		}
+	}
+
+	public static TileEntity c(NBTTagCompound nbttagcompound) {
+		TileEntity tileentity = null;
+
+		try {
+			Class oclass = (Class) TileEntity.f.get(nbttagcompound.getString("id"));
+
+			if (oclass != null) {
+				tileentity = (TileEntity) oclass.newInstance();
+			}
+		} catch (Exception exception) {
+			exception.printStackTrace();
+			ServerInternalException.reportInternalException(exception); // Paper
+		}
+
+		if (tileentity != null) {
+			tileentity.a(nbttagcompound);
+		} else {
+			TileEntity.a.warn("Skipping BlockEntity with id " + nbttagcompound.getString("id"));
+		}
+
+		return tileentity;
+	}
+
+	public int u() {
+		if (this.h == -1) {
+			IBlockData iblockdata = this.world.getType(this.position);
+
+			this.h = iblockdata.getBlock().toLegacyData(iblockdata);
+		}
+
+		return this.h;
+	}
+
+	public void update() {
+		if (this.world != null) {
+			IBlockData iblockdata = this.world.getType(this.position);
+
+			this.h = iblockdata.getBlock().toLegacyData(iblockdata);
+			this.world.b(this.position, this);
+			if (this.w() != Blocks.AIR) {
+				this.world.updateAdjacentComparators(this.position, this.w());
+			}
+		}
+
+	}
+
+	public BlockPosition getPosition() {
+		return this.position;
+	}
+
+	public Block w() {
+		if (this.e == null) {
+			this.e = this.world.getType(this.position).getBlock();
+		}
+
+		return this.e;
+	}
+
+	public Packet getUpdatePacket() {
+		return null;
+	}
+
+	public boolean x() {
+		return this.d;
+	}
+
+	public void y() {
+		this.d = true;
+	}
+
+	public void D() {
+		this.d = false;
+	}
+
+	public boolean c(int i, int j) {
+		return false;
+	}
+
+	public void E() {
+		this.e = null;
+		this.h = -1;
+	}
+
+	public void a(CrashReportSystemDetails crashreportsystemdetails) {
+		crashreportsystemdetails.a("Name", new Callable() {
+			public String a() throws Exception {
+				return (String) TileEntity.g.get(TileEntity.this.getClass()) + " // " + TileEntity.this.getClass().getCanonicalName();
+			}
+
+			public Object call() throws Exception {
+				return this.a();
+			}
+		});
+		if (this.world != null) {
+			// PaperSpigot start - Prevent tile entity and entity crashes
+			Block block = this.w();
+			if (block != null) {
+				CrashReportSystemDetails.a(crashreportsystemdetails, this.position, this.w(), this.u());
+			}
+			// PaperSpigot end
+			crashreportsystemdetails.a("Actual block type", new Callable() {
+				public String a() throws Exception {
+					int i = Block.getId(TileEntity.this.world.getType(TileEntity.this.position).getBlock());
+
+					try {
+						return String.format("ID #%d (%s // %s)", new Object[]{Integer.valueOf(i), Block.getById(i).a(), Block.getById(i).getClass().getCanonicalName()});
+					} catch (Throwable throwable) {
+						return "ID #" + i;
+					}
+				}
+
+				public Object call() throws Exception {
+					return this.a();
+				}
+			});
+			crashreportsystemdetails.a("Actual block data value", new Callable() {
+				public String a() throws Exception {
+					IBlockData iblockdata = TileEntity.this.world.getType(TileEntity.this.position);
+					int i = iblockdata.getBlock().toLegacyData(iblockdata);
+
+					if (i < 0) {
+						return "Unknown? (Got " + i + ")";
+					} else {
+						String s = String.format("%4s", new Object[]{Integer.toBinaryString(i)}).replace(" ", "0");
+
+						return String.format("%1$d / 0x%1$X / 0b%2$s", new Object[]{Integer.valueOf(i), s});
+					}
+				}
+
+				public Object call() throws Exception {
+					return this.a();
+				}
+			});
+		}
+	}
+
+	public void a(BlockPosition blockposition) {
+		this.position = blockposition;
+	}
+
+	public boolean F() {
+		return false;
+	}
+
+	static {
+		a(TileEntityFurnace.class, "Furnace");
+		a(TileEntityChest.class, "Chest");
+		a(TileEntityEnderChest.class, "EnderChest");
+		a(BlockJukeBox.TileEntityRecordPlayer.class, "RecordPlayer");
+		a(TileEntityDispenser.class, "Trap");
+		a(TileEntityDropper.class, "Dropper");
+		a(TileEntitySign.class, "Sign");
+		a(TileEntityMobSpawner.class, "MobSpawner");
+		a(TileEntityNote.class, "Music");
+		a(TileEntityPiston.class, "Piston");
+		a(TileEntityBrewingStand.class, "Cauldron");
+		a(TileEntityEnchantTable.class, "EnchantTable");
+		a(TileEntityEnderPortal.class, "Airportal");
+		a(TileEntityCommand.class, "Control");
+		a(TileEntityBeacon.class, "Beacon");
+		a(TileEntitySkull.class, "Skull");
+		a(TileEntityLightDetector.class, "DLDetector");
+		a(TileEntityHopper.class, "Hopper");
+		a(TileEntityComparator.class, "Comparator");
+		a(TileEntityFlowerPot.class, "FlowerPot");
+		a(TileEntityBanner.class, "Banner");
+	}
+
+	// CraftBukkit start - add method
+	public InventoryHolder getOwner() {
+		if (world == null) return null;
+		// Spigot start
+		org.bukkit.block.Block block = world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ());
+		if (block == null) {
+			org.bukkit.Bukkit.getLogger().log(java.util.logging.Level.WARNING, "No block for owner at %s %d %d %d", new Object[]{world.getWorld(), position.getX(), position.getY(), position.getZ()});
+			return null;
+		}
+		// Spigot end
+		org.bukkit.block.BlockState state = block.getState();
+		if (state instanceof InventoryHolder) return (InventoryHolder) state;
+		return null;
+	}
+	// CraftBukkit end+
+	// TacoSpigot start
+	@Override
+	public boolean isNeedRemoval() {
+		return this.needsRemoval;
+	}
+
+	@Override
+	public void markRemoval() {
+		this.needsRemoval = true;
+	}
+	// TacoSpigot end
 }
diff --git a/src/main/java/net/minecraft/server/UserCache.java b/src/main/java/net/minecraft/server/UserCache.java
index 0f82e06c..1d0a9461 100644
--- a/src/main/java/net/minecraft/server/UserCache.java
+++ b/src/main/java/net/minecraft/server/UserCache.java
@@ -84,7 +84,7 @@ public class UserCache {
 
         minecraftserver.getGameProfileRepository().findProfilesByNames(new String[] { s}, Agent.MINECRAFT, profilelookupcallback);
         if (!minecraftserver.getOnlineMode() && agameprofile[0] == null) {
-            UUID uuid = EntityHuman.a(new GameProfile((UUID) null, s));
+            UUID uuid = EntityHuman.a(new GameProfile(null, s));
             GameProfile gameprofile = new GameProfile(uuid, s);
 
             profilelookupcallback.onProfileLookupSucceeded(gameprofile);
@@ -94,7 +94,7 @@ public class UserCache {
     }
 
     public void a(GameProfile gameprofile) {
-        this.a(gameprofile, (Date) null);
+        this.a(gameprofile, null);
     }
 
     private void a(GameProfile gameprofile, Date date) {
diff --git a/src/main/java/net/minecraft/server/VillageSiege.java b/src/main/java/net/minecraft/server/VillageSiege.java
index 01dbc98a..0c02d195 100644
--- a/src/main/java/net/minecraft/server/VillageSiege.java
+++ b/src/main/java/net/minecraft/server/VillageSiege.java
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import net.jafama.FastMath;
 import org.github.paperspigot.exception.ServerInternalException;
 
 import java.util.Iterator;
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 8f3511f8..1f8e4767 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.util.OptimizedRemoveUtil;
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
@@ -10,12 +12,10 @@ import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
-import co.aikar.timings.SpigotTimings;
 
 import java.util.*;
 import java.util.concurrent.Callable;
@@ -138,7 +138,7 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
-    public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
+    public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("Paper - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
     public static long chunkToKey(int x, int z)
@@ -534,7 +534,6 @@ public abstract class World implements IBlockAccess {
         this.d(blockposition.up(), block);
         this.d(blockposition.north(), block);
         this.d(blockposition.south(), block);
-        spigotConfig.antiXrayInstance.updateNearbyBlocks(this, blockposition); // Spigot
     }
 
     public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
@@ -941,10 +940,15 @@ public abstract class World implements IBlockAccess {
     }
 
     public void makeSound(Entity entity, String s, float f, float f1) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(s, entity.locX, entity.locY, entity.locZ, f, f1);
+        if (entity instanceof EntityHuman) {
+            for (IWorldAccess anU : this.u) {
+                anU.a((EntityHuman) entity, s, entity.locX, entity.locY, entity.locZ, f, f1);
+            }
+        } else {
+            for (IWorldAccess anU : this.u) {
+                anU.a(s, entity.locX, entity.locY, entity.locZ, f, f1);
+            }
         }
-
     }
 
     public void a(EntityHuman entityhuman, String s, float f, float f1) {
@@ -1308,12 +1312,12 @@ public abstract class World implements IBlockAccess {
     public int a(float f) {
         float f1 = this.c(f);
         float f2 = 1.0F - (MathHelper.cos(f1 * 3.1415927F * 2.0F) * 2.0F + 0.5F);
-
         f2 = MathHelper.a(f2, 0.0F, 1.0F);
         f2 = 1.0F - f2;
         f2 = (float) ((double) f2 * (1.0D - (double) (this.j(f) * 5.0F) / 16.0D));
         f2 = (float) ((double) f2 * (1.0D - (double) (this.h(f) * 5.0F) / 16.0D));
         f2 = 1.0F - f2;
+
         return (int) (f2 * 11.0F);
     }
 
@@ -1398,7 +1402,8 @@ public abstract class World implements IBlockAccess {
 
         this.methodProfiler.c("remove");
         timings.entityRemoval.startTiming(); // Spigot
-        this.entityList.removeAll(this.g);
+        //this.entityList.removeAll(this.g);
+        tickPosition = OptimizedRemoveUtil.removeAll(this.entityList, this.g, tickPosition);
 
         int j;
         int k;
@@ -1487,8 +1492,11 @@ public abstract class World implements IBlockAccess {
         this.M = true;
         // CraftBukkit start - From below, clean up tile entities before ticking them
         if (!this.c.isEmpty()) {
-            this.tileEntityList.removeAll(this.c);
-            //this.h.removeAll(this.c); // PaperSpigot - Remove unused list
+            // SpigotX start - use OptimizedRemoveUtil
+            //this.tileEntityList.removeAll(this.setServerIp);
+            tileTickPosition = OptimizedRemoveUtil.removeAll(this.tileEntityList, this.c, tileTickPosition);
+            // SpigotX end
+            //this.h.removeAll(this.setServerIp); // PaperSpigot - Remove unused list
             this.c.clear();
         }
         // CraftBukkit end
@@ -1548,10 +1556,10 @@ public abstract class World implements IBlockAccess {
         timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
         /* CraftBukkit start - Moved up
-        if (!this.c.isEmpty()) {
-            this.tileEntityList.removeAll(this.c);
-            this.h.removeAll(this.c);
-            this.c.clear();
+        if (!this.setServerIp.isEmpty()) {
+            this.tileEntityList.removeAll(this.setServerIp);
+            this.h.removeAll(this.setServerIp);
+            this.setServerIp.clear();
         }
         // CraftBukkit end */
 
@@ -1620,10 +1628,9 @@ public abstract class World implements IBlockAccess {
     public void entityJoinedWorld(Entity entity, boolean flag) {
         int i = MathHelper.floor(entity.locX);
         int j = MathHelper.floor(entity.locZ);
-        byte b0 = 32;
 
         // Spigot start
-        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+        if (PotionSpigot.INSTANCE.getConfig().isEntityActivation() && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
             entity.inactiveTick();
             // PaperSpigot start - Remove entities in unloaded chunks
@@ -1708,7 +1715,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, Entity entity) {
-        List list = this.getEntities((Entity) null, axisalignedbb);
+        List list = this.getEntities(null, axisalignedbb);
 
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
@@ -2105,7 +2112,7 @@ public abstract class World implements IBlockAccess {
         this.allowAnimals = flag1;
     }
 
-    public void doTick() {
+    public void doTick(int ticks) {
         this.p();
     }
 
@@ -3098,29 +3105,29 @@ public abstract class World implements IBlockAccess {
 
     public void a(int i, BlockPosition blockposition, int j) {
         for (int k = 0; k < this.u.size(); ++k) {
-            ((IWorldAccess) this.u.get(k)).a(i, blockposition, j);
+            this.u.get(k).a(i, blockposition, j);
         }
 
     }
 
     public void triggerEffect(int i, BlockPosition blockposition, int j) {
-        this.a((EntityHuman) null, i, blockposition, j);
+        this.a(null, i, blockposition, j);
     }
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         try {
             for (int k = 0; k < this.u.size(); ++k) {
-                ((IWorldAccess) this.u.get(k)).a(entityhuman, i, blockposition, j);
+                this.u.get(k).a(entityhuman, i, blockposition, j);
             }
-
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Playing level event");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Level event being played");
 
-            crashreportsystemdetails.a("Block coordinates", (Object) CrashReportSystemDetails.a(blockposition));
-            crashreportsystemdetails.a("Event source", (Object) entityhuman);
-            crashreportsystemdetails.a("Event type", (Object) Integer.valueOf(i));
-            crashreportsystemdetails.a("Event data", (Object) Integer.valueOf(j));
+            crashreportsystemdetails.a("Block coordinates", CrashReportSystemDetails.a(blockposition));
+            crashreportsystemdetails.a("Event source", entityhuman);
+            crashreportsystemdetails.a("Event type", i);
+            crashreportsystemdetails.a("Event data", j);
+
             throw new ReportedException(crashreport);
         }
     }
@@ -3178,7 +3185,7 @@ public abstract class World implements IBlockAccess {
 
     public void c(int i, BlockPosition blockposition, int j) {
         for (int k = 0; k < this.u.size(); ++k) {
-            IWorldAccess iworldaccess = (IWorldAccess) this.u.get(k);
+            IWorldAccess iworldaccess = this.u.get(k);
 
             iworldaccess.b(i, blockposition, j);
         }
diff --git a/src/main/java/net/minecraft/server/WorldManager.java b/src/main/java/net/minecraft/server/WorldManager.java
index 55a2112d..5f176675 100644
--- a/src/main/java/net/minecraft/server/WorldManager.java
+++ b/src/main/java/net/minecraft/server/WorldManager.java
@@ -29,8 +29,11 @@ public class WorldManager implements IWorldAccess {
     }
 
     public void a(EntityHuman entityhuman, String s, double d0, double d1, double d2, float f, float f1) {
-        // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        if (s.equals("random.drink") || s.contains("step") || s.contains("player") || s.equals("random.eat")) {
+            this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        } else {
+            this.a.getPlayerList().sendPacketNearbyIncludingSelf(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        }
     }
 
     public void a(int i, int j, int k, int l, int i1, int j1) {}
@@ -44,8 +47,13 @@ public class WorldManager implements IWorldAccess {
     public void a(String s, BlockPosition blockposition) {}
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
-        // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        if (i == 2001) {
+            this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        } else {
+            this.a.getPlayerList().sendPacketNearbyIncludingSelf(entityhuman, (double) blockposition.getX(), (double)
+                    blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, new
+                    PacketPlayOutWorldEvent(i, blockposition, j, false));
+        }
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 87529552..689ca29f 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -1,33 +1,31 @@
 package net.minecraft.server;
 
+import org.potionspigot.PotionSpigot;
+
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
+
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-// CraftBukkit start
 import java.util.*;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
-// CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
 
@@ -35,8 +33,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private final MinecraftServer server;
     public EntityTracker tracker;
     private final PlayerChunkMap manager;
-    // private final Set<NextTickListEntry> L = Sets.newHashSet(); // PAIL: Rename nextTickListHash
-    private final HashTreeSet<NextTickListEntry> M = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet // PAIL: Rename nextTickList
+    private final HashTreeSet<NextTickListEntry> M = new HashTreeSet<>();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     public ChunkProviderServer chunkProviderServer;
     public boolean savingDisabled;
@@ -45,27 +42,41 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private final PortalTravelAgent Q;
     private final SpawnerCreature R = new SpawnerCreature();
     protected final VillageSiege siegeManager = new VillageSiege(this);
-    private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
+    private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[]{
+            new WorldServer.BlockActionDataList(null),
+            new WorldServer.BlockActionDataList(null)
+    };
     private int T;
-    private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
+    private static final List<StructurePieceTreasure> U = Lists.newArrayList(
+            new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10),
+            new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10),
+            new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10),
+            new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3),
+            new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5),
+            new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3),
+            new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5),
+            new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5),
+            new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3),
+            new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10));
     private List<NextTickListEntry> V = Lists.newArrayList();
 
-    // CraftBukkit start
     public final int dimension;
 
-    // Add env and gen to constructor
     public WorldServer(MinecraftServer minecraftserver, IDataManager idatamanager, WorldData worlddata, int i, MethodProfiler methodprofiler, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
         super(idatamanager, worlddata, WorldProvider.byDimension(env.getId()), methodprofiler, false, gen, env);
+
         this.dimension = i;
         this.pvpMode = minecraftserver.getPVP();
         worlddata.world = this;
-        // CraftBukkit end
         this.server = minecraftserver;
         this.tracker = new EntityTracker(this);
-        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance); // Spigot
+        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance);
+
         this.worldProvider.a(this);
+
         this.chunkProvider = this.k();
-        this.Q = ((org.bukkit.craftbukkit.CraftTravelAgent) new org.bukkit.craftbukkit.CraftTravelAgent(this).setSearchRadius(paperSpigotConfig.portalSearchRadius)); // CraftBukkit // Paper - configurable search radius
+        this.Q = ((org.bukkit.craftbukkit.CraftTravelAgent) new org.bukkit.craftbukkit.CraftTravelAgent(this).setSearchRadius(paperSpigotConfig.portalSearchRadius));
+
         this.B();
         this.C();
         this.getWorldBorder().a(minecraftserver.aI());
@@ -81,52 +92,51 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             this.worldMaps.a(s, this.villages);
         } else {
             this.villages = persistentvillage;
-            this.villages.a((World) this);
+
+            this.villages.a(this);
         }
 
-        if (getServer().getScoreboardManager() == null) { // CraftBukkit
-        this.scoreboard = new ScoreboardServer(this.server);
-        PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
+        if (getServer().getScoreboardManager() == null) {
+            this.scoreboard = new ScoreboardServer(this.server);
 
-        if (persistentscoreboard == null) {
-            persistentscoreboard = new PersistentScoreboard();
-            this.worldMaps.a("scoreboard", persistentscoreboard);
-        }
+            PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
 
-        persistentscoreboard.a(this.scoreboard);
-        ((ScoreboardServer) this.scoreboard).a(persistentscoreboard);
-        // CraftBukkit start
+            if (persistentscoreboard == null) {
+                persistentscoreboard = new PersistentScoreboard();
+                this.worldMaps.a("scoreboard", persistentscoreboard);
+            }
+
+            persistentscoreboard.a(this.scoreboard);
+            ((ScoreboardServer) this.scoreboard).a(persistentscoreboard);
         } else {
             this.scoreboard = getServer().getScoreboardManager().getMainScoreboard().getHandle();
         }
-        // CraftBukkit end
+
         this.getWorldBorder().setCenter(this.worldData.C(), this.worldData.D());
         this.getWorldBorder().setDamageAmount(this.worldData.I());
         this.getWorldBorder().setDamageBuffer(this.worldData.H());
         this.getWorldBorder().setWarningDistance(this.worldData.J());
         this.getWorldBorder().setWarningTime(this.worldData.K());
+
         if (this.worldData.F() > 0L) {
             this.getWorldBorder().transitionSizeBetween(this.worldData.E(), this.worldData.G(), this.worldData.F());
         } else {
             this.getWorldBorder().setSize(this.worldData.E());
         }
 
-        // CraftBukkit start
         if (generator != null) {
             getWorld().getPopulators().addAll(generator.getDefaultPopulators(getWorld()));
         }
-        // CraftBukkit end
 
         return this;
     }
 
-    // CraftBukkit start
     @Override
     public TileEntity getTileEntity(BlockPosition pos) {
         TileEntity result = super.getTileEntity(pos);
         Block type = getType(pos).getBlock();
 
-        if (type == Blocks.CHEST || type == Blocks.TRAPPED_CHEST) { // Spigot
+        if (type == Blocks.CHEST || type == Blocks.TRAPPED_CHEST) {
             if (!(result instanceof TileEntityChest)) {
                 result = fixTileEntity(pos, type, result);
             }
@@ -180,8 +190,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     }
 
     private TileEntity fixTileEntity(BlockPosition pos, Block type, TileEntity found) {
-        this.getServer().getLogger().log(Level.SEVERE, "Block at {0},{1},{2} is {3} but has {4}" + ". "
-                + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[]{pos.getX(), pos.getY(), pos.getZ(), org.bukkit.Material.getMaterial(Block.getId(type)).toString(), found});
+        this.getServer().getLogger().log(Level.SEVERE, "Block at {0},{1},{2} is {3} but has {4}. Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[]{
+                pos.getX(),
+                pos.getY(),
+                pos.getZ(),
+                org.bukkit.Material.getMaterial(Block.getId(type)),
+                found
+        });
 
         if (type instanceof IContainer) {
             TileEntity replacement = ((IContainer) type).a(this, type.toLegacyData(this.getType(pos)));
@@ -201,15 +216,16 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             return this.worldProvider.canSpawn(x, z);
         }
     }
-    // CraftBukkit end
 
-    public void doTick() {
-        super.doTick();
+    public void doTick(int ticks) {
+        super.doTick(ticks);
+
         if (this.getWorldData().isHardcore() && this.getDifficulty() != EnumDifficulty.HARD) {
             this.getWorldData().setDifficulty(EnumDifficulty.HARD);
         }
 
         this.worldProvider.m().b();
+
         if (this.everyoneDeeplySleeping()) {
             if (this.getGameRules().getBoolean("doDaylightCycle")) {
                 long i = this.worldData.getDayTime() + 24000L;
@@ -220,58 +236,75 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             this.e();
         }
 
-        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
         long time = this.worldData.getTime();
+
         if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
-            timings.mobSpawn.startTiming(); // Spigot
-            this.R.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
-            timings.mobSpawn.stopTiming(); // Spigot
-            // CraftBukkit end
+            timings.mobSpawn.startTiming();
+            this.R.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this
+                    .ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time %
+                    this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            timings.mobSpawn.stopTiming();
         }
-        // CraftBukkit end
-        timings.doChunkUnload.startTiming(); // Spigot
-        this.methodProfiler.c("chunkSource");
-        this.chunkProvider.unloadChunks();
+
+        timings.doChunkUnload.startTiming();
+
+        if (PotionSpigot.INSTANCE.getConfig().isDoChunkUnload()) {
+            this.methodProfiler.c("chunkSource");
+            this.chunkProvider.unloadChunks();
+        }
+
         int j = this.a(1.0F);
 
         if (j != this.ab()) {
             this.c(j);
         }
 
-        this.worldData.setTime(this.worldData.getTime() + 1L);
-        if (this.getGameRules().getBoolean("doDaylightCycle")) {
-            this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
+        if (ticks % DedicatedServer.NORMAL_TICK_TIME == 0) {
+            this.worldData.setTime(this.worldData.getTime() + 1L);
+
+            if (this.getGameRules().getBoolean("doDaylightCycle")) {
+                this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
+            }
         }
 
-        timings.doChunkUnload.stopTiming(); // Spigot
+        timings.doChunkUnload.stopTiming();
+
+        // Tick scheduled blocks
         this.methodProfiler.c("tickPending");
-        timings.scheduledBlocks.startTiming(); // Spigot
+        timings.scheduledBlocks.startTiming();
         this.a(false);
-        timings.scheduledBlocks.stopTiming(); // Spigot
+        timings.scheduledBlocks.stopTiming();
+
+        // Tick current blocks
         this.methodProfiler.c("tickBlocks");
-        timings.chunkTicks.startTiming(); // Spigot
+        timings.chunkTicks.startTiming();
         this.h();
-        timings.chunkTicks.stopTiming(); // Spigot
-        spigotConfig.antiXrayInstance.flushUpdates(this); // PaperSpigot
+        timings.chunkTicks.stopTiming();
+
+        // Tick chunk map
         this.methodProfiler.c("chunkMap");
-        timings.doChunkMap.startTiming(); // Spigot
+        timings.doChunkMap.startTiming();
         this.manager.flush();
-        timings.doChunkMap.stopTiming(); // Spigot
+        timings.doChunkMap.stopTiming();
+
+        // Tick villages and village sieges
         this.methodProfiler.c("village");
-        timings.doVillages.startTiming(); // Spigot
+        timings.doVillages.startTiming();
         this.villages.tick();
         this.siegeManager.a();
-        timings.doVillages.stopTiming(); // Spigot
+        timings.doVillages.stopTiming();
+
         this.methodProfiler.c("portalForcer");
-        timings.doPortalForcer.startTiming(); // Spigot
+        timings.doPortalForcer.startTiming();
         this.Q.a(this.getTime());
-        timings.doPortalForcer.stopTiming(); // Spigot
+        timings.doPortalForcer.stopTiming();
+
+        // Tick sounds
         this.methodProfiler.b();
-        timings.doSounds.startTiming(); // Spigot
+        timings.doSounds.startTiming();
         this.ak();
-
-        this.getWorld().processChunkGC(); // CraftBukkit
-        timings.doChunkGC.stopTiming(); // Spigot
+        this.getWorld().processChunkGC();
+        timings.doChunkGC.stopTiming();
     }
 
     public BiomeBase.BiomeMeta a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
@@ -325,28 +358,22 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     private void ag() {
         this.worldData.setStorm(false);
-        // CraftBukkit start
-        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
-        // Not that everyone ever manages to get the whole server to sleep at the same time....
+
         if (!this.worldData.hasStorm()) {
             this.worldData.setWeatherDuration(0);
         }
-        // CraftBukkit end
+
         this.worldData.setThundering(false);
-        // CraftBukkit start
-        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
-        // Not that everyone ever manages to get the whole server to sleep at the same time....
+
         if (!this.worldData.isThundering()) {
             this.worldData.setThunderDuration(0);
         }
-        // CraftBukkit end
     }
 
     public boolean everyoneDeeplySleeping() {
         if (this.O && !this.isClientSide) {
             Iterator iterator = this.players.iterator();
 
-            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
             boolean foundActualSleepers = false;
 
             EntityHuman entityhuman;
@@ -358,12 +385,10 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
                 entityhuman = (EntityHuman) iterator.next();
 
-                // CraftBukkit start
                 if (entityhuman.isDeeplySleeping()) {
                     foundActualSleepers = true;
                 }
             } while (!entityhuman.isSpectator() || entityhuman.isDeeplySleeping() || entityhuman.fauxSleeping);
-            // CraftBukkit end
 
             return false;
         } else {
@@ -373,96 +398,87 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     protected void h() {
         super.h();
+
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            // Spigot start
-           gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
+            gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
 
             while (iterator.hasNext()) {
                 iterator.advance();
+
                 long chunkCoord = iterator.key();
 
-                this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
-                // Spigot end
+                this.getChunkAt(World.keyToX(chunkCoord), World.keyToZ(chunkCoord)).b(false);
             }
 
         } else {
-            int i = 0;
-            int j = 0;
-
-            // CraftBukkit start
-            //for (Iterator iterator1 = this.chunkTickList.iterator(); iterator1.hasNext(); this.methodProfiler.b()) {
-            //    ChunkCoordIntPair chunkcoordintpair1 = (ChunkCoordIntPair) iterator1.next();
-            //    int k = chunkcoordintpair1.x * 16;
-            //    int l = chunkcoordintpair1.z * 16;
-            // Spigot start
-            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
-            {
+            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); ) {
                 iter.advance();
                 long chunkCoord = iter.key();
-                int chunkX = World.keyToX( chunkCoord );
-                int chunkZ = World.keyToZ( chunkCoord );
-                // If unloaded, or in procedd of being unloaded, drop it
-                if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
-                {
+                int chunkX = World.keyToX(chunkCoord);
+                int chunkZ = World.keyToZ(chunkCoord);
+
+                if ((!this.chunkProvider.isChunkLoaded(chunkX, chunkZ)) || (this.chunkProviderServer.unloadQueue.contains(chunkX, chunkZ))) {
                     iter.remove();
                     continue;
                 }
-                // Spigot end
-                // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+
                 int k = chunkX * 16;
                 int l = chunkZ * 16;
 
                 this.methodProfiler.a("getChunk");
                 Chunk chunk = this.getChunkAt(chunkX, chunkZ);
-                // CraftBukkit end
-
                 this.a(k, l, chunk);
                 this.methodProfiler.c("tickChunk");
                 chunk.b(false);
                 this.methodProfiler.c("thunder");
+
                 int i1;
                 BlockPosition blockposition;
 
-                if (!this.paperSpigotConfig.disableThunder && this.random.nextInt(100000) == 0 && this.S() && this.R()) { // PaperSpigot - Disable thunder
+                if (!this.paperSpigotConfig.disableThunder && this.random.nextInt(100000) == 0 && this.S() && this.R()) {
                     this.m = this.m * 3 + 1013904223;
                     i1 = this.m >> 2;
                     blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+
                     if (this.isRainingAt(blockposition)) {
                         this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
                     }
                 }
 
                 this.methodProfiler.c("iceandsnow");
-                if (!this.paperSpigotConfig.disableIceAndSnow && this.random.nextInt(16) == 0) { // PaperSpigot - Disable ice and snow
+
+                if (!this.paperSpigotConfig.disableIceAndSnow && this.random.nextInt(16) == 0) {
                     this.m = this.m * 3 + 1013904223;
                     i1 = this.m >> 2;
                     blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
                     BlockPosition blockposition1 = blockposition.down();
 
                     if (this.w(blockposition1)) {
-                        // CraftBukkit start
                         BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+
                         blockState.setTypeId(Block.getId(Blocks.ICE));
 
                         BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+
                         this.getServer().getPluginManager().callEvent(iceBlockForm);
+
                         if (!iceBlockForm.isCancelled()) {
                             blockState.update(true);
                         }
-                        // CraftBukkit end
                     }
 
                     if (this.S() && this.f(blockposition, true)) {
-                        // CraftBukkit start
                         BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+
                         blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
 
                         BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+
                         this.getServer().getPluginManager().callEvent(snow);
+
                         if (!snow.isCancelled()) {
                             blockState.update(true);
                         }
-                        // CraftBukkit end
                     }
 
                     if (this.S() && this.getBiome(blockposition1).e()) {
@@ -471,45 +487,45 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                 }
 
                 this.methodProfiler.c("tickBlocks");
-                timings.chunkTicksBlocks.startTiming(); // Spigot
-                i1 = this.getGameRules().c("randomTickSpeed");
-                if (i1 > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int j1 = achunksection.length;
-
-                    for (int k1 = 0; k1 < j1; ++k1) {
-                        ChunkSection chunksection = achunksection[k1];
-
-                        if (chunksection != null && chunksection.shouldTick()) {
-                            for (int l1 = 0; l1 < i1; ++l1) {
-                                this.m = this.m * 3 + 1013904223;
-                                int i2 = this.m >> 2;
-                                int j2 = i2 & 15;
-                                int k2 = i2 >> 8 & 15;
-                                int l2 = i2 >> 16 & 15;
-
-                                ++j;
-                                IBlockData iblockdata = chunksection.getType(j2, l2, k2);
-                                Block block = iblockdata.getBlock();
-
-                                if (block.isTicking()) {
-                                    ++i;
-                                    block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+
+                if (PotionSpigot.INSTANCE.getConfig().isBlockOperations()) {
+                    timings.chunkTicksBlocks.startTiming();
+
+                    i1 = this.getGameRules().c("randomTickSpeed");
+
+                    if (i1 > 0) {
+                        ChunkSection[] achunksection = chunk.getSections();
+                        int j1 = achunksection.length;
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            ChunkSection chunksection = achunksection[k1];
+
+                            if (chunksection != null && chunksection.shouldTick()) {
+                                for (int l1 = 0; l1 < i1; ++l1) {
+                                    this.m = this.m * 3 + 1013904223;
+                                    int i2 = this.m >> 2;
+                                    int j2 = i2 & 15;
+                                    int k2 = i2 >> 8 & 15;
+                                    int l2 = i2 >> 16 & 15;
+                                    IBlockData iblockdata = chunksection.getType(j2, l2, k2);
+                                    Block block = iblockdata.getBlock();
+
+                                    if (block.isTicking()) {
+                                        block.a(this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+
+                                    }
                                 }
                             }
                         }
                     }
+                    timings.chunkTicksBlocks.stopTiming();
                 }
-                timings.chunkTicksBlocks.stopTiming(); // Spigot
             }
-
         }
-        // Spigot Start
-        if ( spigotConfig.clearChunksOnTick )
-        {
+
+        if (spigotConfig.clearChunksOnTick) {
             chunkTickList.clear();
         }
-        // Spigot End
     }
 
     protected BlockPosition a(BlockPosition blockposition) {
@@ -517,7 +533,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition1, new BlockPosition(blockposition1.getX(), this.getHeight(), blockposition1.getZ()))).grow(3.0D, 3.0D, 3.0D);
         List list = this.a(EntityLiving.class, axisalignedbb, new Predicate() {
             public boolean a(EntityLiving entityliving) {
-                return entityliving != null && entityliving.isAlive() && WorldServer.this.i(entityliving.getChunkCoordinates());
+                return entityliving != null && entityliving.isAlive() && WorldServer.this.i(entityliving
+                        .getChunkCoordinates());
             }
 
             public boolean apply(Object object) {
@@ -545,10 +562,12 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         if (this.e && block.getMaterial() != Material.AIR) {
             if (block.N()) {
                 b0 = 8;
-                if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0, b0))) {
+                if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0,
+                        b0))) {
                     IBlockData iblockdata = this.getType(nextticklistentry.a);
 
-                    if (iblockdata.getBlock().getMaterial() != Material.AIR && iblockdata.getBlock() == nextticklistentry.a()) {
+                    if (iblockdata.getBlock().getMaterial() != Material.AIR && iblockdata.getBlock() ==
+                            nextticklistentry.a()) {
                         iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
                     }
                 }
@@ -589,7 +608,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     }
 
     public void tickEntities() {
-        if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
+        if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers
+            // with no players
             if (this.emptyTime++ >= 1200) {
                 return;
             }
@@ -674,12 +694,14 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                     iterator.remove();
                     byte b0 = 0;
 
-                    if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0, b0))) {
+                    if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0,
+                            b0, b0))) {
                         IBlockData iblockdata = this.getType(nextticklistentry.a);
                         co.aikar.timings.Timing timing = iblockdata.getBlock().getTiming(); // Spigot
                         timing.startTiming(); // Spigot
 
-                        if (iblockdata.getBlock().getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
+                        if (iblockdata.getBlock().getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(),
+                                nextticklistentry.a())) {
                             try {
                                 iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
                             } catch (Throwable throwable) {
@@ -730,7 +752,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                 NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
                 BlockPosition blockposition = nextticklistentry.a;
 
-                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d
+                        && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() <
+                        structureboundingbox.f) {
                     if (flag) {
                         // CraftBukkit - use M
                         iterator.remove();
@@ -803,7 +827,9 @@ public class WorldServer extends World implements IAsyncTaskHandler {
                 }
                 for (Object te : chunk.tileEntities.values()) {
                     TileEntity tileentity = (TileEntity) te;
-                    if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)) {
+                    if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity
+                            .position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY()
+                            < i1) && (tileentity.position.getZ() < j1)) {
                         arraylist.add(tileentity);
                     }
                 }
@@ -814,7 +840,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             TileEntity tileentity = (TileEntity) this.h.get(k1);
             BlockPosition blockposition = tileentity.getPosition();
 
-            if (blockposition.getX() >= i && blockposition.getY() >= j && blockposition.getZ() >= k && blockposition.getX() < l && blockposition.getY() < i1 && blockposition.getZ() < j1) {
+            if (blockposition.getX() >= i && blockposition.getY() >= j && blockposition.getZ() >= k && blockposition
+            .getX() < l && blockposition.getY() < i1 && blockposition.getZ() < j1) {
                 arraylist.add(tileentity);
             }
         }
@@ -890,9 +917,11 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
                 if (spawn != null) {
                     if (spawn.getWorld() != ((WorldServer) this).getWorld()) {
-                        throw new IllegalStateException("Cannot set spawn point for " + this.worldData.getName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                        throw new IllegalStateException("Cannot set spawn point for " + this.worldData.getName() + " " +
+                                "to be in another world (" + spawn.getWorld().getName() + ")");
                     } else {
-                        this.worldData.setSpawn(new BlockPosition(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()));
+                        this.worldData.setSpawn(new BlockPosition(spawn.getBlockX(), spawn.getBlockY(), spawn
+                                .getBlockZ()));
                         this.isLoading = false;
                         return;
                     }
@@ -948,7 +977,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     public void save(boolean flag, IProgressUpdate iprogressupdate) throws ExceptionWorldConflict {
         if (this.chunkProvider.canSave()) {
-            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
+            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); //
+            // CraftBukkit
             if (iprogressupdate != null) {
                 iprogressupdate.a("Saving level");
             }
@@ -1029,14 +1059,16 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     public boolean strikeLightning(Entity entity) {
         // CraftBukkit start
-        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) entity.getBukkitEntity());
+        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity
+                .LightningStrike) entity.getBukkitEntity());
         this.getServer().getPluginManager().callEvent(lightning);
 
         if (lightning.isCancelled()) {
             return false;
         }
         if (super.strikeLightning(entity)) {
-            this.server.getPlayerList().sendPacketNearby(entity.locX, entity.locY, entity.locZ, 512.0D, dimension, new PacketPlayOutSpawnEntityWeather(entity));
+            this.server.getPlayerList().sendPacketNearby(entity.locX, entity.locY, entity.locZ, 512.0D, dimension,
+                    new PacketPlayOutSpawnEntityWeather(entity));
             // CraftBukkit end
             return true;
         } else {
@@ -1048,7 +1080,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         this.getTracker().sendPacketToEntity(entity, new PacketPlayOutEntityStatus(entity, b0));
     }
 
-    public Explosion createExplosion(Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
+    public Explosion createExplosion(Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean
+            flag1) {
         // CraftBukkit start
         Explosion explosion = super.createExplosion(entity, d0, d1, d2, f, flag, flag1);
 
@@ -1073,7 +1106,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             EntityHuman entityhuman = (EntityHuman) iterator.next();
 
             if (entityhuman.e(d0, d1, d2) < 4096.0D) {
-                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), (Vec3D) explosion.b().get(entityhuman)));
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f,
+                        explosion.getBlocks(), (Vec3D) explosion.b().get(entityhuman)));
             }
         }
 
@@ -1109,7 +1143,10 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
                 if (this.a(blockactiondata)) {
                     // CraftBukkit - this.worldProvider.dimension -> this.dimension
-                    this.server.getPlayerList().sendPacketNearby((double) blockactiondata.a().getX(), (double) blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, dimension, new PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.d(), blockactiondata.b(), blockactiondata.c()));
+                    this.server.getPlayerList().sendPacketNearby((double) blockactiondata.a().getX(), (double)
+                            blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, dimension, new
+                            PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.d(), blockactiondata.b(),
+                            blockactiondata.c()));
                 }
             }
 
@@ -1121,7 +1158,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private boolean a(BlockActionData blockactiondata) {
         IBlockData iblockdata = this.getType(blockactiondata.a());
 
-        return iblockdata.getBlock() == blockactiondata.d() ? iblockdata.getBlock().a(this, blockactiondata.a(), iblockdata, blockactiondata.b(), blockactiondata.c()) : false;
+        return iblockdata.getBlock() == blockactiondata.d() ? iblockdata.getBlock().a(this, blockactiondata.a(),
+                iblockdata, blockactiondata.b(), blockactiondata.c()) : false;
     }
 
     public void saveLevel() {
@@ -1134,11 +1172,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         super.p();
         /* CraftBukkit start
         if (this.o != this.p) {
-            this.server.getPlayerList().a(new PacketPlayOutGameStateChange(7, this.p), this.worldProvider.getDimension());
+            this.server.getPlayerList().a(new PacketPlayOutGameStateChange(7, this.p), this.worldProvider
+            .getDimension());
         }
 
         if (this.q != this.r) {
-            this.server.getPlayerList().a(new PacketPlayOutGameStateChange(8, this.r), this.worldProvider.getDimension());
+            this.server.getPlayerList().a(new PacketPlayOutGameStateChange(8, this.r), this.worldProvider
+            .getDimension());
         }
 
         if (flag != this.S()) {
@@ -1156,7 +1196,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             // Only send weather packets to those affected
             for (int i = 0; i < this.players.size(); ++i) {
                 if (((EntityPlayer) this.players.get(i)).world == this) {
-                    ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                    ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType
+                            .CLEAR), false);
                 }
             }
         }
@@ -1189,27 +1230,33 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         return this.Q;
     }
 
-    public void a(EnumParticle enumparticle, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+    public void a(EnumParticle enumparticle, double d0, double d1, double d2, int i, double d3, double d4, double d5,
+                  double d6, int... aint) {
         this.a(enumparticle, false, d0, d1, d2, i, d3, d4, d5, d6, aint);
     }
 
-    public void a(EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+    public void a(EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double
+            d4, double d5, double d6, int... aint) {
         // CraftBukkit - visibility api support
         sendParticles(null, enumparticle, flag, d0, d1, d2, i, d3, d4, d5, d6, aint);
     }
 
-    public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+    public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1,
+                              double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
         // CraftBukkit end
-        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
+        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag,
+                (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
 
         for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
-            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
-            BlockPosition blockposition = entityplayer.getChunkCoordinates();
+            EntityPlayer player = (EntityPlayer) this.players.get(j);
+            if (sender != null && !player.getBukkitEntity().canSee(sender.getBukkitEntity())) {
+                continue; // CraftBukkit
+            }
+            BlockPosition blockposition = player.getChunkCoordinates();
             double d7 = blockposition.c(d0, d1, d2);
 
             if (d7 <= 256.0D || flag && d7 <= 65536.0D) {
-                entityplayer.playerConnection.sendPacket(packetplayoutworldparticles);
+                player.playerConnection.sendPacket(packetplayoutworldparticles);
             }
         }
 
@@ -1229,7 +1276,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     static class BlockActionDataList extends ArrayList<BlockActionData> {
 
-        private BlockActionDataList() {}
+        private BlockActionDataList() {
+        }
 
         BlockActionDataList(Object object) {
             this();
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
index 8a33e282..887a0463 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftChunk.java
@@ -1,311 +1,340 @@
 package org.bukkit.craftbukkit;
 
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-
-import net.minecraft.server.*;
-
+import org.potionspigot.chunk.CraftFakeMultiBlockChange;
+import org.potionspigot.chunk.FakeMultiBlockChange;
+import net.minecraft.server.BiomeBase;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.ChunkSection;
+import net.minecraft.server.EmptyChunk;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.PacketPlayOutMultiBlockChange;
+import net.minecraft.server.WorldChunkManager;
+import net.minecraft.server.WorldServer;
 import org.bukkit.Chunk;
+import org.bukkit.ChunkSnapshot;
+import org.bukkit.Location;
 import org.bukkit.World;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.entity.Entity;
-import org.bukkit.ChunkSnapshot;
-
-public class CraftChunk implements Chunk {
-    private WeakReference<net.minecraft.server.Chunk> weakChunk;
-    private final WorldServer worldServer;
-    private final int x;
-    private final int z;
-    private static final byte[] emptyData = new byte[2048];
-    private static final short[] emptyBlockIDs = new short[4096];
-    private static final byte[] emptySkyLight = new byte[2048];
-
-    public CraftChunk(net.minecraft.server.Chunk chunk) {
-        if (!(chunk instanceof EmptyChunk)) {
-            this.weakChunk = new WeakReference<net.minecraft.server.Chunk>(chunk);
-        }
 
-        worldServer = (WorldServer) getHandle().world;
-        x = getHandle().locX;
-        z = getHandle().locZ;
-    }
-
-    public World getWorld() {
-        return worldServer.getWorld();
-    }
-
-    public CraftWorld getCraftWorld() {
-        return (CraftWorld) getWorld();
-    }
-
-    public net.minecraft.server.Chunk getHandle() {
-        net.minecraft.server.Chunk c = weakChunk.get();
-
-        if (c == null) {
-            c = worldServer.getChunkAt(x, z);
-
-            if (!(c instanceof EmptyChunk)) {
-                weakChunk = new WeakReference<net.minecraft.server.Chunk>(c);
-            }
-        }
+import java.lang.ref.WeakReference;
+import java.util.Arrays;
 
-        return c;
-    }
-
-    void breakLink() {
-        weakChunk.clear();
-    }
-
-    public int getX() {
-        return x;
-    }
-
-    public int getZ() {
-        return z;
-    }
-
-    @Override
-    public String toString() {
-        return "CraftChunk{" + "x=" + getX() + "z=" + getZ() + '}';
-    }
-
-    public Block getBlock(int x, int y, int z) {
-        return new CraftBlock(this, (getX() << 4) | (x & 0xF), y, (getZ() << 4) | (z & 0xF));
-    }
-
-    public Entity[] getEntities() {
-        int count = 0, index = 0;
-        net.minecraft.server.Chunk chunk = getHandle();
-
-        for (int i = 0; i < 16; i++) {
-            count += chunk.entitySlices[i].size();
-        }
-
-        Entity[] entities = new Entity[count];
-
-        for (int i = 0; i < 16; i++) {
-
-            for (Object obj : chunk.entitySlices[i].toArray()) {
-                if (!(obj instanceof net.minecraft.server.Entity)) {
-                    continue;
-                }
-
-                entities[index++] = ((net.minecraft.server.Entity) obj).getBukkitEntity();
-            }
-        }
-
-        return entities;
-    }
-
-    public BlockState[] getTileEntities() {
-        int index = 0;
-        net.minecraft.server.Chunk chunk = getHandle();
-
-        BlockState[] entities = new BlockState[chunk.tileEntities.size()];
-
-        for (Object obj : chunk.tileEntities.keySet().toArray()) {
-            if (!(obj instanceof BlockPosition)) {
-                continue;
-            }
-
-            BlockPosition position = (BlockPosition) obj;
-            entities[index++] = worldServer.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()).getState();
-        }
-
-        return entities;
-    }
-
-    public boolean isLoaded() {
-        return getWorld().isChunkLoaded(this);
-    }
-
-    public boolean load() {
-        return getWorld().loadChunk(getX(), getZ(), true);
-    }
-
-    public boolean load(boolean generate) {
-        return getWorld().loadChunk(getX(), getZ(), generate);
-    }
-
-    public boolean unload() {
-        return getWorld().unloadChunk(getX(), getZ());
-    }
-
-    public boolean unload(boolean save) {
-        return getWorld().unloadChunk(getX(), getZ(), save);
-    }
-
-    public boolean unload(boolean save, boolean safe) {
-        return getWorld().unloadChunk(getX(), getZ(), save, safe);
-    }
-
-    public ChunkSnapshot getChunkSnapshot() {
-        return getChunkSnapshot(true, false, false);
-    }
-
-    public ChunkSnapshot getChunkSnapshot(boolean includeMaxBlockY, boolean includeBiome, boolean includeBiomeTempRain) {
-        net.minecraft.server.Chunk chunk = getHandle();
-
-        ChunkSection[] cs = chunk.getSections();
-        short[][] sectionBlockIDs = new short[cs.length][];
-        byte[][] sectionBlockData = new byte[cs.length][];
-        byte[][] sectionSkyLights = new byte[cs.length][];
-        byte[][] sectionEmitLights = new byte[cs.length][];
-        boolean[] sectionEmpty = new boolean[cs.length];
-
-        for (int i = 0; i < cs.length; i++) {
-            if (cs[i] == null) { // Section is empty?
-                sectionBlockIDs[i] = emptyBlockIDs;
-                sectionBlockData[i] = emptyData;
-                sectionSkyLights[i] = emptySkyLight;
-                sectionEmitLights[i] = emptyData;
-                sectionEmpty[i] = true;
-            } else { // Not empty
-                short[] blockids = new short[4096];
-                char[] baseids = cs[i].getIdArray();
-                byte[] dataValues = sectionBlockData[i] = new byte[2048];
-
-                // Copy base IDs
-                for (int j = 0; j < 4096; j++) {
-                    if (baseids[j] == 0) continue;
-                    IBlockData blockData = (IBlockData) net.minecraft.server.Block.d.a(baseids[j]);
-                    if (blockData == null) continue;
-                    blockids[j] = (short) net.minecraft.server.Block.getId(blockData.getBlock());
-                    int data = blockData.getBlock().toLegacyData(blockData);
-                    int jj = j >> 1;
-                    if ((j & 1) == 0) {
-                        dataValues[jj] = (byte) ((dataValues[jj] & 0xF0) | (data & 0xF));
-                    } else {
-                        dataValues[jj] = (byte) ((dataValues[jj] & 0xF) | ((data & 0xF) << 4));
-                    }
-                }               
-
-                sectionBlockIDs[i] = blockids;
-                
-                if (cs[i].getSkyLightArray() == null) {
-                    sectionSkyLights[i] = emptyData;
-                } else {
-                    sectionSkyLights[i] = new byte[2048];
-                    System.arraycopy(cs[i].getSkyLightArray().a(), 0, sectionSkyLights[i], 0, 2048);
-                }
-                sectionEmitLights[i] = new byte[2048];
-                System.arraycopy(cs[i].getEmittedLightArray().a(), 0, sectionEmitLights[i], 0, 2048);
-            }
-        }
-
-        int[] hmap = null;
-
-        if (includeMaxBlockY) {
-            hmap = new int[256]; // Get copy of height map
-            System.arraycopy(chunk.heightMap, 0, hmap, 0, 256);
-        }
-
-        BiomeBase[] biome = null;
-        double[] biomeTemp = null;
-        double[] biomeRain = null;
-
-        if (includeBiome || includeBiomeTempRain) {
-            WorldChunkManager wcm = chunk.world.getWorldChunkManager();
-
-            if (includeBiome) {
-                biome = new BiomeBase[256];
-                for (int i = 0; i < 256; i++) {
-                    biome[i] = chunk.getBiome(new BlockPosition(i & 0xF, 0, i >> 4), wcm);
-                }
-            }
-
-            if (includeBiomeTempRain) {
-                biomeTemp = new double[256];
-                biomeRain = new double[256];
-                float[] dat = getTemperatures(wcm, getX() << 4, getZ() << 4);
-
-                for (int i = 0; i < 256; i++) {
-                    biomeTemp[i] = dat[i];
-                }
-
-                dat = wcm.getWetness(null, getX() << 4, getZ() << 4, 16, 16);
-
-                for (int i = 0; i < 256; i++) {
-                    biomeRain[i] = dat[i];
-                }
-            }
-        }
-
-        World world = getWorld();
-        return new CraftChunkSnapshot(getX(), getZ(), world.getName(), world.getFullTime(), sectionBlockIDs, sectionBlockData, sectionSkyLights, sectionEmitLights, sectionEmpty, hmap, biome, biomeTemp, biomeRain);
-    }
-
-    public static ChunkSnapshot getEmptyChunkSnapshot(int x, int z, CraftWorld world, boolean includeBiome, boolean includeBiomeTempRain) {
-        BiomeBase[] biome = null;
-        double[] biomeTemp = null;
-        double[] biomeRain = null;
-
-        if (includeBiome || includeBiomeTempRain) {
-            WorldChunkManager wcm = world.getHandle().getWorldChunkManager();
-
-            if (includeBiome) {
-                biome = new BiomeBase[256];
-                for (int i = 0; i < 256; i++) {
-                    biome[i] = world.getHandle().getBiome(new BlockPosition((x << 4) + (i & 0xF), 0, (z << 4) + (i >> 4)));
-                }
-            }
-
-            if (includeBiomeTempRain) {
-                biomeTemp = new double[256];
-                biomeRain = new double[256];
-                float[] dat = getTemperatures(wcm, x << 4, z << 4);
-
-                for (int i = 0; i < 256; i++) {
-                    biomeTemp[i] = dat[i];
-                }
-
-                dat = wcm.getWetness(null, x << 4, z << 4, 16, 16);
-
-                for (int i = 0; i < 256; i++) {
-                    biomeRain[i] = dat[i];
-                }
-            }
-        }
-
-        /* Fill with empty data */
-        int hSection = world.getMaxHeight() >> 4;
-        short[][] blockIDs = new short[hSection][];
-        byte[][] skyLight = new byte[hSection][];
-        byte[][] emitLight = new byte[hSection][];
-        byte[][] blockData = new byte[hSection][];
-        boolean[] empty = new boolean[hSection];
-
-        for (int i = 0; i < hSection; i++) {
-            blockIDs[i] = emptyBlockIDs;
-            skyLight[i] = emptySkyLight;
-            emitLight[i] = emptyData;
-            blockData[i] = emptyData;
-            empty[i] = true;
-        }
-
-        return new CraftChunkSnapshot(x, z, world.getName(), world.getFullTime(), blockIDs, blockData, skyLight, emitLight, empty, new int[256], biome, biomeTemp, biomeRain);
-    }
-
-    private static float[] getTemperatures(WorldChunkManager chunkmanager, int chunkX, int chunkZ) {
-        BiomeBase[] biomes = chunkmanager.getBiomes(null, chunkX, chunkZ, 16, 16);
-        float[] temps = new float[biomes.length];
-
-        for (int i = 0; i < biomes.length; i++) {
-            float temp = biomes[i].temperature; // Vanilla of olde: ((int) biomes[i].temperature * 65536.0F) / 65536.0F
-
-            if (temp > 1F) {
-                temp = 1F;
-            }
-
-            temps[i] = temp;
-        }
-
-        return temps;
-    }
-
-    static {
-        Arrays.fill(emptySkyLight, (byte) 0xFF);
-    }
+public class CraftChunk implements Chunk {
+	private static final byte[] emptyData = new byte[2048];
+	private static final short[] emptyBlockIDs = new short[4096];
+	private static final byte[] emptySkyLight = new byte[2048];
+
+	static {
+		Arrays.fill(emptySkyLight, (byte) 0xFF);
+	}
+
+	private final WorldServer worldServer;
+	private final int x;
+	private final int z;
+	private WeakReference<net.minecraft.server.Chunk> weakChunk;
+
+	public CraftChunk(net.minecraft.server.Chunk chunk) {
+		if (!(chunk instanceof EmptyChunk)) {
+			this.weakChunk = new WeakReference<net.minecraft.server.Chunk>(chunk);
+		}
+
+		worldServer = (WorldServer) getHandle().world;
+		x = getHandle().locX;
+		z = getHandle().locZ;
+	}
+
+	public static ChunkSnapshot getEmptyChunkSnapshot(int x, int z, CraftWorld world, boolean includeBiome, boolean includeBiomeTempRain) {
+		BiomeBase[] biome = null;
+		double[] biomeTemp = null;
+		double[] biomeRain = null;
+
+		if (includeBiome || includeBiomeTempRain) {
+			WorldChunkManager wcm = world.getHandle().getWorldChunkManager();
+
+			if (includeBiome) {
+				biome = new BiomeBase[256];
+				for (int i = 0; i < 256; i++) {
+					biome[i] = world.getHandle().getBiome(new BlockPosition((x << 4) + (i & 0xF), 0, (z << 4) + (i >> 4)));
+				}
+			}
+
+			if (includeBiomeTempRain) {
+				biomeTemp = new double[256];
+				biomeRain = new double[256];
+				float[] dat = getTemperatures(wcm, x << 4, z << 4);
+
+				for (int i = 0; i < 256; i++) {
+					biomeTemp[i] = dat[i];
+				}
+
+				dat = wcm.getWetness(null, x << 4, z << 4, 16, 16);
+
+				for (int i = 0; i < 256; i++) {
+					biomeRain[i] = dat[i];
+				}
+			}
+		}
+
+		/* Fill with empty data */
+		int hSection = world.getMaxHeight() >> 4;
+		short[][] blockIDs = new short[hSection][];
+		byte[][] skyLight = new byte[hSection][];
+		byte[][] emitLight = new byte[hSection][];
+		byte[][] blockData = new byte[hSection][];
+		boolean[] empty = new boolean[hSection];
+
+		for (int i = 0; i < hSection; i++) {
+			blockIDs[i] = emptyBlockIDs;
+			skyLight[i] = emptySkyLight;
+			emitLight[i] = emptyData;
+			blockData[i] = emptyData;
+			empty[i] = true;
+		}
+
+		return new CraftChunkSnapshot(x, z, world.getName(), world.getFullTime(), blockIDs, blockData, skyLight, emitLight, empty, new int[256], biome, biomeTemp, biomeRain);
+	}
+
+	private static float[] getTemperatures(WorldChunkManager chunkmanager, int chunkX, int chunkZ) {
+		BiomeBase[] biomes = chunkmanager.getBiomes(null, chunkX, chunkZ, 16, 16);
+		float[] temps = new float[biomes.length];
+
+		for (int i = 0; i < biomes.length; i++) {
+			float temp = biomes[i].temperature; // Vanilla of olde: ((int) biomes[i].temperature * 65536.0F) / 65536.0F
+
+			if (temp > 1F) {
+				temp = 1F;
+			}
+
+			temps[i] = temp;
+		}
+
+		return temps;
+	}
+
+	public World getWorld() {
+		return worldServer.getWorld();
+	}
+
+	public CraftWorld getCraftWorld() {
+		return (CraftWorld) getWorld();
+	}
+
+	public net.minecraft.server.Chunk getHandle() {
+		net.minecraft.server.Chunk c = weakChunk.get();
+
+		if (c == null) {
+			c = worldServer.getChunkAt(x, z);
+
+			if (!(c instanceof EmptyChunk)) {
+				weakChunk = new WeakReference<net.minecraft.server.Chunk>(c);
+			}
+		}
+
+		return c;
+	}
+
+	void breakLink() {
+		weakChunk.clear();
+	}
+
+	public int getX() {
+		return x;
+	}
+
+	public int getZ() {
+		return z;
+	}
+
+	@Override
+	public String toString() {
+		return "CraftChunk{" + "x=" + getX() + "z=" + getZ() + '}';
+	}
+
+	public Block getBlock(int x, int y, int z) {
+		return new CraftBlock(this, (getX() << 4) | (x & 0xF), y, (getZ() << 4) | (z & 0xF));
+	}
+
+	public Entity[] getEntities() {
+		int count = 0, index = 0;
+		net.minecraft.server.Chunk chunk = getHandle();
+
+		for (int i = 0; i < 16; i++) {
+			count += chunk.entitySlices[i].size();
+		}
+
+		Entity[] entities = new Entity[count];
+
+		for (int i = 0; i < 16; i++) {
+
+			for (Object obj : chunk.entitySlices[i].toArray()) {
+				if (!(obj instanceof net.minecraft.server.Entity)) {
+					continue;
+				}
+
+				entities[index++] = ((net.minecraft.server.Entity) obj).getBukkitEntity();
+			}
+		}
+
+		return entities;
+	}
+
+	public BlockState[] getTileEntities() {
+		int index = 0;
+		net.minecraft.server.Chunk chunk = getHandle();
+
+		BlockState[] entities = new BlockState[chunk.tileEntities.size()];
+
+		for (Object obj : chunk.tileEntities.keySet().toArray()) {
+			if (!(obj instanceof BlockPosition)) {
+				continue;
+			}
+
+			BlockPosition position = (BlockPosition) obj;
+			entities[index++] = worldServer.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()).getState();
+		}
+
+		return entities;
+	}
+
+	public boolean isLoaded() {
+		return getWorld().isChunkLoaded(this);
+	}
+
+	public boolean load() {
+		return getWorld().loadChunk(getX(), getZ(), true);
+	}
+
+	public boolean load(boolean generate) {
+		return getWorld().loadChunk(getX(), getZ(), generate);
+	}
+
+	public boolean unload() {
+		return getWorld().unloadChunk(getX(), getZ());
+	}
+
+	public boolean unload(boolean save) {
+		return getWorld().unloadChunk(getX(), getZ(), save);
+	}
+
+	public boolean unload(boolean save, boolean safe) {
+		return getWorld().unloadChunk(getX(), getZ(), save, safe);
+	}
+
+	public ChunkSnapshot getChunkSnapshot() {
+		return getChunkSnapshot(true, false, false);
+	}
+
+	public ChunkSnapshot getChunkSnapshot(boolean includeMaxBlockY, boolean includeBiome, boolean includeBiomeTempRain) {
+		net.minecraft.server.Chunk chunk = getHandle();
+
+		ChunkSection[] cs = chunk.getSections();
+		short[][] sectionBlockIDs = new short[cs.length][];
+		byte[][] sectionBlockData = new byte[cs.length][];
+		byte[][] sectionSkyLights = new byte[cs.length][];
+		byte[][] sectionEmitLights = new byte[cs.length][];
+		boolean[] sectionEmpty = new boolean[cs.length];
+
+		for (int i = 0; i < cs.length; i++) {
+			if (cs[i] == null) { // Section is empty?
+				sectionBlockIDs[i] = emptyBlockIDs;
+				sectionBlockData[i] = emptyData;
+				sectionSkyLights[i] = emptySkyLight;
+				sectionEmitLights[i] = emptyData;
+				sectionEmpty[i] = true;
+			} else { // Not empty
+				short[] blockids = new short[4096];
+				char[] baseids = cs[i].getIdArray();
+				byte[] dataValues = sectionBlockData[i] = new byte[2048];
+
+				// Copy base IDs
+				for (int j = 0; j < 4096; j++) {
+					if (baseids[j] == 0) continue;
+					IBlockData blockData = (IBlockData) net.minecraft.server.Block.d.a(baseids[j]);
+					if (blockData == null) continue;
+					blockids[j] = (short) net.minecraft.server.Block.getId(blockData.getBlock());
+					int data = blockData.getBlock().toLegacyData(blockData);
+					int jj = j >> 1;
+					if ((j & 1) == 0) {
+						dataValues[jj] = (byte) ((dataValues[jj] & 0xF0) | (data & 0xF));
+					} else {
+						dataValues[jj] = (byte) ((dataValues[jj] & 0xF) | ((data & 0xF) << 4));
+					}
+				}
+
+				sectionBlockIDs[i] = blockids;
+
+				if (cs[i].getSkyLightArray() == null) {
+					sectionSkyLights[i] = emptyData;
+				} else {
+					sectionSkyLights[i] = new byte[2048];
+					System.arraycopy(cs[i].getSkyLightArray().a(), 0, sectionSkyLights[i], 0, 2048);
+				}
+				sectionEmitLights[i] = new byte[2048];
+				System.arraycopy(cs[i].getEmittedLightArray().a(), 0, sectionEmitLights[i], 0, 2048);
+			}
+		}
+
+		int[] hmap = null;
+
+		if (includeMaxBlockY) {
+			hmap = new int[256]; // Get copy of height map
+			System.arraycopy(chunk.heightMap, 0, hmap, 0, 256);
+		}
+
+		BiomeBase[] biome = null;
+		double[] biomeTemp = null;
+		double[] biomeRain = null;
+
+		if (includeBiome || includeBiomeTempRain) {
+			WorldChunkManager wcm = chunk.world.getWorldChunkManager();
+
+			if (includeBiome) {
+				biome = new BiomeBase[256];
+				for (int i = 0; i < 256; i++) {
+					biome[i] = chunk.getBiome(new BlockPosition(i & 0xF, 0, i >> 4), wcm);
+				}
+			}
+
+			if (includeBiomeTempRain) {
+				biomeTemp = new double[256];
+				biomeRain = new double[256];
+				float[] dat = getTemperatures(wcm, getX() << 4, getZ() << 4);
+
+				for (int i = 0; i < 256; i++) {
+					biomeTemp[i] = dat[i];
+				}
+
+				dat = wcm.getWetness(null, getX() << 4, getZ() << 4, 16, 16);
+
+				for (int i = 0; i < 256; i++) {
+					biomeRain[i] = dat[i];
+				}
+			}
+		}
+
+		World world = getWorld();
+		return new CraftChunkSnapshot(getX(), getZ(), world.getName(), world.getFullTime(), sectionBlockIDs, sectionBlockData, sectionSkyLights, sectionEmitLights, sectionEmpty, hmap, biome, biomeTemp, biomeRain);
+	}
+
+	// SpigotX start
+	@Override
+	public FakeMultiBlockChange createFakeBlockUpdate(final Location[] locations, final int[] ids, final int[] datas) {
+		PacketPlayOutMultiBlockChange packetPlayOutMultiBlockChange = new PacketPlayOutMultiBlockChange(locations.length, new short[locations.length], this.getHandle());
+		int index = 0;
+		for (PacketPlayOutMultiBlockChange.MultiBlockChangeInfo blockChangeInfo : packetPlayOutMultiBlockChange.getB()) {
+			blockChangeInfo.setC(net.minecraft.server.Block.getByCombinedId(ids[index]));
+			blockChangeInfo.setC(blockChangeInfo.c().getBlock().fromLegacyData(datas[index]));
+
+			Location location = locations[index];
+			blockChangeInfo.setB((short) ((location.getBlockX() & 15) << 12 | (location.getBlockZ() & 15) << 8 | location.getBlockY()));
+
+			index++;
+		}
+
+		return new CraftFakeMultiBlockChange(packetPlayOutMultiBlockChange);
+	}
+	// SpigotX end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 69485fa6..f593935b 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1,5 +1,8 @@
 package org.bukkit.craftbukkit;
 
+import org.potionspigot.PotionSpigot;
+import org.potionspigot.PotionSpigotConfig;
+
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.FileInputStream;
@@ -73,9 +76,9 @@ import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Player;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerChatTabCompleteEvent;
+import org.bukkit.event.server.ServerCommandEvent;
 import org.bukkit.event.world.WorldInitEvent;
 import org.bukkit.event.world.WorldLoadEvent;
-import org.bukkit.event.world.WorldSaveEvent;
 import org.bukkit.event.world.WorldUnloadEvent;
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.help.HelpMap;
@@ -127,7 +130,7 @@ import net.md_5.bungee.api.chat.BaseComponent;
 
 public final class CraftServer implements Server {
     private static final Player[] EMPTY_PLAYER_ARRAY = new Player[0];
-    private final String serverName = "CraftBukkit";
+    private final String serverName = "Spigot";
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -139,11 +142,11 @@ public final class CraftServer implements Server {
     private final PluginManager pluginManager = new SimplePluginManager(this, commandMap);
     protected final MinecraftServer console;
     protected final DedicatedPlayerList playerList;
-    private final Map<String, World> worlds = new LinkedHashMap<String, World>();
+    private final Map<String, World> worlds = new LinkedHashMap<>();
     private YamlConfiguration configuration;
     private YamlConfiguration commandsConfiguration;
     private final Yaml yaml = new Yaml(new SafeConstructor());
-    private final Map<UUID, OfflinePlayer> offlinePlayers = new MapMaker().softValues().makeMap();
+    private final Map<UUID, OfflinePlayer> offlinePlayers = new MapMaker().makeMap();
     private final EntityMetadataStore entityMetadata = new EntityMetadataStore();
     private final PlayerMetadataStore playerMetadata = new PlayerMetadataStore();
     private final WorldMetadataStore worldMetadata = new WorldMetadataStore();
@@ -244,7 +247,7 @@ public final class CraftServer implements Server {
         animalSpawn = configuration.getInt("spawn-limits.animals");
         waterAnimalSpawn = configuration.getInt("spawn-limits.water-animals");
         ambientSpawn = configuration.getInt("spawn-limits.ambient");
-        console.autosavePeriod = configuration.getInt("ticks-per.autosave");
+        console.autoSavePeriod = configuration.getInt("ticks-per.autosave");
         warningState = WarningState.value(configuration.getString("settings.deprecated-verbose"));
         chunkGCPeriod = configuration.getInt("chunk-gc.period-in-ticks");
         chunkGCLoadThresh = configuration.getInt("chunk-gc.load-threshold");
@@ -256,6 +259,10 @@ public final class CraftServer implements Server {
         // Spigot End
     }
 
+    public void setMaxPlayers(int players) {
+        this.playerList.setMaxPlayers(players);
+    }
+
     public boolean getCommandBlockOverride(String command) {
         return overrideAllCommandBlockCommands || commandsConfiguration.getStringList("command-block-overrides").contains(command);
     }
@@ -493,7 +500,7 @@ public final class CraftServer implements Server {
 
     @Override
     public int getViewDistance() {
-        return this.getConfigInt("view-distance", 10);
+        return this.getConfigInt("view-distance", 8);
     }
 
     @Override
@@ -640,28 +647,35 @@ public final class CraftServer implements Server {
         Validate.notNull(sender, "Sender cannot be null");
         Validate.notNull(commandLine, "CommandLine cannot be null");
 
-        // PaperSpigot Start
+        ServerCommandEvent event = new ServerCommandEvent(sender, commandLine);
+
+        this.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            return true;
+        }
+
         if (!Bukkit.isPrimaryThread()) {
             final CommandSender fSender = sender;
             final String fCommandLine = commandLine;
-            Bukkit.getLogger().log(Level.SEVERE, "Command Dispatched Async: " + commandLine);
-            Bukkit.getLogger().log(Level.SEVERE, "Please notify author of plugin causing this execution to fix this bug! see: http://bit.ly/1oSiM6C", new Throwable());
+
             org.bukkit.craftbukkit.util.Waitable<Boolean> wait = new org.bukkit.craftbukkit.util.Waitable<Boolean>() {
                 @Override
                 protected Boolean evaluate() {
                     return dispatchCommand(fSender, fCommandLine);
                 }
             };
+
             net.minecraft.server.MinecraftServer.getServer().processQueue.add(wait);
+
             try {
                 return wait.get();
             } catch (InterruptedException e) {
-                Thread.currentThread().interrupt(); // This is proper habit for java. If we aren't handling it, pass it on!
+                Thread.currentThread().interrupt();
             } catch (Exception e) {
                 throw new RuntimeException("Exception processing dispatch command", e.getCause());
             }
         }
-        // PaperSpigot End
 
         if (commandMap.dispatch(sender, commandLine)) {
             return true;
@@ -696,7 +710,7 @@ public final class CraftServer implements Server {
         ambientSpawn = configuration.getInt("spawn-limits.ambient");
         warningState = WarningState.value(configuration.getString("settings.deprecated-verbose"));
         printSaveWarning = false;
-        console.autosavePeriod = configuration.getInt("ticks-per.autosave");
+        console.autoSavePeriod = configuration.getInt("ticks-per.autosave");
         chunkGCPeriod = configuration.getInt("chunk-gc.period-in-ticks");
         chunkGCLoadThresh = configuration.getInt("chunk-gc.load-threshold");
         loadIcon();
@@ -713,7 +727,12 @@ public final class CraftServer implements Server {
         }
 
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
-        org.github.paperspigot.PaperSpigotConfig.init((File) console.options.valueOf("paper-settings")); // PaperSpigot
+        org.github.paperspigot.PaperSpigotConfig.init((File) console.options.valueOf("spigot-settings")); // PaperSpigot
+
+        // SpigotX
+        PotionSpigot.INSTANCE.setConfig(new PotionSpigotConfig());
+        PotionSpigot.INSTANCE.registerCommands();
+
         for (WorldServer world : console.worlds) {
             world.worldData.setDifficulty(difficulty);
             world.setSpawnFlags(monsters, animals);
@@ -813,7 +832,6 @@ public final class CraftServer implements Server {
         }
 
         if (perms == null) {
-            getLogger().log(Level.INFO, "Server permissions file " + file + " is empty, ignoring it");
             return;
         }
 
@@ -1675,7 +1693,7 @@ public final class CraftServer implements Server {
         PlayerChatTabCompleteEvent event = new PlayerChatTabCompleteEvent(player, message, completions);
         String token = event.getLastToken();
         for (Player p : getOnlinePlayers()) {
-            if (player.canSee(p) && StringUtil.startsWithIgnoreCase(p.getName(), token)) {
+            if (StringUtil.startsWithIgnoreCase(p.getName(), token)) {
                 completions.add(p.getName());
             }
         }
@@ -1704,7 +1722,7 @@ public final class CraftServer implements Server {
     }
 
     public void checkSaveState() {
-        if (this.playerCommandState || this.printSaveWarning || this.console.autosavePeriod <= 0) {
+        if (this.playerCommandState || this.printSaveWarning || this.console.autoSavePeriod <= 0) {
             return;
         }
         this.printSaveWarning = true;
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 76400709..09f52135 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -39,6 +39,7 @@ import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.entity.*;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.Item;
 import org.bukkit.entity.minecart.ExplosiveMinecart;
 import org.bukkit.entity.minecart.HopperMinecart;
 import org.bukkit.entity.minecart.PoweredMinecart;
@@ -329,11 +330,16 @@ public class CraftWorld implements World {
         return world;
     }
 
-    public org.bukkit.entity.Item dropItem(Location loc, ItemStack item) {
+    public Item dropItem(Location loc, ItemStack item) {
+        return this.dropItem(loc, item, null);
+    }
+
+    public Item dropItem(Location loc, ItemStack item, net.minecraft.server.Entity owner) {
         Validate.notNull(item, "Cannot drop a Null item.");
         Validate.isTrue(item.getTypeId() != 0, "Cannot drop AIR.");
         EntityItem entity = new EntityItem(world, loc.getX(), loc.getY(), loc.getZ(), CraftItemStack.asNMSCopy(item));
         entity.pickupDelay = 10;
+        entity.owner = owner;
         world.addEntity(entity);
         // TODO this is inconsistent with how Entity.getBukkitEntity() works.
         // However, this entity is not at the moment backed by a server entity class so it may be left.
@@ -365,7 +371,16 @@ public class CraftWorld implements World {
         }
     }
 
-    public org.bukkit.entity.Item dropItemNaturally(Location loc, ItemStack item) {
+    @Override
+    public Item dropItemNaturally(Location location, ItemStack item, Player player) {
+        return dropItemNaturally(location, item, ((CraftPlayer) player).getHandle());
+    }
+
+    public Item dropItemNaturally(Location loc, ItemStack item) {
+        return dropItemNaturally(loc, item, (net.minecraft.server.Entity) null);
+    }
+
+    public Item dropItemNaturally(Location loc, ItemStack item, net.minecraft.server.Entity owner) {
         double xs = world.random.nextFloat() * 0.7F - 0.35D;
         double ys = world.random.nextFloat() * 0.7F - 0.35D;
         double zs = world.random.nextFloat() * 0.7F - 0.35D;
@@ -373,7 +388,7 @@ public class CraftWorld implements World {
         // Makes sure the new item is created within the block the location points to.
         // This prevents item spill in 1-block wide farms.
         randomLocationWithinBlock(loc, xs, ys, zs);
-        return dropItem(loc, item);
+        return dropItem(loc, item, owner);
     }
 
     public Arrow spawnArrow(Location loc, Vector velocity, float speed, float spread) {
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index c9362191..0a200523 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -13,6 +13,7 @@ import net.minecraft.server.MinecraftServer;
 import org.fusesource.jansi.AnsiConsole;
 
 public class Main {
+
     public static boolean useJline = true;
     public static boolean useConsole = true;
 
@@ -124,10 +125,10 @@ public class Main {
                 // Spigot End
 
                 // PaperSpigot Start
-                acceptsAll(asList("paper", "paper-settings"), "File for paperspigot settings")
+                acceptsAll(asList("spigot", "spigot-settings"), "File for paperspigot settings")
                         .withRequiredArg()
                         .ofType(File.class)
-                        .defaultsTo(new File("paper.yml"))
+                        .defaultsTo(new File("spigot.yml"))
                         .describedAs("Yml file");
                 // PaperSpigot End
             }
@@ -150,8 +151,8 @@ public class Main {
         } else if (options.has("v")) {
             System.out.println(CraftServer.class.getPackage().getImplementationVersion());
         } else {
-            // Do you love Java using + and ! as string based identifiers? I sure do!
             String path = new File(".").getAbsolutePath();
+
             if (path.contains("!") || path.contains("+")) {
                 System.err.println("Cannot run server in a directory with ! or + in the pathname. Please rename the affected folders and try again.");
                 return;
@@ -176,28 +177,26 @@ public class Main {
                     System.setProperty(jline.TerminalFactory.JLINE_TERMINAL, jline.UnsupportedTerminal.class.getName());
                 }
 
-
                 if (options.has("noconsole")) {
                     useConsole = false;
                 }
 
-                // Spigot Start
                 int maxPermGen = 0; // In kb
-                for ( String s : java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments() )
-                {
-                    if ( s.startsWith( "-XX:MaxPermSize" ) )
-                    {
+
+                for (String s : java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments()) {
+                    if (s.startsWith("-XX:MaxPermSize")) {
                         maxPermGen = Integer.parseInt( s.replaceAll( "[^\\d]", "" ) );
-                        maxPermGen <<= 10 * ("kmg".indexOf( Character.toLowerCase( s.charAt( s.length() - 1 ) ) ) );
+                        maxPermGen <<= 10 * ("kmg".indexOf(Character.toLowerCase(s.charAt(s.length() - 1))));
                     }
                 }
-                if ( Float.parseFloat( System.getProperty( "java.class.version" ) ) < 52 && maxPermGen < ( 128 << 10 ) ) // 128mb
-                {
+
+                if (Float.parseFloat(System.getProperty( "java.class.version")) < 52 && maxPermGen < (128 << 10)) { // 128mb
                     System.out.println( "Warning, your max perm gen size is not set or less than 128mb. It is recommended you restart Java with the following argument: -XX:MaxPermSize=128M" );
                     System.out.println( "Please see http://www.spigotmc.org/wiki/changing-permgen-size/ for more details and more in-depth instructions." );
                 }
-                // Spigot End
+
                 System.out.println("Loading libraries, please wait...");
+
                 MinecraftServer.main(options);
             } catch (Throwable t) {
                 t.printStackTrace();
@@ -208,4 +207,5 @@ public class Main {
     private static List<String> asList(String... params) {
         return Arrays.asList(params);
     }
+
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 1178ad7f..538a676f 100644
--- a/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -14,6 +14,8 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.Entity;
 import net.minecraft.server.EntitySlice;
+import org.bukkit.event.world.ChunkLoadEvent;
+import org.bukkit.event.world.PreChunkLoadEvent;
 
 class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChunk, Chunk, Runnable, RuntimeException> {
     private final AtomicInteger threadNumber = new AtomicInteger(1);
@@ -43,6 +45,15 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
             return;
         }
 
+        Server server = queuedChunk.provider.world.getServer();
+        if (server != null) {
+            PreChunkLoadEvent event = new PreChunkLoadEvent();
+            server.getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return;
+            }
+        }
+
         queuedChunk.loader.loadEntities(chunk, queuedChunk.compound.getCompound("Level"), queuedChunk.world);
         chunk.setLastSaved(queuedChunk.provider.world.getTime());
         queuedChunk.provider.chunks.put(LongHash.toLong(queuedChunk.x, queuedChunk.z), chunk);
@@ -54,7 +65,6 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
             queuedChunk.provider.world.timings.syncChunkLoadStructuresTimer.stopTiming(); // Spigot
         }
 
-        Server server = queuedChunk.provider.world.getServer();
         if (server != null) {
             server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
index 01f616bb..88cfbbec 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftBlockCommandSender.java
@@ -1,53 +1,64 @@
 package org.bukkit.craftbukkit.command;
 
-import net.minecraft.server.ICommandListener;
 import net.minecraft.server.CommandBlockListenerAbstract;
 import net.minecraft.server.IChatBaseComponent;
-
+import net.minecraft.server.ICommandListener;
+import org.bukkit.ChatColor;
 import org.bukkit.block.Block;
 import org.bukkit.command.BlockCommandSender;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 
+import java.text.MessageFormat;
+
 /**
  * Represents input from a command block
  */
 public class CraftBlockCommandSender extends ServerCommandSender implements BlockCommandSender {
-    private final CommandBlockListenerAbstract commandBlock;
-
-    public CraftBlockCommandSender(CommandBlockListenerAbstract commandBlockListenerAbstract) {
-        super();
-        this.commandBlock = commandBlockListenerAbstract;
-    }
-
-    public Block getBlock() {
-        return commandBlock.getWorld().getWorld().getBlockAt(commandBlock.getChunkCoordinates().getX(), commandBlock.getChunkCoordinates().getY(), commandBlock.getChunkCoordinates().getZ());
-    }
-
-    public void sendMessage(String message) {
-        for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
-            commandBlock.sendMessage(component);
-        }
-    }
-
-    public void sendMessage(String[] messages) {
-        for (String message : messages) {
-            sendMessage(message);
-        }
-    }
-
-    public String getName() {
-        return commandBlock.getName();
-    }
-
-    public boolean isOp() {
-        return true;
-    }
-
-    public void setOp(boolean value) {
-        throw new UnsupportedOperationException("Cannot change operator status of a block");
-    }
-
-    public ICommandListener getTileEntity() {
-        return commandBlock;
-    }
+	private final CommandBlockListenerAbstract commandBlock;
+
+	public CraftBlockCommandSender(CommandBlockListenerAbstract commandBlockListenerAbstract) {
+		super();
+		this.commandBlock = commandBlockListenerAbstract;
+	}
+
+	public Block getBlock() {
+		return commandBlock.getWorld().getWorld().getBlockAt(commandBlock.getChunkCoordinates().getX(), commandBlock.getChunkCoordinates().getY(), commandBlock.getChunkCoordinates().getZ());
+	}
+
+	public void sendMessage(String message) {
+		for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
+			commandBlock.sendMessage(component);
+		}
+	}
+
+	public void sendMessage(String[] messages) {
+		for (String message : messages) {
+			sendMessage(message);
+		}
+	}
+
+	public void sendFormattedMessage(final String message, final Object... args) {
+		this.sendMessage(MessageFormat.format(message, args));
+	}
+
+	public String getName() {
+		return commandBlock.getName();
+	}
+
+	@Override
+	public String getDisplayName() {
+		return ChatColor.DARK_RED + "Command Block";
+	}
+
+	public boolean isOp() {
+		return true;
+	}
+
+	public void setOp(boolean value) {
+		throw new UnsupportedOperationException("Cannot change operator status of a block");
+	}
+
+	public ICommandListener getTileEntity() {
+		return commandBlock;
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
index 9abcf92d..1e3567b7 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftConsoleCommandSender.java
@@ -6,61 +6,83 @@ import org.bukkit.conversations.Conversation;
 import org.bukkit.conversations.ConversationAbandonedEvent;
 import org.bukkit.conversations.ManuallyAbandonedConversationCanceller;
 import org.bukkit.craftbukkit.conversations.ConversationTracker;
+import org.bukkit.permissions.Permission;
+
+import java.text.MessageFormat;
 
 /**
  * Represents CLI input from a console
  */
 public class CraftConsoleCommandSender extends ServerCommandSender implements ConsoleCommandSender {
 
-    protected final ConversationTracker conversationTracker = new ConversationTracker();
+	protected final ConversationTracker conversationTracker = new ConversationTracker();
+
+	protected CraftConsoleCommandSender() {
+		super();
+	}
+
+	public void sendMessage(String message) {
+		sendRawMessage(message);
+	}
+
+	public void sendRawMessage(String message) {
+		System.out.println(ChatColor.stripColor(message));
+	}
+
+	public void sendMessage(String[] messages) {
+		for (String message : messages) {
+			sendMessage(message);
+		}
+	}
 
-    protected CraftConsoleCommandSender() {
-        super();
-    }
+	public void sendFormattedMessage(final String message, final Object... args) {
+		this.sendMessage(MessageFormat.format(message, args));
+	}
 
-    public void sendMessage(String message) {
-        sendRawMessage(message);
-    }
+	public String getName() {
+		return "Console";
+	}
 
-    public void sendRawMessage(String message) {
-        System.out.println(ChatColor.stripColor(message));
-    }
+	@Override
+	public String getDisplayName() {
+		return ChatColor.DARK_RED + "Console";
+	}
 
-    public void sendMessage(String[] messages) {
-        for (String message : messages) {
-            sendMessage(message);
-        }
-    }
+	public boolean isOp() {
+		return true;
+	}
 
-    public String getName() {
-        return "CONSOLE";
-    }
+	public void setOp(boolean value) {
+		throw new UnsupportedOperationException("Cannot change operator status of server console");
+	}
 
-    public boolean isOp() {
-        return true;
-    }
+	@Override
+	public boolean hasPermission(String name) {
+		return true;
+	}
 
-    public void setOp(boolean value) {
-        throw new UnsupportedOperationException("Cannot change operator status of server console");
-    }
+	@Override
+	public boolean hasPermission(Permission permission) {
+		return true;
+	}
 
-    public boolean beginConversation(Conversation conversation) {
-        return conversationTracker.beginConversation(conversation);
-    }
+	public boolean beginConversation(Conversation conversation) {
+		return conversationTracker.beginConversation(conversation);
+	}
 
-    public void abandonConversation(Conversation conversation) {
-        conversationTracker.abandonConversation(conversation, new ConversationAbandonedEvent(conversation, new ManuallyAbandonedConversationCanceller()));
-    }
+	public void abandonConversation(Conversation conversation) {
+		conversationTracker.abandonConversation(conversation, new ConversationAbandonedEvent(conversation, new ManuallyAbandonedConversationCanceller()));
+	}
 
-    public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details) {
-        conversationTracker.abandonConversation(conversation, details);
-    }
+	public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details) {
+		conversationTracker.abandonConversation(conversation, details);
+	}
 
-    public void acceptConversationInput(String input) {
-        conversationTracker.acceptConversationInput(input);
-    }
+	public void acceptConversationInput(String input) {
+		conversationTracker.acceptConversationInput(input);
+	}
 
-    public boolean isConversing() {
-        return conversationTracker.isConversing();
-    }
+	public boolean isConversing() {
+		return conversationTracker.isConversing();
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
index 7c5523b0..13a91c8c 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/CraftRemoteConsoleCommandSender.java
@@ -2,37 +2,49 @@ package org.bukkit.craftbukkit.command;
 
 import net.minecraft.server.ChatComponentText;
 import net.minecraft.server.RemoteControlCommandListener;
+import org.bukkit.ChatColor;
 import org.bukkit.command.RemoteConsoleCommandSender;
 
+import java.text.MessageFormat;
+
 public class CraftRemoteConsoleCommandSender extends ServerCommandSender implements RemoteConsoleCommandSender {
-    public CraftRemoteConsoleCommandSender() {
-        super();
-    }
-
-    @Override
-    public void sendMessage(String message) {
-        RemoteControlCommandListener.getInstance().sendMessage(new ChatComponentText(message + "\n")); // Send a newline after each message, to preserve formatting.
-    }
-
-    @Override
-    public void sendMessage(String[] messages) {
-        for (String message : messages) {
-            sendMessage(message);
-        }
-    }
-
-    @Override
-    public String getName() {
-        return "Rcon";
-    }
-
-    @Override
-    public boolean isOp() {
-        return true;
-    }
-
-    @Override
-    public void setOp(boolean value) {
-        throw new UnsupportedOperationException("Cannot change operator status of remote controller.");
-    }
+	public CraftRemoteConsoleCommandSender() {
+		super();
+	}
+
+	@Override
+	public void sendMessage(String message) {
+		RemoteControlCommandListener.getInstance().sendMessage(new ChatComponentText(message + "\n")); // Send a newline after each message, to preserve formatting.
+	}
+
+	@Override
+	public void sendMessage(String[] messages) {
+		for (String message : messages) {
+			sendMessage(message);
+		}
+	}
+
+	public void sendFormattedMessage(final String message, final Object... args) {
+		this.sendMessage(MessageFormat.format(message, args));
+	}
+
+	@Override
+	public String getName() {
+		return "RCON";
+	}
+
+	@Override
+	public String getDisplayName() {
+		return ChatColor.DARK_RED + "RCON";
+	}
+
+	@Override
+	public boolean isOp() {
+		return true;
+	}
+
+	@Override
+	public void setOp(boolean value) {
+		throw new UnsupportedOperationException("Cannot change operator status of remote controller.");
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
index 9acd92c3..416f41fb 100644
--- a/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
+++ b/src/main/java/org/bukkit/craftbukkit/command/ProxiedNativeCommandSender.java
@@ -1,9 +1,6 @@
-
 package org.bukkit.craftbukkit.command;
 
-import java.util.Set;
 import net.minecraft.server.ICommandListener;
-
 import org.bukkit.Server;
 import org.bukkit.command.CommandSender;
 import org.bukkit.command.ProxiedCommandSender;
@@ -12,115 +9,127 @@ import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
 
+import java.text.MessageFormat;
+import java.util.Set;
+
 public class ProxiedNativeCommandSender implements ProxiedCommandSender {
 
-    private final ICommandListener orig;
-    private final CommandSender caller;
-    private final CommandSender callee;
-
-    public ProxiedNativeCommandSender(ICommandListener orig, CommandSender caller, CommandSender callee) {
-        this.orig = orig;
-        this.caller = caller;
-        this.callee = callee;
-    }
-
-    public ICommandListener getHandle() {
-        return orig;
-    }
-
-    @Override
-    public CommandSender getCaller() {
-        return caller;
-    }
-
-    @Override
-    public CommandSender getCallee() {
-        return callee;
-    }
-
-    @Override
-    public void sendMessage(String message) {
-        getCaller().sendMessage(message);
-    }
-
-    @Override
-    public void sendMessage(String[] messages) {
-        getCaller().sendMessage(messages);
-    }
-
-    @Override
-    public Server getServer() {
-        return getCallee().getServer();
-    }
-
-    @Override
-    public String getName() {
-        return getCallee().getName();
-    }
-
-    @Override
-    public boolean isPermissionSet(String name) {
-        return getCaller().isPermissionSet(name);
-    }
-
-    @Override
-    public boolean isPermissionSet(Permission perm) {
-        return getCaller().isPermissionSet(perm);
-    }
-
-    @Override
-    public boolean hasPermission(String name) {
-        return getCaller().hasPermission(name);
-    }
-
-    @Override
-    public boolean hasPermission(Permission perm) {
-        return getCaller().hasPermission(perm);
-    }
-
-    @Override
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value) {
-        return getCaller().addAttachment(plugin, name, value);
-    }
-
-    @Override
-    public PermissionAttachment addAttachment(Plugin plugin) {
-        return getCaller().addAttachment(plugin);
-    }
-
-    @Override
-    public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value, int ticks) {
-        return getCaller().addAttachment(plugin, name, value, ticks);
-    }
-
-    @Override
-    public PermissionAttachment addAttachment(Plugin plugin, int ticks) {
-        return getCaller().addAttachment(plugin, ticks);
-    }
-
-    @Override
-    public void removeAttachment(PermissionAttachment attachment) {
-        getCaller().removeAttachment(attachment);
-    }
-
-    @Override
-    public void recalculatePermissions() {
-        getCaller().recalculatePermissions();
-    }
-
-    @Override
-    public Set<PermissionAttachmentInfo> getEffectivePermissions() {
-        return getCaller().getEffectivePermissions();
-    }
-
-    @Override
-    public boolean isOp() {
-        return getCaller().isOp();
-    }
-
-    @Override
-    public void setOp(boolean value) {
-        getCaller().setOp(value);
-    }
+	private final ICommandListener orig;
+	private final CommandSender caller;
+	private final CommandSender callee;
+
+	public ProxiedNativeCommandSender(ICommandListener orig, CommandSender caller, CommandSender callee) {
+		this.orig = orig;
+		this.caller = caller;
+		this.callee = callee;
+	}
+
+	public ICommandListener getHandle() {
+		return orig;
+	}
+
+	@Override
+	public CommandSender getCaller() {
+		return caller;
+	}
+
+	@Override
+	public CommandSender getCallee() {
+		return callee;
+	}
+
+	@Override
+	public void sendMessage(String message) {
+		getCaller().sendMessage(message);
+	}
+
+	@Override
+	public void sendMessage(String[] messages) {
+		getCaller().sendMessage(messages);
+	}
+
+	public void sendFormattedMessage(final String message, final Object... args) {
+		this.sendMessage(MessageFormat.format(message, args));
+	}
+
+	@Override
+	public Server getServer() {
+		return getCallee().getServer();
+	}
+
+	@Override
+	public String getName() {
+		return getCallee().getName();
+	}
+
+	@Override
+	public String getDisplayName() {
+		return getCallee().getName();
+	}
+
+	@Override
+	public boolean isPermissionSet(String name) {
+		return getCaller().isPermissionSet(name);
+	}
+
+	@Override
+	public boolean isPermissionSet(Permission perm) {
+		return getCaller().isPermissionSet(perm);
+	}
+
+	@Override
+	public boolean hasPermission(String name) {
+		return getCaller().hasPermission(name);
+	}
+
+	@Override
+	public boolean hasPermission(Permission perm) {
+		return getCaller().hasPermission(perm);
+	}
+
+	@Override
+	public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value) {
+		return getCaller().addAttachment(plugin, name, value);
+	}
+
+	@Override
+	public PermissionAttachment addAttachment(Plugin plugin) {
+		return getCaller().addAttachment(plugin);
+	}
+
+	@Override
+	public PermissionAttachment addAttachment(Plugin plugin, String name, boolean value, int ticks) {
+		return getCaller().addAttachment(plugin, name, value, ticks);
+	}
+
+	@Override
+	public PermissionAttachment addAttachment(Plugin plugin, int ticks) {
+		return getCaller().addAttachment(plugin, ticks);
+	}
+
+	@Override
+	public void removeAttachment(PermissionAttachment attachment) {
+		getCaller().removeAttachment(attachment);
+	}
+
+	@Override
+	public void recalculatePermissions() {
+		getCaller().recalculatePermissions();
+	}
+
+	@Override
+	public Set<PermissionAttachmentInfo> getEffectivePermissions() {
+		return getCaller().getEffectivePermissions();
+	}
+
+	@Override
+	public boolean isOp() {
+		return getCaller().isOp();
+	}
+
+	@Override
+	public void setOp(boolean value) {
+		getCaller().setOp(value);
+	}
 
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 4f917990..d1e9a631 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -1,8 +1,6 @@
 package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
@@ -14,7 +12,6 @@ import org.bukkit.Location;
 import org.bukkit.Server;
 import org.bukkit.World;
 import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 import org.bukkit.metadata.MetadataValue;
@@ -29,7 +26,6 @@ import org.github.paperspigot.PaperSpigotConfig;
 
 public abstract class CraftEntity implements org.bukkit.entity.Entity {
     private static final PermissibleBase perm = new PermissibleBase(new ServerOperator() {
-
         @Override
         public boolean isOp() {
             return false;
@@ -50,6 +46,8 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         this.entity = entity;
     }
 
+    public void extinguish() {}
+
     public static CraftEntity getEntity(CraftServer server, Entity entity) {
         /**
          * Order is *EXTREMELY* important -- keep it right! =D
@@ -288,6 +286,10 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         return entity.maxFireTicks;
     }
 
+    public void setMaxFireTicks(int ticks) {
+        entity.maxFireTicks = ticks;
+    }
+
     public void setFireTicks(int ticks) {
         entity.fireTicks = ticks;
     }
@@ -487,11 +489,21 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
 
     }
 
+    @Override
+    public void sendFormattedMessage(String message, Object... parameters) {
+
+    }
+
     @Override
     public String getName() {
         return getHandle().getName();
     }
 
+    @Override
+    public String getDisplayName() {
+        return getHandle().getName();
+    }
+
     @Override
     public boolean isPermissionSet(String name) {
         return perm.isPermissionSet(name);
@@ -567,6 +579,21 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
     };
 
+    @Override
+    public double getX() {
+        return entity.getX();
+    }
+
+    @Override
+    public double getY() {
+        return entity.getY();
+    }
+
+    @Override
+    public double getZ() {
+        return entity.getZ();
+    }
+
     public Spigot spigot()
     {
         return spigot;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftFireball.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftFireball.java
index 6f0b9423..dba72108 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftFireball.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftFireball.java
@@ -1,8 +1,9 @@
 package org.bukkit.craftbukkit.entity;
 
+import net.jafama.FastMath;
 import net.minecraft.server.EntityFireball;
-import net.minecraft.server.MathHelper;
 
+import net.minecraft.server.MathHelper;
 import org.apache.commons.lang.Validate;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.entity.EntityType;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftFish.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftFish.java
index ecfc316b..e627ab71 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftFish.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftFish.java
@@ -3,8 +3,8 @@ package org.bukkit.craftbukkit.entity;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.EntityFishingHook;
 import net.minecraft.server.EntityHuman;
-import net.minecraft.server.MathHelper;
 
+import net.minecraft.server.MathHelper;
 import org.apache.commons.lang.Validate;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.entity.EntityType;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
index 8a08babc..43cf173e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHumanEntity.java
@@ -9,6 +9,7 @@ import org.bukkit.Location;
 import org.bukkit.Material;
 import org.bukkit.entity.HumanEntity;
 import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.event.player.PlayerVelocityEvent;
 import org.bukkit.inventory.Inventory;
 import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.ItemStack;
@@ -27,6 +28,7 @@ import org.bukkit.permissions.Permission;
 import org.bukkit.permissions.PermissionAttachment;
 import org.bukkit.permissions.PermissionAttachmentInfo;
 import org.bukkit.plugin.Plugin;
+import org.bukkit.util.Vector;
 
 public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     private CraftInventoryPlayer inventory;
@@ -86,10 +88,6 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
         return getHandle().sleepTicks;
     }
 
-    public boolean isOp() {
-        return op;
-    }
-
     public boolean isPermissionSet(String name) {
         return perm.isPermissionSet(name);
     }
@@ -362,4 +360,5 @@ public class CraftHumanEntity extends CraftLivingEntity implements HumanEntity {
     public int getExpToLevel() {
         return getHandle().getExpToLevel();
     }
+
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
index a17a537d..e7adfdd5 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftItem.java
@@ -2,47 +2,56 @@ package org.bukkit.craftbukkit.entity;
 
 import net.minecraft.server.Entity;
 import net.minecraft.server.EntityItem;
-
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Item;
 import org.bukkit.inventory.ItemStack;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.CraftServer;
 
 public class CraftItem extends CraftEntity implements Item {
-    private final EntityItem item;
-
-    public CraftItem(CraftServer server, Entity entity, EntityItem item) {
-        super(server, entity);
-        this.item = item;
-    }
-
-    public CraftItem(CraftServer server, EntityItem entity) {
-        this(server, entity, entity);
-    }
-
-    public ItemStack getItemStack() {
-        return CraftItemStack.asCraftMirror(item.getItemStack());
-    }
-
-    public void setItemStack(ItemStack stack) {
-        item.setItemStack(CraftItemStack.asNMSCopy(stack));
-    }
-
-    public int getPickupDelay() {
-        return item.pickupDelay;
-    }
-
-    public void setPickupDelay(int delay) {
-        item.pickupDelay = Math.min(delay, Short.MAX_VALUE);
-    }
-
-    @Override
-    public String toString() {
-        return "CraftItem";
-    }
-
-    public EntityType getType() {
-        return EntityType.DROPPED_ITEM;
-    }
+	private final EntityItem item;
+
+	public CraftItem(CraftServer server, Entity entity, EntityItem item) {
+		super(server, entity);
+		this.item = item;
+	}
+
+	public CraftItem(CraftServer server, EntityItem entity) {
+		this(server, entity, entity);
+	}
+
+	public ItemStack getItemStack() {
+		return CraftItemStack.asCraftMirror(item.getItemStack());
+	}
+
+	public void setItemStack(ItemStack stack) {
+		item.setItemStack(CraftItemStack.asNMSCopy(stack));
+	}
+
+	public int getPickupDelay() {
+		return item.pickupDelay;
+	}
+
+	public void setPickupDelay(int delay) {
+		item.pickupDelay = Math.min(delay, Short.MAX_VALUE);
+	}
+
+	@Override
+	public String toString() {
+		return "CraftItem";
+	}
+
+	public EntityType getType() {
+		return EntityType.DROPPED_ITEM;
+	}
+
+	@Override
+	public int getAge() {
+		return this.item.age;
+	}
+
+	@Override
+	public void setAge(int age) {
+		this.item.age = age;
+	}
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
index 3e3a0480..6163c5eb 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftLivingEntity.java
@@ -7,11 +7,11 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
+import org.potionspigot.knockback.KnockbackProfile;
 import net.minecraft.server.DamageSource;
 import net.minecraft.server.EntityArmorStand;
 import net.minecraft.server.EntityArrow;
 import net.minecraft.server.EntityEgg;
-import net.minecraft.server.EntityEnderDragon;
 import net.minecraft.server.EntityEnderPearl;
 import net.minecraft.server.EntityFishingHook;
 import net.minecraft.server.EntityHuman;
@@ -64,6 +64,19 @@ import org.bukkit.util.NumberConversions;
 import org.bukkit.util.Vector;
 
 public class CraftLivingEntity extends CraftEntity implements LivingEntity {
+
+    // SpigotX start
+    @Override
+    public KnockbackProfile getKnockbackProfile() {
+        return getHandle().getKnockbackProfile();
+    }
+
+    @Override
+    public void setKnockbackProfile(KnockbackProfile profile) {
+        getHandle().setKnockbackProfile(profile);
+    }
+    // SpigotX end
+
     private CraftEntityEquipment equipment;
 
     public CraftLivingEntity(final CraftServer server, final EntityLiving entity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index d44fc62b..3d3816b5 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1,15 +1,15 @@
 package org.bukkit.craftbukkit.entity;
 
+import org.potionspigot.PotionSpigot;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
-
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.lang.Override;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.text.MessageFormat;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
@@ -21,31 +21,74 @@ import java.util.UUID;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.md_5.bungee.api.chat.BaseComponent;
-
-import net.minecraft.server.*;
+import net.minecraft.server.AttributeInstance;
+import net.minecraft.server.AttributeMapServer;
+import net.minecraft.server.AttributeModifiable;
+import net.minecraft.server.AttributeRanged;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Container;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityItem;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.EntityProjectile;
+import net.minecraft.server.EntityTracker;
+import net.minecraft.server.EntityTrackerEntry;
+import net.minecraft.server.IAttribute;
+import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.MapIcon;
+import net.minecraft.server.NBTTagCompound;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketPlayOutBlockChange;
+import net.minecraft.server.PacketPlayOutChat;
+import net.minecraft.server.PacketPlayOutCustomPayload;
+import net.minecraft.server.PacketPlayOutEntityVelocity;
+import net.minecraft.server.PacketPlayOutGameStateChange;
+import net.minecraft.server.PacketPlayOutMap;
+import net.minecraft.server.PacketPlayOutNamedSoundEffect;
+import net.minecraft.server.PacketPlayOutPlayerInfo;
+import net.minecraft.server.PacketPlayOutPlayerListHeaderFooter;
+import net.minecraft.server.PacketPlayOutSpawnPosition;
+import net.minecraft.server.PacketPlayOutTitle;
 import net.minecraft.server.PacketPlayOutTitle.EnumTitleAction;
-
-import org.apache.commons.lang.Validate;
+import net.minecraft.server.PacketPlayOutUpdateAttributes;
+import net.minecraft.server.PacketPlayOutUpdateHealth;
+import net.minecraft.server.PacketPlayOutUpdateSign;
+import net.minecraft.server.PacketPlayOutWorldEvent;
+import net.minecraft.server.PacketPlayOutWorldParticles;
+import net.minecraft.server.PlayerConnection;
+import net.minecraft.server.WorldServer;
+import net.minecraft.server.WorldSettings;
 import org.apache.commons.lang.NotImplementedException;
-import org.bukkit.*;
+import org.apache.commons.lang.Validate;
 import org.bukkit.Achievement;
 import org.bukkit.BanList;
-import org.bukkit.Statistic;
+import org.bukkit.Effect;
+import org.bukkit.GameMode;
+import org.bukkit.Instrument;
+import org.bukkit.Location;
 import org.bukkit.Material;
+import org.bukkit.Note;
+import org.bukkit.OfflinePlayer;
+import org.bukkit.Sound;
+import org.bukkit.Statistic;
 import org.bukkit.Statistic.Type;
+import org.bukkit.WeatherType;
 import org.bukkit.World;
 import org.bukkit.configuration.serialization.DelegateDeserialization;
 import org.bukkit.conversations.Conversation;
 import org.bukkit.conversations.ConversationAbandonedEvent;
 import org.bukkit.conversations.ManuallyAbandonedConversationCanceller;
-import org.bukkit.craftbukkit.block.CraftSign;
-import org.bukkit.craftbukkit.conversations.ConversationTracker;
 import org.bukkit.craftbukkit.CraftEffect;
 import org.bukkit.craftbukkit.CraftOfflinePlayer;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftSound;
 import org.bukkit.craftbukkit.CraftStatistic;
 import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftSign;
+import org.bukkit.craftbukkit.conversations.ConversationTracker;
 import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.map.RenderData;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboard;
@@ -57,6 +100,7 @@ import org.bukkit.event.player.PlayerGameModeChangeEvent;
 import org.bukkit.event.player.PlayerRegisterChannelEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.event.player.PlayerUnregisterChannelEvent;
+import org.bukkit.event.player.PlayerVelocityEvent;
 import org.bukkit.inventory.InventoryView.Property;
 import org.bukkit.map.MapCursor;
 import org.bukkit.map.MapView;
@@ -64,411 +108,472 @@ import org.bukkit.metadata.MetadataValue;
 import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.scoreboard.Scoreboard;
-// PaperSpigot start
+import org.bukkit.util.Vector;
 import org.github.paperspigot.Title;
+
+// PaperSpigot start
 // PaperSpigot end
 
 @DelegateDeserialization(CraftOfflinePlayer.class)
 public class CraftPlayer extends CraftHumanEntity implements Player {
-    private long firstPlayed = 0;
-    private long lastPlayed = 0;
-    private boolean hasPlayedBefore = false;
-    private final ConversationTracker conversationTracker = new ConversationTracker();
-    private final Set<String> channels = new HashSet<String>();
-    private final Set<UUID> hiddenPlayers = new HashSet<UUID>();
-    private int hash = 0;
-    private double health = 20;
-    private boolean scaledHealth = false;
-    private double healthScale = 20;
-
-    public CraftPlayer(CraftServer server, EntityPlayer entity) {
-        super(server, entity);
-
-        firstPlayed = System.currentTimeMillis();
-    }
-
-    public GameProfile getProfile() {
-        return getHandle().getProfile();
-    }
-
-    @Override
-    public boolean isOp() {
-        return server.getHandle().isOp(getProfile());
-    }
-
-    @Override
-    public void setOp(boolean value) {
-        if (value == isOp()) return;
-
-        if (value) {
-            server.getHandle().addOp(getProfile());
-        } else {
-            server.getHandle().removeOp(getProfile());
-        }
-
-        perm.recalculatePermissions();
-    }
-
-    public boolean isOnline() {
-        return server.getPlayer(getUniqueId()) != null;
-    }
-
-    public InetSocketAddress getAddress() {
-        if (getHandle().playerConnection == null) return null;
-
-        SocketAddress addr = getHandle().playerConnection.networkManager.getSocketAddress();
-        if (addr instanceof InetSocketAddress) {
-            return (InetSocketAddress) addr;
-        } else {
-            return null;
-        }
-    }
-
-    @Override
-    public double getEyeHeight() {
-        return getEyeHeight(false);
-    }
-
-    @Override
-    public double getEyeHeight(boolean ignoreSneaking) {
-        if (ignoreSneaking) {
-            return 1.62D;
-        } else {
-            if (isSneaking()) {
-                return 1.54D;
-            } else {
-                return 1.62D;
-            }
-        }
-    }
-
-    @Override
-    public void sendRawMessage(String message) {
-        if (getHandle().playerConnection == null) return;
-
-        for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
-            getHandle().playerConnection.sendPacket(new PacketPlayOutChat(component));
-        }
-    }
-
-    @Override
-    public void sendMessage(String message) {
-        if (!conversationTracker.isConversingModaly()) {
-            this.sendRawMessage(message);
-        }
-    }
-
-    @Override
-    public void sendMessage(String[] messages) {
-        for (String message : messages) {
-            sendMessage(message);
-        }
-    }
-
-    // Paper start
-    @Override
-    public void sendMessage(BaseComponent component) {
-        sendMessage(new BaseComponent[]{component});
-    }
-
-    @Override
-    public void sendMessage(BaseComponent... components) {
-        if (getHandle().playerConnection == null) return;
-
-        PacketPlayOutChat packet = new PacketPlayOutChat();
-        packet.components = components;
-        getHandle().playerConnection.sendPacket(packet);
-    }
-
-    @Override
-    public void setPlayerListHeaderFooter(BaseComponent[] header, BaseComponent[] footer) {
-        PacketPlayOutPlayerListHeaderFooter packet = new PacketPlayOutPlayerListHeaderFooter();
-        packet.header = header;
-        packet.footer = footer;
-        getHandle().playerConnection.sendPacket(packet);
-    }
-
-    @Override
-    public void setPlayerListHeaderFooter(BaseComponent header, BaseComponent footer) {
-        this.setPlayerListHeaderFooter(header == null ? null : new BaseComponent[]{header},
-                footer == null ? null : new BaseComponent[]{footer});
-    }
-
-
-    @Override
-    public void setTitleTimes(int fadeInTicks, int stayTicks, int fadeOutTicks) {
-        getHandle().playerConnection.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.TIMES, (BaseComponent[]) null, fadeInTicks, stayTicks, fadeOutTicks));
-    }
-
-    @Override
-    public void setSubtitle(BaseComponent[] subtitle) {
-        getHandle().playerConnection.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.SUBTITLE, subtitle, 0, 0, 0));
-    }
-
-    @Override
-    public void setSubtitle(BaseComponent subtitle) {
-        setSubtitle(new BaseComponent[]{subtitle});
-    }
-
-    @Override
-    public void showTitle(BaseComponent[] title) {
-        getHandle().playerConnection.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.TITLE, title, 0, 0, 0));
-    }
-
-    @Override
-    public void showTitle(BaseComponent title) {
-        showTitle(new BaseComponent[]{title});
-    }
-
-    @Override
-    public void showTitle(BaseComponent[] title, BaseComponent[] subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks) {
-        setTitleTimes(fadeInTicks, stayTicks, fadeOutTicks);
-        setSubtitle(subtitle);
-        showTitle(title);
-    }
-
-    @Override
-    public void showTitle(BaseComponent title, BaseComponent subtitle, int fadeInTicks, int stayTicks, int fadeOutTicks) {
-        setTitleTimes(fadeInTicks, stayTicks, fadeOutTicks);
-        setSubtitle(subtitle);
-        showTitle(title);
-    }
-
-    @Override
-    public void sendTitle(Title title) {
-        Preconditions.checkNotNull(title, "Title is null");
-        setTitleTimes(title.getFadeIn(), title.getStay(), title.getFadeOut());
-        setSubtitle(title.getSubtitle() == null ? new BaseComponent[0] : title.getSubtitle());
-        showTitle(title.getTitle());
-    }
-
-    @Override
-    public void updateTitle(Title title) {
-        Preconditions.checkNotNull(title, "Title is null");
-        setTitleTimes(title.getFadeIn(), title.getStay(), title.getFadeOut());
-        if (title.getSubtitle() != null) {
-            setSubtitle(title.getSubtitle());
-        }
-        showTitle(title.getTitle());
-    }
-
-    @Override
-    public void hideTitle() {
-        getHandle().playerConnection.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.CLEAR, (BaseComponent[]) null, 0, 0, 0));
-    }
-    // Paper end
-
-    @Override
-    public String getDisplayName() {
-        return getHandle().displayName;
-    }
-
-    @Override
-    public void setDisplayName(final String name) {
-        getHandle().displayName = name == null ? getName() : name;
-    }
-
-    @Override
-    public String getPlayerListName() {
-        return getHandle().listName == null ? getName() : CraftChatMessage.fromComponent(getHandle().listName);
-    }
-
-    @Override
-    public void setPlayerListName(String name) {
-        if (name == null) {
-            name = getName();
-        }
-        getHandle().listName = name.equals(getName()) ? null : CraftChatMessage.fromString(name)[0];
-        for (EntityPlayer player : (List<EntityPlayer>)server.getHandle().players) {
-            if (player.getBukkitEntity().canSee(this)) {
-                player.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME, getHandle()));
-            }
-        }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (!(obj instanceof OfflinePlayer)) {
-            return false;
-        }
-        OfflinePlayer other = (OfflinePlayer) obj;
-        if ((this.getUniqueId() == null) || (other.getUniqueId() == null)) {
-            return false;
-        }
-
-        boolean uuidEquals = this.getUniqueId().equals(other.getUniqueId());
-        boolean idEquals = true;
-
-        if (other instanceof CraftPlayer) {
-            idEquals = this.getEntityId() == ((CraftPlayer) other).getEntityId();
-        }
 
-        return uuidEquals && idEquals;
-    }
-
-    @Override
-    public void kickPlayer(String message) {
-        org.spigotmc.AsyncCatcher.catchOp( "player kick"); // Spigot
-        if (getHandle().playerConnection == null) return;
-
-        getHandle().playerConnection.disconnect(message == null ? "" : message);
-    }
-
-    @Override
-    public void setCompassTarget(Location loc) {
-        if (getHandle().playerConnection == null) return;
-
-        // Do not directly assign here, from the packethandler we'll assign it.
-        getHandle().playerConnection.sendPacket(new PacketPlayOutSpawnPosition(new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())));
-    }
-
-    @Override
-    public Location getCompassTarget() {
-        return getHandle().compassTarget;
-    }
-
-    @Override
-    public void chat(String msg) {
-        if (getHandle().playerConnection == null) return;
-
-        getHandle().playerConnection.chat(msg, false);
-    }
-
-    @Override
-    public boolean performCommand(String command) {
-        return server.dispatchCommand(this, command);
-    }
-
-    @Override
-    public void playNote(Location loc, byte instrument, byte note) {
-        if (getHandle().playerConnection == null) return;
-
-        String instrumentName = null;
-        switch (instrument) {
-        case 0:
-            instrumentName = "harp";
-            break;
-        case 1:
-            instrumentName = "bd";
-            break;
-        case 2:
-            instrumentName = "snare";
-            break;
-        case 3:
-            instrumentName = "hat";
-            break;
-        case 4:
-            instrumentName = "bassattack";
-            break;
-        }
-
-        float f = (float) Math.pow(2.0D, (note - 12.0D) / 12.0D);
-        getHandle().playerConnection.sendPacket(new PacketPlayOutNamedSoundEffect("note."+instrumentName, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), 3.0f, f));
-    }
-
-    @Override
-    public void playNote(Location loc, Instrument instrument, Note note) {
-        if (getHandle().playerConnection == null) return;
-
-        String instrumentName = null;
-        switch (instrument.ordinal()) {
-            case 0:
-                instrumentName = "harp";
-                break;
-            case 1:
-                instrumentName = "bd";
-                break;
-            case 2:
-                instrumentName = "snare";
-                break;
-            case 3:
-                instrumentName = "hat";
-                break;
-            case 4:
-                instrumentName = "bassattack";
-                break;
-        }
-        float f = (float) Math.pow(2.0D, (note.getId() - 12.0D) / 12.0D);
-        getHandle().playerConnection.sendPacket(new PacketPlayOutNamedSoundEffect("note."+instrumentName, loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), 3.0f, f));
-    }
-
-    @Override
-    public void playSound(Location loc, Sound sound, float volume, float pitch) {
-        if (sound == null) {
-            return;
-        }
-        playSound(loc, CraftSound.getSound(sound), volume, pitch);
-    }
-
-    @Override
-    public void playSound(Location loc, String sound, float volume, float pitch) {
-        if (loc == null || sound == null || getHandle().playerConnection == null) return;
-
-        double x = loc.getBlockX() + 0.5;
-        double y = loc.getBlockY() + 0.5;
-        double z = loc.getBlockZ() + 0.5;
-
-        PacketPlayOutNamedSoundEffect packet = new PacketPlayOutNamedSoundEffect(sound, x, y, z, volume, pitch);
-        getHandle().playerConnection.sendPacket(packet);
-    }
-
-    @Override
-    public void playEffect(Location loc, Effect effect, int data) {
-        if (getHandle().playerConnection == null) return;
-
-        spigot().playEffect(loc, effect, data, 0, 0, 0, 0, 1, 1, 64); // Spigot
-    }
-
-    @Override
-    public <T> void playEffect(Location loc, Effect effect, T data) {
-        if (data != null) {
-            Validate.isTrue(data.getClass().isAssignableFrom(effect.getData()), "Wrong kind of data for this effect!");
-        } else {
-            Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
-        }
-
-        int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
-        playEffect(loc, effect, datavalue);
-    }
-
-    @Override
-    public void sendBlockChange(Location loc, Material material, byte data) {
-        sendBlockChange(loc, material.getId(), data);
-    }
-
-    @Override
-    public void sendBlockChange(Location loc, int material, byte data) {
-        if (getHandle().playerConnection == null) return;
-
-        PacketPlayOutBlockChange packet = new PacketPlayOutBlockChange(((CraftWorld) loc.getWorld()).getHandle(), new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));
-
-        packet.block = CraftMagicNumbers.getBlock(material).fromLegacyData(data);
-        getHandle().playerConnection.sendPacket(packet);
-    }
-
-    @Override
-    public void sendSignChange(Location loc, String[] lines) {
-        if (getHandle().playerConnection == null) {
-            return;
-        }
-
-        if (lines == null) {
-            lines = new String[4];
-        }
-
-        Validate.notNull(loc, "Location can not be null");
-        if (lines.length < 4) {
-            throw new IllegalArgumentException("Must have at least 4 lines");
-        }
-
-        IChatBaseComponent[] components = CraftSign.sanitizeLines(lines);
-
-        getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateSign(getHandle().world, new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()), components));
-    }
-
-    @Override
-    public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data) {
-        if (getHandle().playerConnection == null) return false;
+	private long firstPlayed = 0;
+	private long lastPlayed = 0;
+	private boolean hasPlayedBefore = false;
+	private final ConversationTracker conversationTracker = new ConversationTracker();
+	private final Set<String> channels = new HashSet<>();
+	private final Set<UUID> hiddenPlayers = new HashSet<>();
+	private int hash = 0;
+	private double health = 20;
+	private boolean scaledHealth = false;
+	private double healthScale = 20;
+
+	public CraftPlayer(CraftServer server, EntityPlayer entity) {
+		super(server, entity);
+
+		firstPlayed = System.currentTimeMillis();
+	}
+
+	public GameProfile getProfile() {
+		return getHandle().getProfile();
+	}
+
+	@Override
+	public int getPing() {
+		return getHandle().ping;
+	}
+
+	@Override
+	public boolean isOp() {
+		return server.getHandle().isOp(getProfile());
+	}
+
+	@Override
+	public void setOp(boolean value) {
+		if (value == isOp()) {
+			return;
+		}
+
+		if (value) {
+			server.getHandle().addOp(getProfile());
+		} else {
+			server.getHandle().removeOp(getProfile());
+		}
+
+		perm.recalculatePermissions();
+	}
+
+	public boolean isOnline() {
+		return server.getPlayer(getUniqueId()) != null;
+	}
+
+	public InetSocketAddress getAddress() {
+		if (getHandle().playerConnection == null) {
+			return null;
+		}
+
+		SocketAddress addr = getHandle().playerConnection.networkManager.getSocketAddress();
+		if (addr instanceof InetSocketAddress) {
+			return (InetSocketAddress) addr;
+		} else {
+			return null;
+		}
+	}
+
+	@Override
+	public double getEyeHeight() {
+		return getEyeHeight(false);
+	}
+
+	@Override
+	public double getEyeHeight(boolean ignoreSneaking) {
+		if (ignoreSneaking) {
+			return 1.62D;
+		} else {
+			if (isSneaking()) {
+				return 1.54D;
+			} else {
+				return 1.62D;
+			}
+		}
+	}
+
+	@Override
+	public void sendRawMessage(String message) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		for (IChatBaseComponent component : CraftChatMessage.fromString(message)) {
+			getHandle().playerConnection.sendPacket(new PacketPlayOutChat(component));
+		}
+	}
+
+	@Override
+	public void sendMessage(String message) {
+		if (!conversationTracker.isConversingModaly()) {
+			this.sendRawMessage(message);
+		}
+	}
+
+	@Override
+	public void sendMessage(String[] messages) {
+		for (String message : messages) {
+			sendMessage(message);
+		}
+	}
+
+	// Paper start
+	@Override
+	public void sendMessage(BaseComponent component) {
+		sendMessage(new BaseComponent[]{component});
+	}
+
+	@Override
+	public void sendMessage(BaseComponent... components) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		PacketPlayOutChat packet = new PacketPlayOutChat();
+		packet.components = components;
+		getHandle().playerConnection.sendPacket(packet);
+	}
+
+	public void sendFormattedMessage(String message, final Object... params) {
+		if (this.getHandle().playerConnection == null) {
+			return;
+		}
+
+		message = MessageFormat.format(message, params);
+		for (final IChatBaseComponent component : CraftChatMessage.fromString(message)) {
+			getHandle().playerConnection.sendPacket(new PacketPlayOutChat(component));
+		}
+	}
+
+	@Override
+	public void setPlayerListHeaderFooter(BaseComponent[] header, BaseComponent[] footer) {
+		PacketPlayOutPlayerListHeaderFooter packet = new PacketPlayOutPlayerListHeaderFooter();
+		packet.header = header;
+		packet.footer = footer;
+		getHandle().playerConnection.sendPacket(packet);
+	}
+
+	@Override
+	public void setPlayerListHeaderFooter(BaseComponent header, BaseComponent footer) {
+		this.setPlayerListHeaderFooter(header == null ? null : new BaseComponent[]{header},
+				footer == null ? null : new BaseComponent[]{footer});
+	}
+
+
+	@Override
+	public void setTitleTimes(int fadeInTicks, int stayTicks, int fadeOutTicks) {
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.TIMES, (BaseComponent[]) null, fadeInTicks,
+						stayTicks, fadeOutTicks));
+	}
+
+	@Override
+	public void setSubtitle(BaseComponent[] subtitle) {
+		getHandle().playerConnection
+				.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.SUBTITLE, subtitle, 0, 0, 0));
+	}
+
+	@Override
+	public void setSubtitle(BaseComponent subtitle) {
+		setSubtitle(new BaseComponent[]{subtitle});
+	}
+
+	@Override
+	public void showTitle(BaseComponent[] title) {
+		getHandle().playerConnection
+				.sendPacket(new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.TITLE, title, 0, 0, 0));
+	}
+
+	@Override
+	public void showTitle(BaseComponent title) {
+		showTitle(new BaseComponent[]{title});
+	}
+
+	@Override
+	public void showTitle(BaseComponent[] title, BaseComponent[] subtitle, int fadeInTicks, int stayTicks,
+	                      int fadeOutTicks) {
+		setTitleTimes(fadeInTicks, stayTicks, fadeOutTicks);
+		setSubtitle(subtitle);
+		showTitle(title);
+	}
+
+	@Override
+	public void showTitle(BaseComponent title, BaseComponent subtitle, int fadeInTicks, int stayTicks,
+	                      int fadeOutTicks) {
+		setTitleTimes(fadeInTicks, stayTicks, fadeOutTicks);
+		setSubtitle(subtitle);
+		showTitle(title);
+	}
+
+	@Override
+	public void sendTitle(Title title) {
+		Preconditions.checkNotNull(title, "Title is null");
+		setTitleTimes(title.getFadeIn(), title.getStay(), title.getFadeOut());
+		setSubtitle(title.getSubtitle() == null ? new BaseComponent[0] : title.getSubtitle());
+		showTitle(title.getTitle());
+	}
+
+	@Override
+	public void updateTitle(Title title) {
+		Preconditions.checkNotNull(title, "Title is null");
+		setTitleTimes(title.getFadeIn(), title.getStay(), title.getFadeOut());
+		if (title.getSubtitle() != null) {
+			setSubtitle(title.getSubtitle());
+		}
+		showTitle(title.getTitle());
+	}
+
+	@Override
+	public void hideTitle() {
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutTitle(PacketPlayOutTitle.EnumTitleAction.CLEAR, (BaseComponent[]) null, 0, 0, 0));
+	}
+	// Paper end
+
+	@Override
+	public String getDisplayName() {
+		return getHandle().displayName;
+	}
+
+	@Override
+	public void setDisplayName(final String name) {
+		getHandle().displayName = name == null ? getName() : name;
+	}
+
+	@Override
+	public String getPlayerListName() {
+		return getHandle().listName == null ? getName() : CraftChatMessage.fromComponent(getHandle().listName);
+	}
+
+	@Override
+	public void setPlayerListName(String name) {
+		if (name == null) {
+			name = getName();
+		}
+		getHandle().listName = name.equals(getName()) ? null : CraftChatMessage.fromString(name)[0];
+		for (EntityPlayer player : server.getHandle().players) {
+			if (!PotionSpigot.INSTANCE.getConfig().isHidePlayersFromTab() || player.getBukkitEntity().canSee(this)) {
+				player.playerConnection.sendPacket(
+						new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_DISPLAY_NAME,
+								this.getHandle()));
+			}
+		}
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		if (!(obj instanceof OfflinePlayer)) {
+			return false;
+		}
+		OfflinePlayer other = (OfflinePlayer) obj;
+		if ((this.getUniqueId() == null) || (other.getUniqueId() == null)) {
+			return false;
+		}
+
+		boolean uuidEquals = this.getUniqueId().equals(other.getUniqueId());
+		boolean idEquals = true;
+
+		if (other instanceof CraftPlayer) {
+			idEquals = this.getEntityId() == ((CraftPlayer) other).getEntityId();
+		}
+
+		return uuidEquals && idEquals;
+	}
+
+	@Override
+	public void kickPlayer(String message) {
+		org.spigotmc.AsyncCatcher.catchOp("player kick"); // Spigot
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		getHandle().playerConnection.disconnect(message == null ? "" : message);
+	}
+
+	@Override
+	public void setCompassTarget(Location loc) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		// Do not directly assign here, from the packethandler we'll assign it.
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutSpawnPosition(new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ())));
+	}
+
+	@Override
+	public Location getCompassTarget() {
+		return getHandle().compassTarget;
+	}
+
+	@Override
+	public void chat(String msg) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		getHandle().playerConnection.chat(msg, false);
+	}
+
+	@Override
+	public boolean performCommand(String command) {
+		return server.dispatchCommand(this, command);
+	}
+
+	@Override
+	public void playNote(Location loc, byte instrument, byte note) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		String instrumentName = null;
+		switch (instrument) {
+			case 0:
+				instrumentName = "harp";
+				break;
+			case 1:
+				instrumentName = "bd";
+				break;
+			case 2:
+				instrumentName = "snare";
+				break;
+			case 3:
+				instrumentName = "hat";
+				break;
+			case 4:
+				instrumentName = "bassattack";
+				break;
+		}
+
+		float f = (float) Math.pow(2.0D, (note - 12.0D) / 12.0D);
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutNamedSoundEffect("note." + instrumentName, loc.getBlockX(), loc.getBlockY(),
+						loc.getBlockZ(), 3.0f, f));
+	}
+
+	@Override
+	public void playNote(Location loc, Instrument instrument, Note note) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		String instrumentName = null;
+		switch (instrument.ordinal()) {
+			case 0:
+				instrumentName = "harp";
+				break;
+			case 1:
+				instrumentName = "bd";
+				break;
+			case 2:
+				instrumentName = "snare";
+				break;
+			case 3:
+				instrumentName = "hat";
+				break;
+			case 4:
+				instrumentName = "bassattack";
+				break;
+		}
+		float f = (float) Math.pow(2.0D, (note.getId() - 12.0D) / 12.0D);
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutNamedSoundEffect("note." + instrumentName, loc.getBlockX(), loc.getBlockY(),
+						loc.getBlockZ(), 3.0f, f));
+	}
+
+	@Override
+	public void playSound(Location loc, Sound sound, float volume, float pitch) {
+		if (sound == null) {
+			return;
+		}
+		playSound(loc, CraftSound.getSound(sound), volume, pitch);
+	}
+
+	@Override
+	public void playSound(Location loc, String sound, float volume, float pitch) {
+		if (loc == null || sound == null || getHandle().playerConnection == null) {
+			return;
+		}
+
+		double x = loc.getBlockX() + 0.5;
+		double y = loc.getBlockY() + 0.5;
+		double z = loc.getBlockZ() + 0.5;
+
+		PacketPlayOutNamedSoundEffect packet = new PacketPlayOutNamedSoundEffect(sound, x, y, z, volume, pitch);
+		getHandle().playerConnection.sendPacket(packet);
+	}
+
+	@Override
+	public void playEffect(Location loc, Effect effect, int data) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		spigot().playEffect(loc, effect, data, 0, 0, 0, 0, 1, 1, 64); // Spigot
+	}
+
+	@Override
+	public <T> void playEffect(Location loc, Effect effect, T data) {
+		if (data != null) {
+			Validate.isTrue(data.getClass().isAssignableFrom(effect.getData()), "Wrong kind of data for this effect!");
+		} else {
+			Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
+		}
+
+		int datavalue = data == null ? 0 : CraftEffect.getDataValue(effect, data);
+		playEffect(loc, effect, datavalue);
+	}
+
+	@Override
+	public void sendBlockChange(Location loc, Material material, byte data) {
+		sendBlockChange(loc, material.getId(), data);
+	}
+
+	@Override
+	public void sendBlockChange(Location loc, int material, byte data) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		PacketPlayOutBlockChange packet = new PacketPlayOutBlockChange(((CraftWorld) loc.getWorld()).getHandle(),
+				new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()));
+
+		packet.block = CraftMagicNumbers.getBlock(material).fromLegacyData(data);
+		getHandle().playerConnection.sendPacket(packet);
+	}
+
+	@Override
+	public void sendSignChange(Location loc, String[] lines) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		if (lines == null) {
+			lines = new String[4];
+		}
+
+		Validate.notNull(loc, "Location can not be null");
+		if (lines.length < 4) {
+			throw new IllegalArgumentException("Must have at least 4 lines");
+		}
+
+		IChatBaseComponent[] components = CraftSign.sanitizeLines(lines);
+
+		getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateSign(getHandle().world,
+				new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ()), components));
+	}
+
+	@Override
+	public boolean sendChunkChange(Location loc, int sx, int sy, int sz, byte[] data) {
+		if (getHandle().playerConnection == null) {
+			return false;
+		}
 
         /*
         int x = loc.getBlockX();
@@ -497,1112 +602,1224 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
         return true;
         */
 
-        throw new NotImplementedException("Chunk changes do not yet work"); // TODO: Chunk changes.
-    }
-
-    @Override
-    public void sendMap(MapView map) {
-        if (getHandle().playerConnection == null) return;
-
-        RenderData data = ((CraftMapView) map).render(this);
-        Collection<MapIcon> icons = new ArrayList<MapIcon>();
-        for (MapCursor cursor : data.cursors) {
-            if (cursor.isVisible()) {
-                icons.add(new MapIcon(cursor.getRawType(), cursor.getX(), cursor.getY(), cursor.getDirection()));
-            }
-        }
-
-        PacketPlayOutMap packet = new PacketPlayOutMap(map.getId(), map.getScale().getValue(), icons, data.buffer, 0, 0, 0, 0);
-        getHandle().playerConnection.sendPacket(packet);
-    }
-
-    @Override
-    public boolean teleport(Location location, PlayerTeleportEvent.TeleportCause cause) {
-        EntityPlayer entity = getHandle();
-
-        if (getHealth() == 0 || entity.dead) {
-            return false;
-        }
-
-        if (entity.playerConnection == null || entity.playerConnection.isDisconnected()) {
-           return false;
-        }
-
-        if (entity.passenger != null) {
-            return false;
-        }
-
-        // From = Players current Location
-        Location from = this.getLocation();
-        // To = Players new Location if Teleport is Successful
-        Location to = location;
-        // Create & Call the Teleport Event.
-        PlayerTeleportEvent event = new PlayerTeleportEvent(this, from, to, cause);
-        server.getPluginManager().callEvent(event);
-
-        // Return False to inform the Plugin that the Teleport was unsuccessful/cancelled.
-        if (event.isCancelled()) {
-            return false;
-        }
-
-        // If this player is riding another entity, we must dismount before teleporting.
-        entity.mount(null);
-
-        // Update the From Location
-        from = event.getFrom();
-        // Grab the new To Location dependent on whether the event was cancelled.
-        to = event.getTo();
-        // Grab the To and From World Handles.
-        WorldServer fromWorld = ((CraftWorld) from.getWorld()).getHandle();
-        WorldServer toWorld = ((CraftWorld) to.getWorld()).getHandle();
-
-        // Close any foreign inventory
-        if (getHandle().activeContainer != getHandle().defaultContainer) {
-            getHandle().closeInventory();
-        }
-
-        // Check if the fromWorld and toWorld are the same.
-        if (fromWorld == toWorld) {
-            entity.playerConnection.teleport(to);
-        } else {
-            server.getHandle().moveToWorld(entity, toWorld.dimension, true, to, !toWorld.paperSpigotConfig.disableTeleportationSuffocationCheck);
-        }
-        return true;
-    }
-
-    @Override
-    public void setSneaking(boolean sneak) {
-        getHandle().setSneaking(sneak);
-    }
-
-    @Override
-    public boolean isSneaking() {
-        return getHandle().isSneaking();
-    }
-
-    @Override
-    public boolean isSprinting() {
-        return getHandle().isSprinting();
-    }
-
-    @Override
-    public void setSprinting(boolean sprinting) {
-        getHandle().setSprinting(sprinting);
-    }
-
-    @Override
-    public void loadData() {
-        server.getHandle().playerFileData.load(getHandle());
-    }
-
-    @Override
-    public void saveData() {
-        server.getHandle().playerFileData.save(getHandle());
-    }
-
-    @Deprecated
-    @Override
-    public void updateInventory() {
-        getHandle().updateInventory(getHandle().activeContainer);
-    }
-
-    @Override
-    public void setSleepingIgnored(boolean isSleeping) {
-        getHandle().fauxSleeping = isSleeping;
-        ((CraftWorld) getWorld()).getHandle().checkSleepStatus();
-    }
-
-    @Override
-    public boolean isSleepingIgnored() {
-        return getHandle().fauxSleeping;
-    }
-
-    @Override
-    public void awardAchievement(Achievement achievement) {
-        Validate.notNull(achievement, "Achievement cannot be null");
-        if (achievement.hasParent() && !hasAchievement(achievement.getParent())) {
-            awardAchievement(achievement.getParent());
-        }
-        getHandle().getStatisticManager().setStatistic(getHandle(), CraftStatistic.getNMSAchievement(achievement), 1);
-        getHandle().getStatisticManager().updateStatistics(getHandle());
-    }
-
-    @Override
-    public void removeAchievement(Achievement achievement) {
-        Validate.notNull(achievement, "Achievement cannot be null");
-        for (Achievement achieve : Achievement.values()) {
-            if (achieve.getParent() == achievement && hasAchievement(achieve)) {
-                removeAchievement(achieve);
-            }
-        }
-        getHandle().getStatisticManager().setStatistic(getHandle(), CraftStatistic.getNMSAchievement(achievement), 0);
-    }
-
-    @Override
-    public boolean hasAchievement(Achievement achievement) {
-        Validate.notNull(achievement, "Achievement cannot be null");
-        return getHandle().getStatisticManager().hasAchievement(CraftStatistic.getNMSAchievement(achievement));
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic) {
-        incrementStatistic(statistic, 1);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic) {
-        decrementStatistic(statistic, 1);
-    }
-
-    @Override
-    public int getStatistic(Statistic statistic) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.isTrue(statistic.getType() == Type.UNTYPED, "Must supply additional paramater for this statistic");
-        return getHandle().getStatisticManager().getStatisticValue(CraftStatistic.getNMSStatistic(statistic));
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, getStatistic(statistic) + amount);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, getStatistic(statistic) - amount);
-    }
-
-    @Override
-    public void setStatistic(Statistic statistic, int newValue) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.isTrue(statistic.getType() == Type.UNTYPED, "Must supply additional paramater for this statistic");
-        Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
-        net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getNMSStatistic(statistic);
-        getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic, Material material) {
-        incrementStatistic(statistic, material, 1);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic, Material material) {
-        decrementStatistic(statistic, material, 1);
-    }
-
-    @Override
-    public int getStatistic(Statistic statistic, Material material) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.notNull(material, "Material cannot be null");
-        Validate.isTrue(statistic.getType() == Type.BLOCK || statistic.getType() == Type.ITEM, "This statistic does not take a Material parameter");
-        net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getMaterialStatistic(statistic, material);
-        Validate.notNull(nmsStatistic, "The supplied Material does not have a corresponding statistic");
-        return getHandle().getStatisticManager().getStatisticValue(nmsStatistic);
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic, Material material, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, material, getStatistic(statistic, material) + amount);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic, Material material, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, material, getStatistic(statistic, material) - amount);
-    }
-
-    @Override
-    public void setStatistic(Statistic statistic, Material material, int newValue) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.notNull(material, "Material cannot be null");
-        Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
-        Validate.isTrue(statistic.getType() == Type.BLOCK || statistic.getType() == Type.ITEM, "This statistic does not take a Material parameter");
-        net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getMaterialStatistic(statistic, material);
-        Validate.notNull(nmsStatistic, "The supplied Material does not have a corresponding statistic");
-        getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic, EntityType entityType) {
-        incrementStatistic(statistic, entityType, 1);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic, EntityType entityType) {
-        decrementStatistic(statistic, entityType, 1);
-    }
-
-    @Override
-    public int getStatistic(Statistic statistic, EntityType entityType) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.notNull(entityType, "EntityType cannot be null");
-        Validate.isTrue(statistic.getType() == Type.ENTITY, "This statistic does not take an EntityType parameter");
-        net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getEntityStatistic(statistic, entityType);
-        Validate.notNull(nmsStatistic, "The supplied EntityType does not have a corresponding statistic");
-        return getHandle().getStatisticManager().getStatisticValue(nmsStatistic);
-    }
-
-    @Override
-    public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, entityType, getStatistic(statistic, entityType) + amount);
-    }
-
-    @Override
-    public void decrementStatistic(Statistic statistic, EntityType entityType, int amount) {
-        Validate.isTrue(amount > 0, "Amount must be greater than 0");
-        setStatistic(statistic, entityType, getStatistic(statistic, entityType) - amount);
-    }
-
-    @Override
-    public void setStatistic(Statistic statistic, EntityType entityType, int newValue) {
-        Validate.notNull(statistic, "Statistic cannot be null");
-        Validate.notNull(entityType, "EntityType cannot be null");
-        Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
-        Validate.isTrue(statistic.getType() == Type.ENTITY, "This statistic does not take an EntityType parameter");
-        net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getEntityStatistic(statistic, entityType);
-        Validate.notNull(nmsStatistic, "The supplied EntityType does not have a corresponding statistic");
-        getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
-    }
-
-    @Override
-    public void setPlayerTime(long time, boolean relative) {
-        getHandle().timeOffset = time;
-        getHandle().relativeTime = relative;
-    }
-
-    @Override
-    public long getPlayerTimeOffset() {
-        return getHandle().timeOffset;
-    }
-
-    @Override
-    public long getPlayerTime() {
-        return getHandle().getPlayerTime();
-    }
-
-    @Override
-    public boolean isPlayerTimeRelative() {
-        return getHandle().relativeTime;
-    }
-
-    @Override
-    public void resetPlayerTime() {
-        setPlayerTime(0, true);
-    }
-
-    @Override
-    public void setPlayerWeather(WeatherType type) {
-        getHandle().setPlayerWeather(type, true);
-    }
-
-    @Override
-    public WeatherType getPlayerWeather() {
-        return getHandle().getPlayerWeather();
-    }
-
-    @Override
-    public void resetPlayerWeather() {
-        getHandle().resetPlayerWeather();
-    }
-
-    @Override
-    public boolean isBanned() {
-        return server.getBanList(BanList.Type.NAME).isBanned(getName());
-    }
-
-    @Override
-    public void setBanned(boolean value) {
-        if (value) {
-            server.getBanList(BanList.Type.NAME).addBan(getName(), null, null, null);
-        } else {
-            server.getBanList(BanList.Type.NAME).pardon(getName());
-        }
-    }
-
-    @Override
-    public boolean isWhitelisted() {
-        return server.getHandle().getWhitelist().isWhitelisted(getProfile());
-    }
-
-    @Override
-    public void setWhitelisted(boolean value) {
-        if (value) {
-            server.getHandle().addWhitelist(getProfile());
-        } else {
-            server.getHandle().removeWhitelist(getProfile());
-        }
-    }
-
-    @Override
-    public void setGameMode(GameMode mode) {
-        if (getHandle().playerConnection == null) return;
-
-        if (mode == null) {
-            throw new IllegalArgumentException("Mode cannot be null");
-        }
-
-        if (mode != getGameMode()) {
-            PlayerGameModeChangeEvent event = new PlayerGameModeChangeEvent(this, mode);
-            server.getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                return;
-            }
-            
-            getHandle().setSpectatorTarget(getHandle());
-            getHandle().playerInteractManager.setGameMode(WorldSettings.EnumGamemode.getById(mode.getValue()));
-            getHandle().fallDistance = 0;
-            getHandle().playerConnection.sendPacket(new PacketPlayOutGameStateChange(3, mode.getValue()));
-        }
-    }
-
-    @Override
-    public GameMode getGameMode() {
-        return GameMode.getByValue(getHandle().playerInteractManager.getGameMode().getId());
-    }
-
-    @Override
-    public void giveExp(int exp) {
-        getHandle().giveExp(exp);
-    }
-
-    @Override
-    public void giveExpLevels(int levels) {
-        getHandle().levelDown(levels);
-    }
-
-    @Override
-    public float getExp() {
-        return getHandle().exp;
-    }
-
-    @Override
-    public void setExp(float exp) {
-        getHandle().exp = exp;
-        getHandle().lastSentExp = -1;
-    }
-
-    @Override
-    public int getLevel() {
-        return getHandle().expLevel;
-    }
-
-    @Override
-    public void setLevel(int level) {
-        getHandle().expLevel = level;
-        getHandle().lastSentExp = -1;
-    }
-
-    @Override
-    public int getTotalExperience() {
-        return getHandle().expTotal;
-    }
-
-    @Override
-    public void setTotalExperience(int exp) {
-        getHandle().expTotal = exp;
-    }
-
-    @Override
-    public float getExhaustion() {
-        return getHandle().getFoodData().exhaustionLevel;
-    }
-
-    @Override
-    public void setExhaustion(float value) {
-        getHandle().getFoodData().exhaustionLevel = value;
-    }
-
-    @Override
-    public float getSaturation() {
-        return getHandle().getFoodData().saturationLevel;
-    }
-
-    @Override
-    public void setSaturation(float value) {
-        getHandle().getFoodData().saturationLevel = value;
-    }
-
-    @Override
-    public int getFoodLevel() {
-        return getHandle().getFoodData().foodLevel;
-    }
-
-    @Override
-    public void setFoodLevel(int value) {
-        getHandle().getFoodData().foodLevel = value;
-    }
-
-    @Override
-    public Location getBedSpawnLocation() {
-        World world = getServer().getWorld(getHandle().spawnWorld);
-        BlockPosition bed = getHandle().getBed();
-
-        if (world != null && bed != null) {
-            bed = EntityHuman.getBed(((CraftWorld) world).getHandle(), bed, getHandle().isRespawnForced());
-            if (bed != null) {
-                return new Location(world, bed.getX(), bed.getY(), bed.getZ());
-            }
-        }
-        return null;
-    }
-
-    @Override
-    public void setBedSpawnLocation(Location location) {
-        setBedSpawnLocation(location, false);
-    }
-
-    @Override
-    public void setBedSpawnLocation(Location location, boolean override) {
-        if (location == null) {
-            getHandle().setRespawnPosition(null, override);
-        } else {
-            getHandle().setRespawnPosition(new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ()), override);
-            getHandle().spawnWorld = location.getWorld().getName();
-        }
-    }
-
-    @Override
-    public void hidePlayer(Player player) {
-        Validate.notNull(player, "hidden player cannot be null");
-        if (getHandle().playerConnection == null) return;
-        if (equals(player)) return;
-        if (hiddenPlayers.contains(player.getUniqueId())) return;
-        hiddenPlayers.add(player.getUniqueId());
-
-        //remove this player from the hidden player's EntityTrackerEntry
-        EntityTracker tracker = ((WorldServer) entity.world).tracker;
-        EntityPlayer other = ((CraftPlayer) player).getHandle();
-        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
-        if (entry != null) {
-            entry.clear(getHandle());
-        }
-
-        //remove the hidden player from this player user list
-        getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, other));
-    }
-
-    @Override
-    public void showPlayer(Player player) {
-        Validate.notNull(player, "shown player cannot be null");
-        if (getHandle().playerConnection == null) return;
-        if (equals(player)) return;
-        if (!hiddenPlayers.contains(player.getUniqueId())) return;
-        hiddenPlayers.remove(player.getUniqueId());
-
-        EntityTracker tracker = ((WorldServer) entity.world).tracker;
-        EntityPlayer other = ((CraftPlayer) player).getHandle();
-
-        getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, other));
-
-        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
-        if (entry != null && !entry.trackedPlayers.contains(getHandle())) {
-            entry.updatePlayer(getHandle());
-        }
-    }
-
+		throw new NotImplementedException("Chunk changes do not yet work"); // TODO: Chunk changes.
+	}
+
+	@Override
+	public void sendMap(MapView map) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		RenderData data = ((CraftMapView) map).render(this);
+		Collection<MapIcon> icons = new ArrayList<MapIcon>();
+		for (MapCursor cursor : data.cursors) {
+			if (cursor.isVisible()) {
+				icons.add(new MapIcon(cursor.getRawType(), cursor.getX(), cursor.getY(), cursor.getDirection()));
+			}
+		}
+
+		PacketPlayOutMap packet = new PacketPlayOutMap(map.getId(), map.getScale().getValue(), icons, data.buffer,
+				0, 0,
+				0, 0);
+		getHandle().playerConnection.sendPacket(packet);
+	}
+
+	@Override
+	public boolean teleport(Location location, PlayerTeleportEvent.TeleportCause cause) {
+		EntityPlayer entity = getHandle();
+
+		if (getHealth() == 0 || entity.dead) {
+			return false;
+		}
+
+		if (entity.playerConnection == null || entity.playerConnection.isDisconnected()) {
+			return false;
+		}
+
+		if (entity.passenger != null) {
+			return false;
+		}
+
+		// From = Players current Location
+		Location from = this.getLocation();
+		// To = Players new Location if Teleport is Successful
+		Location to = location;
+		// Create & Call the Teleport Event.
+		PlayerTeleportEvent event = new PlayerTeleportEvent(this, from, to, cause);
+		server.getPluginManager().callEvent(event);
+
+		// Return False to inform the Plugin that the Teleport was unsuccessful/cancelled.
+		if (event.isCancelled()) {
+			return false;
+		}
+
+		// If this player is riding another entity, we must dismount before teleporting.
+		entity.mount(null);
+
+		// Update the From Location
+		from = event.getFrom();
+		// Grab the new To Location dependent on whether the event was cancelled.
+		to = event.getTo();
+		// Grab the To and From World Handles.
+		WorldServer fromWorld = ((CraftWorld) from.getWorld()).getHandle();
+		WorldServer toWorld = ((CraftWorld) to.getWorld()).getHandle();
+
+		// Close any foreign inventory
+		if (getHandle().activeContainer != getHandle().defaultContainer) {
+			getHandle().closeInventory();
+		}
+
+		// Check if the fromWorld and toWorld are the same.
+		if (fromWorld == toWorld) {
+			entity.playerConnection.teleport(to);
+		} else {
+			server.getHandle().moveToWorld(entity, toWorld.dimension, true, to,
+					!toWorld.paperSpigotConfig.disableTeleportationSuffocationCheck);
+		}
+		return true;
+	}
+
+	@Override
+	public void setSneaking(boolean sneak) {
+		getHandle().setSneaking(sneak);
+	}
+
+	@Override
+	public boolean isSneaking() {
+		return getHandle().isSneaking();
+	}
+
+	@Override
+	public boolean isSprinting() {
+		return getHandle().isSprinting();
+	}
+
+	@Override
+	public void setSprinting(boolean sprinting) {
+		getHandle().setSprinting(sprinting);
+	}
+
+	@Override
+	public void loadData() {
+		server.getHandle().playerFileData.load(getHandle());
+	}
+
+	@Override
+	public void saveData() {
+		server.getHandle().playerFileData.save(getHandle());
+	}
+
+	@Deprecated
+	@Override
+	public void updateInventory() {
+		getHandle().updateInventory(getHandle().activeContainer);
+	}
+
+	@Override
+	public void setSleepingIgnored(boolean isSleeping) {
+		getHandle().fauxSleeping = isSleeping;
+		((CraftWorld) getWorld()).getHandle().checkSleepStatus();
+	}
+
+	@Override
+	public boolean isSleepingIgnored() {
+		return getHandle().fauxSleeping;
+	}
+
+	@Override
+	public void awardAchievement(Achievement achievement) {
+		Validate.notNull(achievement, "Achievement cannot be null");
+		if (achievement.hasParent() && !hasAchievement(achievement.getParent())) {
+			awardAchievement(achievement.getParent());
+		}
+		getHandle().getStatisticManager().setStatistic(getHandle(), CraftStatistic.getNMSAchievement(achievement), 1);
+		getHandle().getStatisticManager().updateStatistics(getHandle());
+	}
+
+	@Override
+	public void removeAchievement(Achievement achievement) {
+		Validate.notNull(achievement, "Achievement cannot be null");
+		for (Achievement achieve : Achievement.values()) {
+			if (achieve.getParent() == achievement && hasAchievement(achieve)) {
+				removeAchievement(achieve);
+			}
+		}
+		getHandle().getStatisticManager().setStatistic(getHandle(), CraftStatistic.getNMSAchievement(achievement), 0);
+	}
+
+	@Override
+	public boolean hasAchievement(Achievement achievement) {
+		Validate.notNull(achievement, "Achievement cannot be null");
+		return getHandle().getStatisticManager().hasAchievement(CraftStatistic.getNMSAchievement(achievement));
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic) {
+		incrementStatistic(statistic, 1);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic) {
+		decrementStatistic(statistic, 1);
+	}
+
+	@Override
+	public int getStatistic(Statistic statistic) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.isTrue(statistic.getType() == Type.UNTYPED, "Must supply additional paramater for this statistic");
+		return getHandle().getStatisticManager().getStatisticValue(CraftStatistic.getNMSStatistic(statistic));
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, getStatistic(statistic) + amount);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, getStatistic(statistic) - amount);
+	}
+
+	@Override
+	public void setStatistic(Statistic statistic, int newValue) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.isTrue(statistic.getType() == Type.UNTYPED, "Must supply additional paramater for this statistic");
+		Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
+		net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getNMSStatistic(statistic);
+		getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic, Material material) {
+		incrementStatistic(statistic, material, 1);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic, Material material) {
+		decrementStatistic(statistic, material, 1);
+	}
+
+	@Override
+	public int getStatistic(Statistic statistic, Material material) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.notNull(material, "Material cannot be null");
+		Validate.isTrue(statistic.getType() == Type.BLOCK || statistic.getType() == Type.ITEM,
+				"This statistic does not take a Material parameter");
+		net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getMaterialStatistic(statistic, material);
+		Validate.notNull(nmsStatistic, "The supplied Material does not have a corresponding statistic");
+		return getHandle().getStatisticManager().getStatisticValue(nmsStatistic);
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic, Material material, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, material, getStatistic(statistic, material) + amount);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic, Material material, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, material, getStatistic(statistic, material) - amount);
+	}
+
+	@Override
+	public void setStatistic(Statistic statistic, Material material, int newValue) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.notNull(material, "Material cannot be null");
+		Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
+		Validate.isTrue(statistic.getType() == Type.BLOCK || statistic.getType() == Type.ITEM,
+				"This statistic does not take a Material parameter");
+		net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getMaterialStatistic(statistic, material);
+		Validate.notNull(nmsStatistic, "The supplied Material does not have a corresponding statistic");
+		getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic, EntityType entityType) {
+		incrementStatistic(statistic, entityType, 1);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic, EntityType entityType) {
+		decrementStatistic(statistic, entityType, 1);
+	}
+
+	@Override
+	public int getStatistic(Statistic statistic, EntityType entityType) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.notNull(entityType, "EntityType cannot be null");
+		Validate.isTrue(statistic.getType() == Type.ENTITY, "This statistic does not take an EntityType parameter");
+		net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getEntityStatistic(statistic, entityType);
+		Validate.notNull(nmsStatistic, "The supplied EntityType does not have a corresponding statistic");
+		return getHandle().getStatisticManager().getStatisticValue(nmsStatistic);
+	}
+
+	@Override
+	public void incrementStatistic(Statistic statistic, EntityType entityType, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, entityType, getStatistic(statistic, entityType) + amount);
+	}
+
+	@Override
+	public void decrementStatistic(Statistic statistic, EntityType entityType, int amount) {
+		Validate.isTrue(amount > 0, "Amount must be greater than 0");
+		setStatistic(statistic, entityType, getStatistic(statistic, entityType) - amount);
+	}
+
+	@Override
+	public void setStatistic(Statistic statistic, EntityType entityType, int newValue) {
+		Validate.notNull(statistic, "Statistic cannot be null");
+		Validate.notNull(entityType, "EntityType cannot be null");
+		Validate.isTrue(newValue >= 0, "Value must be greater than or equal to 0");
+		Validate.isTrue(statistic.getType() == Type.ENTITY, "This statistic does not take an EntityType parameter");
+		net.minecraft.server.Statistic nmsStatistic = CraftStatistic.getEntityStatistic(statistic, entityType);
+		Validate.notNull(nmsStatistic, "The supplied EntityType does not have a corresponding statistic");
+		getHandle().getStatisticManager().setStatistic(getHandle(), nmsStatistic, newValue);
+	}
+
+	@Override
+	public void setPlayerTime(long time, boolean relative) {
+		getHandle().timeOffset = time;
+		getHandle().relativeTime = relative;
+	}
+
+	@Override
+	public long getPlayerTimeOffset() {
+		return getHandle().timeOffset;
+	}
+
+	@Override
+	public long getPlayerTime() {
+		return getHandle().getPlayerTime();
+	}
+
+	@Override
+	public boolean isPlayerTimeRelative() {
+		return getHandle().relativeTime;
+	}
+
+	@Override
+	public void resetPlayerTime() {
+		setPlayerTime(0, true);
+	}
+
+	@Override
+	public void setPlayerWeather(WeatherType type) {
+		getHandle().setPlayerWeather(type, true);
+	}
+
+	@Override
+	public WeatherType getPlayerWeather() {
+		return getHandle().getPlayerWeather();
+	}
+
+	@Override
+	public void resetPlayerWeather() {
+		getHandle().resetPlayerWeather();
+	}
+
+	@Override
+	public boolean isBanned() {
+		return server.getBanList(BanList.Type.NAME).isBanned(getName());
+	}
+
+	@Override
+	public void setBanned(boolean value) {
+		if (value) {
+			server.getBanList(BanList.Type.NAME).addBan(getName(), null, null, null);
+		} else {
+			server.getBanList(BanList.Type.NAME).pardon(getName());
+		}
+	}
+
+	@Override
+	public boolean isWhitelisted() {
+		return server.getHandle().getWhitelist().isWhitelisted(getProfile());
+	}
+
+	@Override
+	public void setWhitelisted(boolean value) {
+		if (value) {
+			server.getHandle().addWhitelist(getProfile());
+		} else {
+			server.getHandle().removeWhitelist(getProfile());
+		}
+	}
+
+	@Override
+	public void setGameMode(GameMode mode) {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		if (mode == null) {
+			throw new IllegalArgumentException("Mode cannot be null");
+		}
+
+		if (mode != getGameMode()) {
+			PlayerGameModeChangeEvent event = new PlayerGameModeChangeEvent(this, mode);
+			server.getPluginManager().callEvent(event);
+			if (event.isCancelled()) {
+				return;
+			}
+
+			getHandle().setSpectatorTarget(getHandle());
+			getHandle().playerInteractManager.setGameMode(WorldSettings.EnumGamemode.getById(mode.getValue()));
+			getHandle().fallDistance = 0;
+			getHandle().playerConnection.sendPacket(new PacketPlayOutGameStateChange(3, mode.getValue()));
+		}
+	}
+
+	@Override
+	public GameMode getGameMode() {
+		return GameMode.getByValue(getHandle().playerInteractManager.getGameMode().getId());
+	}
+
+	@Override
+	public void giveExp(int exp) {
+		getHandle().giveExp(exp);
+	}
+
+	@Override
+	public void giveExpLevels(int levels) {
+		getHandle().levelDown(levels);
+	}
+
+	@Override
+	public float getExp() {
+		return getHandle().exp;
+	}
+
+	@Override
+	public void setExp(float exp) {
+		getHandle().exp = exp;
+		getHandle().lastSentExp = -1;
+	}
+
+	@Override
+	public int getLevel() {
+		return getHandle().expLevel;
+	}
+
+	@Override
+	public void setLevel(int level) {
+		getHandle().expLevel = level;
+		getHandle().lastSentExp = -1;
+	}
+
+	@Override
+	public int getTotalExperience() {
+		return getHandle().expTotal;
+	}
+
+	@Override
+	public void setTotalExperience(int exp) {
+		getHandle().expTotal = exp;
+	}
+
+	@Override
+	public float getExhaustion() {
+		return getHandle().getFoodData().exhaustionLevel;
+	}
+
+	@Override
+	public void setExhaustion(float value) {
+		getHandle().getFoodData().exhaustionLevel = value;
+	}
+
+	@Override
+	public float getSaturation() {
+		return getHandle().getFoodData().saturationLevel;
+	}
+
+	@Override
+	public void setSaturation(float value) {
+		getHandle().getFoodData().saturationLevel = value;
+	}
+
+	@Override
+	public int getFoodLevel() {
+		return getHandle().getFoodData().foodLevel;
+	}
+
+	@Override
+	public void setFoodLevel(int value) {
+		getHandle().getFoodData().foodLevel = value;
+	}
+
+	@Override
+	public Location getBedSpawnLocation() {
+		World world = getServer().getWorld(getHandle().spawnWorld);
+		BlockPosition bed = getHandle().getBed();
+
+		if (world != null && bed != null) {
+			bed = EntityHuman.getBed(((CraftWorld) world).getHandle(), bed, getHandle().isRespawnForced());
+			if (bed != null) {
+				return new Location(world, bed.getX(), bed.getY(), bed.getZ());
+			}
+		}
+		return null;
+	}
+
+	@Override
+	public void setBedSpawnLocation(Location location) {
+		setBedSpawnLocation(location, false);
+	}
+
+	@Override
+	public void setBedSpawnLocation(Location location, boolean override) {
+		if (location == null) {
+			getHandle().setRespawnPosition(null, override);
+		} else {
+			getHandle().setRespawnPosition(
+					new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ()), override);
+			getHandle().spawnWorld = location.getWorld().getName();
+		}
+	}
+
+	@Override
+	public void hidePlayer(Player player) {
+		this.hidePlayer(player, true);
+	}
+
+	public void hidePlayer(Player player, boolean sendDestroy) {
+		Validate.notNull(player, "hidden player cannot be null");
+
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		if (equals(player)) {
+			return;
+		}
+
+		if (hiddenPlayers.contains(player.getUniqueId())) {
+			return;
+		}
+
+		hiddenPlayers.add(player.getUniqueId());
+
+		// remove this player from the hidden player's EntityTrackerEntry
+		EntityTracker tracker = ((WorldServer) entity.world).tracker;
+		EntityPlayer other = ((CraftPlayer) player).getHandle();
+		EntityTrackerEntry entry = tracker.trackedEntities.get(other.getId());
+
+		if (entry != null) {
+			entry.clear(getHandle(), sendDestroy);
+		}
+
+//		getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, other));
+//
+//		if (!SpigotX.INSTANCE.getConfig().isHidePlayersFromTab()) {
+//			getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, other));
+//		}
+
+		if (PotionSpigot.INSTANCE.getConfig().isHidePlayersFromTab()) {
+			getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, other));
+		}
+	}
+
+	@Override
+	public void showPlayer(Player player) {
+		Validate.notNull(player, "shown player cannot be null");
+
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		if (equals(player)) {
+			return;
+		}
+
+		if (!hiddenPlayers.contains(player.getUniqueId())) {
+			return;
+		}
+
+		hiddenPlayers.remove(player.getUniqueId());
+
+		EntityTracker tracker = ((WorldServer) entity.world).tracker;
+		EntityPlayer other = ((CraftPlayer) player).getHandle();
+
+		getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, other));
+
+		EntityTrackerEntry entry = tracker.trackedEntities.get(other.getId());
+
+		if (entry != null && !entry.trackedPlayers.contains(getHandle())) {
+			entry.updatePlayer(getHandle());
+		}
+	}
+
+    /*
     public void removeDisconnectingPlayer(Player player) {
         hiddenPlayers.remove(player.getUniqueId());
     }
+    */
 
-    @Override
-    public boolean canSee(Player player) {
-        return !hiddenPlayers.contains(player.getUniqueId());
-    }
-
-    @Override
-    public Map<String, Object> serialize() {
-        Map<String, Object> result = new LinkedHashMap<String, Object>();
-
-        result.put("name", getName());
-
-        return result;
-    }
-
-    @Override
-    public Player getPlayer() {
-        return this;
-    }
-
-    @Override
-    public EntityPlayer getHandle() {
-        return (EntityPlayer) entity;
-    }
-
-    public void setHandle(final EntityPlayer entity) {
-        super.setHandle(entity);
-    }
-
-    @Override
-    public String toString() {
-        return "CraftPlayer{" + "name=" + getName() + '}';
-    }
-
-    @Override
-    public int hashCode() {
-        if (hash == 0 || hash == 485) {
-            hash = 97 * 5 + (this.getUniqueId() != null ? this.getUniqueId().hashCode() : 0);
-        }
-        return hash;
-    }
-
-    @Override
-    public long getFirstPlayed() {
-        return firstPlayed;
-    }
-
-    @Override
-    public long getLastPlayed() {
-        return lastPlayed;
-    }
-
-    @Override
-    public boolean hasPlayedBefore() {
-        return hasPlayedBefore;
-    }
-
-    public void setFirstPlayed(long firstPlayed) {
-        this.firstPlayed = firstPlayed;
-    }
-
-    public void readExtraData(NBTTagCompound nbttagcompound) {
-        hasPlayedBefore = true;
-        if (nbttagcompound.hasKey("bukkit")) {
-            NBTTagCompound data = nbttagcompound.getCompound("bukkit");
-
-            if (data.hasKey("firstPlayed")) {
-                firstPlayed = data.getLong("firstPlayed");
-                lastPlayed = data.getLong("lastPlayed");
-            }
-
-            if (data.hasKey("newExp")) {
-                EntityPlayer handle = getHandle();
-                handle.newExp = data.getInt("newExp");
-                handle.newTotalExp = data.getInt("newTotalExp");
-                handle.newLevel = data.getInt("newLevel");
-                handle.expToDrop = data.getInt("expToDrop");
-                handle.keepLevel = data.getBoolean("keepLevel");
-            }
-        }
-    }
-
-    public void setExtraData(NBTTagCompound nbttagcompound) {
-        if (!nbttagcompound.hasKey("bukkit")) {
-            nbttagcompound.set("bukkit", new NBTTagCompound());
-        }
-
-        NBTTagCompound data = nbttagcompound.getCompound("bukkit");
-        EntityPlayer handle = getHandle();
-        data.setInt("newExp", handle.newExp);
-        data.setInt("newTotalExp", handle.newTotalExp);
-        data.setInt("newLevel", handle.newLevel);
-        data.setInt("expToDrop", handle.expToDrop);
-        data.setBoolean("keepLevel", handle.keepLevel);
-        data.setLong("firstPlayed", getFirstPlayed());
-        data.setLong("lastPlayed", System.currentTimeMillis());
-        data.setString("lastKnownName", handle.getName());
-    }
-
-    @Override
-    public boolean beginConversation(Conversation conversation) {
-        return conversationTracker.beginConversation(conversation);
-    }
-
-    @Override
-    public void abandonConversation(Conversation conversation) {
-        conversationTracker.abandonConversation(conversation, new ConversationAbandonedEvent(conversation, new ManuallyAbandonedConversationCanceller()));
-    }
-
-    @Override
-    public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details) {
-        conversationTracker.abandonConversation(conversation, details);
-    }
-
-    @Override
-    public void acceptConversationInput(String input) {
-        conversationTracker.acceptConversationInput(input);
-    }
-
-    @Override
-    public boolean isConversing() {
-        return conversationTracker.isConversing();
-    }
-
-    @Override
-    public void sendPluginMessage(Plugin source, String channel, byte[] message) {
-        StandardMessenger.validatePluginMessage(server.getMessenger(), source, channel, message);
-        if (getHandle().playerConnection == null) return;
-
-        if (channels.contains(channel)) {
-            PacketPlayOutCustomPayload packet = new PacketPlayOutCustomPayload(channel, new PacketDataSerializer(Unpooled.wrappedBuffer(message)));
-            getHandle().playerConnection.sendPacket(packet);
-        }
-    }
-
-    @Override
-    public void setTexturePack(String url) {
-        setResourcePack(url);
-    }
-
-    @Override
-    public void setResourcePack(String url) {
-        Validate.notNull(url, "Resource pack URL cannot be null");
-
-        getHandle().setResourcePack(url, "null");
-    }
-
-    public void addChannel(String channel) {
-       com.google.common.base.Preconditions.checkState( channels.size() < 128, "Too many channels registered" ); // Spigot
-        if (channels.add(channel)) {
-            server.getPluginManager().callEvent(new PlayerRegisterChannelEvent(this, channel));
-        }
-    }
-
-    public void removeChannel(String channel) {
-        if (channels.remove(channel)) {
-            server.getPluginManager().callEvent(new PlayerUnregisterChannelEvent(this, channel));
-        }
-    }
-
-    @Override
-    public Set<String> getListeningPluginChannels() {
-        return ImmutableSet.copyOf(channels);
-    }
-
-    public void sendSupportedChannels() {
-        if (getHandle().playerConnection == null) return;
-        Set<String> listening = server.getMessenger().getIncomingChannels();
-
-        if (!listening.isEmpty()) {
-            ByteArrayOutputStream stream = new ByteArrayOutputStream();
-
-            for (String channel : listening) {
-                try {
-                    stream.write(channel.getBytes("UTF8"));
-                    stream.write((byte) 0);
-                } catch (IOException ex) {
-                    Logger.getLogger(CraftPlayer.class.getName()).log(Level.SEVERE, "Could not send Plugin Channel REGISTER to " + getName(), ex);
-                }
-            }
-
-            getHandle().playerConnection.sendPacket(new PacketPlayOutCustomPayload("REGISTER", new PacketDataSerializer(Unpooled.wrappedBuffer(stream.toByteArray()))));
-        }
-    }
-
-    @Override
-    public EntityType getType() {
-        return EntityType.PLAYER;
-    }
-
-    @Override
-    public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
-        server.getPlayerMetadata().setMetadata(this, metadataKey, newMetadataValue);
-    }
-
-    @Override
-    public List<MetadataValue> getMetadata(String metadataKey) {
-        return server.getPlayerMetadata().getMetadata(this, metadataKey);
-    }
-
-    @Override
-    public boolean hasMetadata(String metadataKey) {
-        return server.getPlayerMetadata().hasMetadata(this, metadataKey);
-    }
-
-    @Override
-    public void removeMetadata(String metadataKey, Plugin owningPlugin) {
-        server.getPlayerMetadata().removeMetadata(this, metadataKey, owningPlugin);
-    }
-
-    @Override
-    public boolean setWindowProperty(Property prop, int value) {
-        Container container = getHandle().activeContainer;
-        if (container.getBukkitView().getType() != prop.getType()) {
-            return false;
-        }
-        getHandle().setContainerData(container, prop.getId(), value);
-        return true;
-    }
-
-    public void disconnect(String reason) {
-        conversationTracker.abandonAllConversations();
-        perm.clearPermissions();
-    }
-
-    @Override
-    public boolean isFlying() {
-        return getHandle().abilities.isFlying;
-    }
-
-    @Override
-    public void setFlying(boolean value) {
-        boolean needsUpdate = getHandle().abilities.canFly != value; // PaperSpigot - Only refresh abilities if needed
-        if (!getAllowFlight() && value) {
-            throw new IllegalArgumentException("Cannot make player fly if getAllowFlight() is false");
-        }
-
-        getHandle().abilities.isFlying = value;
-        if (needsUpdate) getHandle().updateAbilities(); // PaperSpigot - Only refresh abilities if needed
-    }
-
-    @Override
-    public boolean getAllowFlight() {
-        return getHandle().abilities.canFly;
-    }
-
-    @Override
-    public void setAllowFlight(boolean value) {
-        if (isFlying() && !value) {
-            getHandle().abilities.isFlying = false;
-        }
-
-        getHandle().abilities.canFly = value;
-        getHandle().updateAbilities();
-    }
-
-    @Override
-    public int getNoDamageTicks() {
-        if (getHandle().invulnerableTicks > 0) {
-            return Math.max(getHandle().invulnerableTicks, getHandle().noDamageTicks);
-        } else {
-            return getHandle().noDamageTicks;
-        }
-    }
-
-    @Override
-    public void setFlySpeed(float value) {
-        validateSpeed(value);
-        EntityPlayer player = getHandle();
-        player.abilities.flySpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
-        player.updateAbilities();
-
-    }
-
-    @Override
-    public void setWalkSpeed(float value) {
-        validateSpeed(value);
-        EntityPlayer player = getHandle();
-        player.abilities.walkSpeed = Math.max( value, 0.0001f ) / 2f; // Spigot
-        player.updateAbilities();
-    }
-
-    @Override
-    public float getFlySpeed() {
-        return getHandle().abilities.flySpeed * 2f;
-    }
-
-    @Override
-    public float getWalkSpeed() {
-        return getHandle().abilities.walkSpeed * 2f;
-    }
-
-    private void validateSpeed(float value) {
-        if (value < 0) {
-            if (value < -1f) {
-                throw new IllegalArgumentException(value + " is too low");
-            }
-        } else {
-            if (value > 1f) {
-                throw new IllegalArgumentException(value + " is too high");
-            }
-        }
-    }
-
-    @Override
-    public void setMaxHealth(double amount) {
-        super.setMaxHealth(amount);
-        this.health = Math.min(this.health, health);
-        getHandle().triggerHealthUpdate();
-    }
-
-    @Override
-    public void resetMaxHealth() {
-        super.resetMaxHealth();
-        getHandle().triggerHealthUpdate();
-    }
-
-    @Override
-    public CraftScoreboard getScoreboard() {
-        return this.server.getScoreboardManager().getPlayerBoard(this);
-    }
-
-    @Override
-    public void setScoreboard(Scoreboard scoreboard) {
-        Validate.notNull(scoreboard, "Scoreboard cannot be null");
-        PlayerConnection playerConnection = getHandle().playerConnection;
-        if (playerConnection == null) {
-            throw new IllegalStateException("Cannot set scoreboard yet");
-        }
-        if (playerConnection.isDisconnected()) {
-            // throw new IllegalStateException("Cannot set scoreboard for invalid CraftPlayer"); // Spigot - remove this as Mojang's semi asynchronous Netty implementation can lead to races
-        }
-
-        this.server.getScoreboardManager().setPlayerBoard(this, scoreboard);
-    }
-
-    @Override
-    public void setHealthScale(double value) {
-        Validate.isTrue((float) value > 0F, "Must be greater than 0");
-        healthScale = value;
-        scaledHealth = true;
-        updateScaledHealth();
-    }
-
-    @Override
-    public double getHealthScale() {
-        return healthScale;
-    }
-
-    @Override
-    public void setHealthScaled(boolean scale) {
-        if (scaledHealth != (scaledHealth = scale)) {
-            updateScaledHealth();
-        }
-    }
-
-    @Override
-    public boolean isHealthScaled() {
-        return scaledHealth;
-    }
-
-    public float getScaledHealth() {
-        return (float) (isHealthScaled() ? getHealth() * getHealthScale() / getMaxHealth() : getHealth());
-    }
-
-    @Override
-    public double getHealth() {
-        return health;
-    }
-
-    public void setRealHealth(double health) {
-        this.health = health;
-    }
-
-    public void updateScaledHealth() {
-        AttributeMapServer attributemapserver = (AttributeMapServer) getHandle().getAttributeMap();
-        Set set = attributemapserver.getAttributes();
-
-        injectScaledMaxHealth(set, true);
-
-        getHandle().getDataWatcher().watch(6, (float) getScaledHealth());
-        getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateHealth(getScaledHealth(), getHandle().getFoodData().getFoodLevel(), getHandle().getFoodData().getSaturationLevel()));
-        getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateAttributes(getHandle().getId(), set));
-
-        set.clear();
-        getHandle().maxHealthCache = getMaxHealth();
-    }
-
-    public void injectScaledMaxHealth(Collection collection, boolean force) {
-        if (!scaledHealth && !force) {
-            return;
-        }
-        for (Object genericInstance : collection) {
-            IAttribute attribute = ((AttributeInstance) genericInstance).getAttribute();
-            if (attribute.getName().equals("generic.maxHealth")) {
-                collection.remove(genericInstance);
-                break;
-            }
-        }
-        // Spigot start
-        double healthMod = scaledHealth ? healthScale : getMaxHealth();
-        if ( healthMod >= Float.MAX_VALUE || healthMod <= 0 )
-        {
-            healthMod = 20; // Reset health
-            getServer().getLogger().warning( getName() + " tried to crash the server with a large health attribute" );
-        }
-        collection.add(new AttributeModifiable(getHandle().getAttributeMap(), (new AttributeRanged(null, "generic.maxHealth", healthMod, 0.0D, Float.MAX_VALUE)).a("Max Health").a(true)));
-        // Spigot end
-    }
-
-    @Override
-    public org.bukkit.entity.Entity getSpectatorTarget() {
-        Entity followed = getHandle().C(); // PAIL
-        return followed == getHandle() ? null : followed.getBukkitEntity();
-    }
-
-    @Override
-    public void setSpectatorTarget(org.bukkit.entity.Entity entity) {
-        Preconditions.checkArgument(getGameMode() == GameMode.SPECTATOR, "Player must be in spectator mode");
-        getHandle().setSpectatorTarget((entity == null) ? null : ((CraftEntity) entity).getHandle());
-    }
-
-    @Override
-    public void sendTitle(String title, String subtitle) {
-        if (title != null) {
-            PacketPlayOutTitle packetTitle = new PacketPlayOutTitle(EnumTitleAction.TITLE, CraftChatMessage.fromString(title)[0]);
-            getHandle().playerConnection.sendPacket(packetTitle);
-        }
-
-        if (subtitle != null) {
-            PacketPlayOutTitle packetSubtitle = new PacketPlayOutTitle(EnumTitleAction.SUBTITLE, CraftChatMessage.fromString(subtitle)[0]);
-            getHandle().playerConnection.sendPacket(packetSubtitle);
-        }
-    }
-
-    @Override
-    public void resetTitle() {
-        PacketPlayOutTitle packetReset = new PacketPlayOutTitle(EnumTitleAction.RESET, null);
-        getHandle().playerConnection.sendPacket(packetReset);
-    }
-
-    // Spigot start
-    private final Player.Spigot spigot = new Player.Spigot()
-    {
-
-        @Override
-        public InetSocketAddress getRawAddress()
-        {
-            return (InetSocketAddress) getHandle().playerConnection.networkManager.getRawAddress();
-        }
-
-        @Override
-        public boolean getCollidesWithEntities()
-        {
-            return getHandle().collidesWithEntities;
-        }
-
-        @Override
-        public void setCollidesWithEntities(boolean collides)
-        {
-            getHandle().collidesWithEntities = collides;
-            getHandle().k = collides; // First boolean of Entity
-        }
-
-        @Override
-        public void respawn()
-        {
-            if ( getHealth() <= 0 && isOnline() )
-            {
-                server.getServer().getPlayerList().moveToWorld( getHandle(), 0, false );
-            }
-        }
-
-        @Override
-        public void playEffect( Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius )
-        {
-            Validate.notNull( location, "Location cannot be null" );
-            Validate.notNull( effect, "Effect cannot be null" );
-            Validate.notNull( location.getWorld(), "World cannot be null" );
-            Packet packet;
-            if ( effect.getType() != Effect.Type.PARTICLE )
-            {
-                int packetData = effect.getId();
-                packet = new PacketPlayOutWorldEvent( packetData, new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ() ), id, false );
-            } else
-            {
-                net.minecraft.server.EnumParticle particle = null;
-                int[] extra = null;
-                for ( net.minecraft.server.EnumParticle p : net.minecraft.server.EnumParticle.values() )
-                {
-                    if ( effect.getName().startsWith( p.b().replace("_", "") ) )
-                    {
-                        particle = p;
-                        if ( effect.getData() != null ) 
-                        {
-                            if ( effect.getData().equals( org.bukkit.Material.class ) )
-                            {
-                                extra = new int[]{ id };
-                            } else 
-                            {
-                                extra = new int[]{ (data << 12) | (id & 0xFFF) };
-                            }
-                        }
-                        break;
-                    }
-                }
-                if ( extra == null )
-                {
-                    extra = new int[0];
-                }
-                packet = new PacketPlayOutWorldParticles( particle, true, (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount, extra );
-            }
-            int distance;
-            radius *= radius;
-            if ( getHandle().playerConnection == null )
-            {
-                return;
-            }
-            if ( !location.getWorld().equals( getWorld() ) )
-            {
-                return;
-            }
-
-            distance = (int) getLocation().distanceSquared( location );
-            if ( distance <= radius )
-            {
-                getHandle().playerConnection.sendPacket( packet );
-            }
-        }
-
-        @Override
-        public String getLocale()
-        {
-           return getHandle().locale;
-        }
-
-        @Override
-        public Set<Player> getHiddenPlayers()
-        {
-            Set<Player> ret = new HashSet<Player>();
-            for ( UUID u : hiddenPlayers )
-            {
-                ret.add( getServer().getPlayer( u ) );
-            }
-
-            return java.util.Collections.unmodifiableSet( ret );
-        }
-
-        @Override
-        public void sendMessage(BaseComponent component) {
-          sendMessage( new BaseComponent[] { component } );
-        }
-
-        @Override
-        public void sendMessage(BaseComponent... components) {
-           if ( getHandle().playerConnection == null ) return;
-
-            PacketPlayOutChat packet = new PacketPlayOutChat();
-            packet.components = components;
-            getHandle().playerConnection.sendPacket(packet);
-        }
-
-        // PaperSpigot start - Implement affects spawning API
-        @Override
-        public boolean getAffectsSpawning() {
-            return getHandle().affectsSpawning;
-        }
-
-        @Override
-        public void setAffectsSpawning(boolean affects) {
-            getHandle().affectsSpawning = affects;
-        }
-        // PaperSpigot end
-
-        // PaperSpigot start - Player view distance API
-        @Override
-        public int getViewDistance() {
-            return getHandle().viewDistance;
-        }
-
-        @Override
-        public void setViewDistance(int viewDistance) {
-            ((WorldServer) getHandle().world).getPlayerChunkMap().updateViewDistance(getHandle(), viewDistance);
-        }
-        // PaperSpigot end
-
-        @Override
-        public int getPing()
-        {
-            return getHandle().ping;
-        }
-    };
-
-    public Player.Spigot spigot()
-    {
-        return spigot;
-    }
-    // Spigot end
+	@Override
+	public boolean canSee(Player player) {
+		return !hiddenPlayers.contains(player.getUniqueId());
+	}
+
+	public boolean canSeeEntity(org.bukkit.entity.Entity entity) {
+		Entity nmsEntity = ((CraftEntity) entity).getHandle();
+
+		if (nmsEntity instanceof EntityProjectile) {
+			EntityProjectile entityProjectile = (EntityProjectile) nmsEntity;
+
+			if (entityProjectile.getShooter() instanceof EntityPlayer) {
+				return this.canSee(((EntityPlayer) entityProjectile.getShooter()).getBukkitEntity());
+			}
+		}
+
+		if (nmsEntity instanceof EntityItem) {
+			EntityItem entityItem = (EntityItem) nmsEntity;
+
+			if (entityItem.owner instanceof EntityPlayer) {
+				return this.canSee(((EntityPlayer) entityItem.owner).getBukkitEntity());
+			}
+		}
+
+		if (nmsEntity instanceof EntityArrow) {
+			EntityArrow entityProjectile = (EntityArrow) nmsEntity;
+
+			if (entityProjectile.shooter instanceof EntityPlayer) {
+				return this.canSee(((EntityPlayer) entityProjectile.shooter).getBukkitEntity());
+			}
+		}
+
+		return !(entity instanceof Player) || this.canSee((Player) entity);
+	}
+
+	@Override
+	public Map<String, Object> serialize() {
+		Map<String, Object> result = new LinkedHashMap<String, Object>();
+
+		result.put("name", getName());
+
+		return result;
+	}
+
+	@Override
+	public Player getPlayer() {
+		return this;
+	}
+
+	@Override
+	public EntityPlayer getHandle() {
+		return (EntityPlayer) entity;
+	}
+
+	public void setHandle(final EntityPlayer entity) {
+		super.setHandle(entity);
+	}
+
+	@Override
+	public String toString() {
+		return "CraftPlayer{" + "name=" + getName() + '}';
+	}
+
+	@Override
+	public int hashCode() {
+		if (hash == 0 || hash == 485) {
+			hash = 97 * 5 + (this.getUniqueId() != null ? this.getUniqueId().hashCode() : 0);
+		}
+		return hash;
+	}
+
+	@Override
+	public long getFirstPlayed() {
+		return firstPlayed;
+	}
+
+	@Override
+	public long getLastPlayed() {
+		return lastPlayed;
+	}
+
+	@Override
+	public boolean hasPlayedBefore() {
+		return hasPlayedBefore;
+	}
+
+	public void setFirstPlayed(long firstPlayed) {
+		this.firstPlayed = firstPlayed;
+	}
+
+	public void readExtraData(NBTTagCompound nbttagcompound) {
+		hasPlayedBefore = true;
+		if (nbttagcompound.hasKey("bukkit")) {
+			NBTTagCompound data = nbttagcompound.getCompound("bukkit");
+
+			if (data.hasKey("firstPlayed")) {
+				firstPlayed = data.getLong("firstPlayed");
+				lastPlayed = data.getLong("lastPlayed");
+			}
+
+			if (data.hasKey("newExp")) {
+				EntityPlayer handle = getHandle();
+				handle.newExp = data.getInt("newExp");
+				handle.newTotalExp = data.getInt("newTotalExp");
+				handle.newLevel = data.getInt("newLevel");
+				handle.expToDrop = data.getInt("expToDrop");
+				handle.keepLevel = data.getBoolean("keepLevel");
+			}
+		}
+	}
+
+	public void setExtraData(NBTTagCompound nbttagcompound) {
+		if (!nbttagcompound.hasKey("bukkit")) {
+			nbttagcompound.set("bukkit", new NBTTagCompound());
+		}
+
+		NBTTagCompound data = nbttagcompound.getCompound("bukkit");
+		EntityPlayer handle = getHandle();
+		data.setInt("newExp", handle.newExp);
+		data.setInt("newTotalExp", handle.newTotalExp);
+		data.setInt("newLevel", handle.newLevel);
+		data.setInt("expToDrop", handle.expToDrop);
+		data.setBoolean("keepLevel", handle.keepLevel);
+		data.setLong("firstPlayed", getFirstPlayed());
+		data.setLong("lastPlayed", System.currentTimeMillis());
+		data.setString("lastKnownName", handle.getName());
+	}
+
+	@Override
+	public boolean beginConversation(Conversation conversation) {
+		return conversationTracker.beginConversation(conversation);
+	}
+
+	@Override
+	public void abandonConversation(Conversation conversation) {
+		conversationTracker.abandonConversation(conversation,
+				new ConversationAbandonedEvent(conversation, new ManuallyAbandonedConversationCanceller()));
+	}
+
+	@Override
+	public void abandonConversation(Conversation conversation, ConversationAbandonedEvent details) {
+		conversationTracker.abandonConversation(conversation, details);
+	}
+
+	@Override
+	public void acceptConversationInput(String input) {
+		conversationTracker.acceptConversationInput(input);
+	}
+
+	@Override
+	public boolean isConversing() {
+		return conversationTracker.isConversing();
+	}
+
+	@Override
+	public void sendPluginMessage(Plugin source, String channel, byte[] message) {
+		StandardMessenger.validatePluginMessage(server.getMessenger(), source, channel, message);
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+
+		if (channels.contains(channel)) {
+			PacketPlayOutCustomPayload packet = new PacketPlayOutCustomPayload(channel,
+					new PacketDataSerializer(Unpooled.wrappedBuffer(message)));
+			getHandle().playerConnection.sendPacket(packet);
+		}
+	}
+
+	@Override
+	public void setTexturePack(String url) {
+		setResourcePack(url);
+	}
+
+	@Override
+	public void setResourcePack(String url) {
+		Validate.notNull(url, "Resource pack URL cannot be null");
+
+		getHandle().setResourcePack(url, "null");
+	}
+
+	public void addChannel(String channel) {
+		com.google.common.base.Preconditions
+				.checkState(channels.size() < 128, "Too many channels registered"); // Spigot
+		if (channels.add(channel)) {
+			server.getPluginManager().callEvent(new PlayerRegisterChannelEvent(this, channel));
+		}
+	}
+
+	public void removeChannel(String channel) {
+		if (channels.remove(channel)) {
+			server.getPluginManager().callEvent(new PlayerUnregisterChannelEvent(this, channel));
+		}
+	}
+
+	@Override
+	public Set<String> getListeningPluginChannels() {
+		return ImmutableSet.copyOf(channels);
+	}
+
+	public void sendSupportedChannels() {
+		if (getHandle().playerConnection == null) {
+			return;
+		}
+		Set<String> listening = server.getMessenger().getIncomingChannels();
+
+		if (!listening.isEmpty()) {
+			ByteArrayOutputStream stream = new ByteArrayOutputStream();
+
+			for (String channel : listening) {
+				try {
+					stream.write(channel.getBytes("UTF8"));
+					stream.write((byte) 0);
+				} catch (IOException ex) {
+					Logger.getLogger(CraftPlayer.class.getName())
+							.log(Level.SEVERE, "Could not send Plugin Channel REGISTER to " + getName(), ex);
+				}
+			}
+
+			getHandle().playerConnection.sendPacket(new PacketPlayOutCustomPayload("REGISTER",
+					new PacketDataSerializer(Unpooled.wrappedBuffer(stream.toByteArray()))));
+		}
+	}
+
+	@Override
+	public EntityType getType() {
+		return EntityType.PLAYER;
+	}
+
+	@Override
+	public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
+		server.getPlayerMetadata().setMetadata(this, metadataKey, newMetadataValue);
+	}
+
+	@Override
+	public List<MetadataValue> getMetadata(String metadataKey) {
+		return server.getPlayerMetadata().getMetadata(this, metadataKey);
+	}
+
+	@Override
+	public boolean hasMetadata(String metadataKey) {
+		return server.getPlayerMetadata().hasMetadata(this, metadataKey);
+	}
+
+	@Override
+	public void removeMetadata(String metadataKey, Plugin owningPlugin) {
+		server.getPlayerMetadata().removeMetadata(this, metadataKey, owningPlugin);
+	}
+
+	@Override
+	public boolean setWindowProperty(Property prop, int value) {
+		Container container = getHandle().activeContainer;
+		if (container.getBukkitView().getType() != prop.getType()) {
+			return false;
+		}
+		getHandle().setContainerData(container, prop.getId(), value);
+		return true;
+	}
+
+	public void disconnect(String reason) {
+		conversationTracker.abandonAllConversations();
+		perm.clearPermissions();
+	}
+
+	@Override
+	public boolean isFlying() {
+		return getHandle().abilities.isFlying;
+	}
+
+	@Override
+	public void setFlying(boolean value) {
+		boolean needsUpdate = getHandle().abilities.canFly != value; // PaperSpigot - Only refresh abilities if needed
+		if (!getAllowFlight() && value) {
+			throw new IllegalArgumentException("Cannot make player fly if getAllowFlight() is false");
+		}
+
+		getHandle().abilities.isFlying = value;
+		if (needsUpdate) {
+			getHandle().updateAbilities(); // PaperSpigot - Only refresh abilities if needed
+		}
+	}
+
+	@Override
+	public boolean getAllowFlight() {
+		return getHandle().abilities.canFly;
+	}
+
+	@Override
+	public void setAllowFlight(boolean value) {
+		if (isFlying() && !value) {
+			getHandle().abilities.isFlying = false;
+		}
+
+		getHandle().abilities.canFly = value;
+		getHandle().updateAbilities();
+	}
+
+	@Override
+	public int getNoDamageTicks() {
+		if (getHandle().invulnerableTicks > 0) {
+			return Math.max(getHandle().invulnerableTicks, getHandle().noDamageTicks);
+		} else {
+			return getHandle().noDamageTicks;
+		}
+	}
+
+	@Override
+	public void setFlySpeed(float value) {
+		validateSpeed(value);
+		EntityPlayer player = getHandle();
+		player.abilities.flySpeed = Math.max(value, 0.0001f) / 2f; // Spigot
+		player.updateAbilities();
+
+	}
+
+	@Override
+	public void setWalkSpeed(float value) {
+		validateSpeed(value);
+		EntityPlayer player = getHandle();
+		player.abilities.walkSpeed = Math.max(value, 0.0001f) / 2f; // Spigot
+		player.updateAbilities();
+	}
+
+	@Override
+	public float getFlySpeed() {
+		return getHandle().abilities.flySpeed * 2f;
+	}
+
+	@Override
+	public float getWalkSpeed() {
+		return getHandle().abilities.walkSpeed * 2f;
+	}
+
+	private void validateSpeed(float value) {
+		if (value < 0) {
+			if (value < -1f) {
+				throw new IllegalArgumentException(value + " is too low");
+			}
+		} else {
+			if (value > 1f) {
+				throw new IllegalArgumentException(value + " is too high");
+			}
+		}
+	}
+
+	@Override
+	public void setMaxHealth(double amount) {
+		super.setMaxHealth(amount);
+		this.health = Math.min(this.health, health);
+		getHandle().triggerHealthUpdate();
+	}
+
+	@Override
+	public void resetMaxHealth() {
+		super.resetMaxHealth();
+		getHandle().triggerHealthUpdate();
+	}
+
+	@Override
+	public CraftScoreboard getScoreboard() {
+		return this.server.getScoreboardManager().getPlayerBoard(this);
+	}
+
+	@Override
+	public void setScoreboard(Scoreboard scoreboard) {
+		Validate.notNull(scoreboard, "Scoreboard cannot be null");
+		PlayerConnection playerConnection = getHandle().playerConnection;
+		if (playerConnection == null) {
+			throw new IllegalStateException("Cannot set scoreboard yet");
+		}
+		if (playerConnection.isDisconnected()) {
+			// throw new IllegalStateException("Cannot set scoreboard for invalid CraftPlayer"); // Spigot - remove
+			// this as Mojang's semi asynchronous Netty implementation can lead to races
+		}
+
+		this.server.getScoreboardManager().setPlayerBoard(this, scoreboard);
+	}
+
+	@Override
+	public void setHealthScale(double value) {
+		Validate.isTrue((float) value > 0F, "Must be greater than 0");
+		healthScale = value;
+		scaledHealth = true;
+		updateScaledHealth();
+	}
+
+	@Override
+	public double getHealthScale() {
+		return healthScale;
+	}
+
+	@Override
+	public void setHealthScaled(boolean scale) {
+		if (scaledHealth != (scaledHealth = scale)) {
+			updateScaledHealth();
+		}
+	}
+
+	@Override
+	public boolean isHealthScaled() {
+		return scaledHealth;
+	}
+
+	public float getScaledHealth() {
+		return (float) (isHealthScaled() ? getHealth() * getHealthScale() / getMaxHealth() : getHealth());
+	}
+
+	@Override
+	public double getHealth() {
+		return health;
+	}
+
+	public void setRealHealth(double health) {
+		this.health = health;
+	}
+
+	public void updateScaledHealth() {
+		AttributeMapServer attributemapserver = (AttributeMapServer) getHandle().getAttributeMap();
+		Set set = attributemapserver.getAttributes();
+
+		injectScaledMaxHealth(set, true);
+
+		getHandle().getDataWatcher().watch(6, getScaledHealth());
+		getHandle().playerConnection.sendPacket(
+				new PacketPlayOutUpdateHealth(getScaledHealth(), getHandle().getFoodData().getFoodLevel(),
+						getHandle().getFoodData().getSaturationLevel()));
+		getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateAttributes(getHandle().getId(), set));
+
+		set.clear();
+		getHandle().maxHealthCache = getMaxHealth();
+	}
+
+	public void injectScaledMaxHealth(Collection collection, boolean force) {
+		if (!scaledHealth && !force) {
+			return;
+		}
+		for (Object genericInstance : collection) {
+			IAttribute attribute = ((AttributeInstance) genericInstance).getAttribute();
+			if (attribute.getName().equals("generic.maxHealth")) {
+				collection.remove(genericInstance);
+				break;
+			}
+		}
+		// Spigot start
+		double healthMod = scaledHealth ? healthScale : getMaxHealth();
+		if (healthMod >= Float.MAX_VALUE || healthMod <= 0) {
+			healthMod = 20; // Reset health
+			getServer().getLogger().warning(getName() + " tried to crash the server with a large health attribute");
+		}
+		collection.add(new AttributeModifiable(getHandle().getAttributeMap(),
+				(new AttributeRanged(null, "generic.maxHealth", healthMod, 0.0D, Float.MAX_VALUE)).a("Max Health")
+						.a(true)));
+		// Spigot end
+	}
+
+	@Override
+	public org.bukkit.entity.Entity getSpectatorTarget() {
+		Entity followed = getHandle().C(); // PAIL
+		return followed == getHandle() ? null : followed.getBukkitEntity();
+	}
+
+	@Override
+	public void setSpectatorTarget(org.bukkit.entity.Entity entity) {
+		Preconditions.checkArgument(getGameMode() == GameMode.SPECTATOR, "Player must be in spectator mode");
+		getHandle().setSpectatorTarget((entity == null) ? null : ((CraftEntity) entity).getHandle());
+	}
+
+	@Override
+	public void sendTitle(String title, String subtitle) {
+		if (title != null) {
+			PacketPlayOutTitle packetTitle = new PacketPlayOutTitle(EnumTitleAction.TITLE,
+					CraftChatMessage.fromString(title)[0]);
+			getHandle().playerConnection.sendPacket(packetTitle);
+		}
+
+		if (subtitle != null) {
+			PacketPlayOutTitle packetSubtitle = new PacketPlayOutTitle(EnumTitleAction.SUBTITLE,
+					CraftChatMessage.fromString(subtitle)[0]);
+			getHandle().playerConnection.sendPacket(packetSubtitle);
+		}
+	}
+
+	@Override
+	public void resetTitle() {
+		PacketPlayOutTitle packetReset = new PacketPlayOutTitle(EnumTitleAction.RESET, null);
+		getHandle().playerConnection.sendPacket(packetReset);
+	}
+
+	// Kohi start
+	@Override
+	public void setVelocity(Vector vel) {
+		// To be consistent with old behavior, set the velocity before firing the event
+		this.setVelocityDirect(vel);
+
+		PlayerVelocityEvent event = new PlayerVelocityEvent(this, vel.clone());
+
+		this.getServer().getPluginManager().callEvent(event);
+
+		if (!event.isCancelled()) {
+			// Set the velocity again in case it was changed by event handlers
+			this.setVelocityDirect(event.getVelocity());
+
+			// Send the new velocity to the player's client immediately, so it isn't affected by
+			// any movement packets from this player that may be processed before the end of the tick.
+			// Without this, player velocity changes tend to be very inconsistent.
+
+			this.getHandle().playerConnection.sendPacket(new PacketPlayOutEntityVelocity(this.getHandle()));
+		}
+
+		// Note that cancelling the event does not restore the old velocity, it only prevents
+		// the packet from sending. Again, this is to be consistent with old behavior.
+	}
+
+	public void setVelocityDirect(Vector vel) {
+		entity.motX = vel.getX();
+		entity.motY = vel.getY();
+		entity.motZ = vel.getZ();
+
+		if (entity.motY > 0) {
+			entity.fallDistance = 0.0f;
+		}
+	}
+	// Kohi end
+
+	// Spigot start
+	private final Player.Spigot spigot = new Player.Spigot() {
+
+		@Override
+		public InetSocketAddress getRawAddress() {
+			return (InetSocketAddress) getHandle().playerConnection.networkManager.getRawAddress();
+		}
+
+		@Override
+		public boolean getCollidesWithEntities() {
+			return getHandle().collidesWithEntities;
+		}
+
+		@Override
+		public void setCollidesWithEntities(boolean collides) {
+			getHandle().collidesWithEntities = collides;
+			getHandle().k = collides; // First boolean of Entity
+		}
+
+		@Override
+		public void respawn() {
+			if (getHealth() <= 0 && isOnline()) {
+				server.getServer().getPlayerList().moveToWorld(getHandle(), 0, false);
+			}
+		}
+
+		@Override
+		public void playEffect(Location location, Effect effect, int id, int data, float offsetX, float offsetY,
+		                       float offsetZ, float speed, int particleCount, int radius) {
+			Validate.notNull(location, "Location cannot be null");
+			Validate.notNull(effect, "Effect cannot be null");
+			Validate.notNull(location.getWorld(), "World cannot be null");
+			Packet packet;
+			if (effect.getType() != Effect.Type.PARTICLE) {
+				int packetData = effect.getId();
+				packet = new PacketPlayOutWorldEvent(packetData,
+						new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ()), id,
+						false);
+			} else {
+				net.minecraft.server.EnumParticle particle = null;
+				int[] extra = null;
+				for (net.minecraft.server.EnumParticle p : net.minecraft.server.EnumParticle.values()) {
+					if (effect.getName().startsWith(p.b().replace("_", ""))) {
+						particle = p;
+						if (effect.getData() != null) {
+							if (effect.getData().equals(org.bukkit.Material.class)) {
+								extra = new int[]{id};
+							} else {
+								extra = new int[]{(data << 12) | (id & 0xFFF)};
+							}
+						}
+						break;
+					}
+				}
+				if (extra == null) {
+					extra = new int[0];
+				}
+				packet = new PacketPlayOutWorldParticles(particle, true, (float) location.getX(),
+						(float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed,
+						particleCount, extra);
+			}
+			int distance;
+			radius *= radius;
+			if (getHandle().playerConnection == null) {
+				return;
+			}
+			if (!location.getWorld().equals(getWorld())) {
+				return;
+			}
+
+			distance = (int) getLocation().distanceSquared(location);
+			if (distance <= radius) {
+				getHandle().playerConnection.sendPacket(packet);
+			}
+		}
+
+		@Override
+		public String getLocale() {
+			return getHandle().locale;
+		}
+
+		@Override
+		public Set<Player> getHiddenPlayers() {
+			Set<Player> ret = new HashSet<Player>();
+			for (UUID u : hiddenPlayers) {
+				ret.add(getServer().getPlayer(u));
+			}
+
+			return java.util.Collections.unmodifiableSet(ret);
+		}
+
+		@Override
+		public void sendMessage(BaseComponent component) {
+			sendMessage(new BaseComponent[]{component});
+		}
+
+		@Override
+		public void sendMessage(BaseComponent... components) {
+			if (getHandle().playerConnection == null) {
+				return;
+			}
+
+			PacketPlayOutChat packet = new PacketPlayOutChat();
+			packet.components = components;
+			getHandle().playerConnection.sendPacket(packet);
+		}
+
+		// PaperSpigot start - Implement affects spawning API
+		@Override
+		public boolean getAffectsSpawning() {
+			return getHandle().affectsSpawning;
+		}
+
+		@Override
+		public void setAffectsSpawning(boolean affects) {
+			getHandle().affectsSpawning = affects;
+		}
+		// PaperSpigot end
+
+		// PaperSpigot start - Player view distance API
+		@Override
+		public int getViewDistance() {
+			return getHandle().viewDistance;
+		}
+
+		@Override
+		public void setViewDistance(int viewDistance) {
+			((WorldServer) getHandle().world).getPlayerChunkMap().updateViewDistance(getHandle(), viewDistance);
+		}
+		// PaperSpigot end
+
+		@Override
+		public int getPing() {
+			return getHandle().ping;
+		}
+	};
+
+	public Player.Spigot spigot() {
+		return spigot;
+	}
+	// Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index db915033..7a2ab141 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -192,10 +192,11 @@ public class CraftEventFactory {
     }
 
     public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack) {
-        return callPlayerInteractEvent(who, action, position, direction, itemstack, false);
+        return callPlayerInteractEvent(who, action, position, itemstack, false, direction);
     }
     
-    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack, boolean cancelledBlock) {
+    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, ItemStack itemstack, boolean cancelledBlock, EnumDirection direction) {
+//    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, ItemStack itemstack, boolean cancelledBlock) {
         Player player = (who == null) ? null : (Player) who.getBukkitEntity();
         CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
 
@@ -222,9 +223,11 @@ public class CraftEventFactory {
         }
 
         PlayerInteractEvent event = new PlayerInteractEvent(player, action, itemInHand, blockClicked, blockFace);
+//        PlayerInteractEvent event = new PlayerInteractEvent(player, action, itemInHand, blockClicked);
         if (cancelledBlock) {
             event.setUseInteractedBlock(Event.Result.DENY);
         }
+
         craftServer.getPluginManager().callEvent(event);
 
         return event;
@@ -382,7 +385,7 @@ public class CraftEventFactory {
         for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
             if (stack == null || stack.getType() == Material.AIR || stack.getAmount() == 0) continue;
 
-            world.dropItemNaturally(entity.getLocation(), stack);
+            world.dropItemNaturally(entity.getLocation(), stack, victim);
         }
 
         return event;
@@ -392,7 +395,7 @@ public class CraftEventFactory {
         CraftPlayer entity = victim.getBukkitEntity();
         PlayerDeathEvent event = new PlayerDeathEvent(entity, drops, victim.getExpReward(), 0, deathMessage);
         event.setKeepInventory(keepInventory);
-        org.bukkit.World world = entity.getWorld();
+        CraftWorld world = (CraftWorld) entity.getWorld();
         Bukkit.getServer().getPluginManager().callEvent(event);
 
         victim.keepLevel = event.getKeepLevel();
@@ -408,7 +411,7 @@ public class CraftEventFactory {
         for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
             if (stack == null || stack.getType() == Material.AIR) continue;
 
-            world.dropItemNaturally(entity.getLocation(), stack);
+            world.dropItemNaturally(entity.getLocation(), stack, victim);
         }
 
         return event;
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index e9a3c501..a99dc843 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -35,6 +35,31 @@ public class CraftInventory implements Inventory {
         return inventory;
     }
 
+    @Override
+    public void removeAmount(Material material, int amount) {
+        int removed = 0;
+        for (int i = 0; i < this.getSize(); i++) {
+            if (removed >= amount) {
+                return;
+            }
+
+            ItemStack itemStack = this.getItem(i);
+            if (itemStack == null) {
+                continue;
+            }
+
+            if (itemStack.getType() == material) {
+                removed += itemStack.getAmount();
+                int newAmount = itemStack.getAmount() - amount;
+                if (newAmount <= 0) {
+                    this.setItem(i, null);
+                } else {
+                    itemStack.setAmount(newAmount);
+                }
+            }
+        }
+    }
+
     public int getSize() {
         return getInventory().getSize();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/projectiles/CraftBlockProjectileSource.java b/src/main/java/org/bukkit/craftbukkit/projectiles/CraftBlockProjectileSource.java
index b8bf7541..584947ef 100644
--- a/src/main/java/org/bukkit/craftbukkit/projectiles/CraftBlockProjectileSource.java
+++ b/src/main/java/org/bukkit/craftbukkit/projectiles/CraftBlockProjectileSource.java
@@ -2,6 +2,8 @@ package org.bukkit.craftbukkit.projectiles;
 
 import java.util.Random;
 
+import net.jafama.FastMath;
+import net.minecraft.server.MathHelper;
 import org.apache.commons.lang.Validate;
 import org.bukkit.Material;
 import org.bukkit.block.Block;
@@ -35,7 +37,6 @@ import net.minecraft.server.EntityWitherSkull;
 import net.minecraft.server.EnumDirection;
 import net.minecraft.server.IPosition;
 import net.minecraft.server.IProjectile;
-import net.minecraft.server.MathHelper;
 import net.minecraft.server.SourceBlock;
 import net.minecraft.server.TileEntityDispenser;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
index 193c3621..7ea3d4e3 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
@@ -24,7 +24,7 @@ import org.apache.commons.lang.Validate;
  * @param <T> The type of object you provide. This is created in stage 1, and passed to stage 2, 3, and returned if get() is called.
  * @param <C> The type of callback you provide. You may register many of these to be passed to the provider in stage 3, one at a time.
  * @param <E> A type of exception you may throw and expect to be handled by the main thread
- * @author Wesley Wolfe (c) 2012, 2014
+ * @author Wesley Wolfe (setServerIp) 2012, 2014
  */
 public final class AsynchronousExecutor<P, T, C, E extends Throwable> {
 
diff --git a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
index ad83fd87..d106c0a2 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/LazyHashSet.java
@@ -1,98 +1,98 @@
-package org.bukkit.craftbukkit.util;
-
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Set;
-
-
-public abstract class LazyHashSet<E> implements Set<E> {
-    Set<E> reference = null;
-
-    public int size() {
-        return getReference().size();
-    }
-
-    public boolean isEmpty() {
-        return getReference().isEmpty();
-    }
-
-    public boolean contains(Object o) {
-        return getReference().contains(o);
-    }
-
-    public Iterator<E> iterator() {
-        return getReference().iterator();
-    }
-
-    public Object[] toArray() {
-        return getReference().toArray();
-    }
-
-    public <T> T[] toArray(T[] a) {
-        return getReference().toArray(a);
-    }
-
-    public boolean add(E o) {
-        return getReference().add(o);
-    }
-
-    public boolean remove(Object o) {
-        return getReference().remove(o);
-    }
-
-    public boolean containsAll(Collection<?> c) {
-        return getReference().containsAll(c);
-    }
-
-    public boolean addAll(Collection<? extends E> c) {
-        return getReference().addAll(c);
-    }
-
-    public boolean retainAll(Collection<?> c) {
-        return getReference().retainAll(c);
-    }
-
-    public boolean removeAll(Collection<?> c) {
-        return getReference().removeAll(c);
-    }
-
-    public void clear() {
-        getReference().clear();
-    }
-
-    public Set<E> getReference() {
-        Set<E> reference = this.reference ;
-        if (reference != null) {
-            return reference;
-        }
-        return this.reference = makeReference();
-    }
-
-    abstract Set<E> makeReference();
-
-    public boolean isLazy() {
-        return reference == null;
-    }
-
-    @Override
-    public int hashCode() {
-        return 157 * getReference().hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == this) {
-            return true;
-        }
-        if (obj == null || this.getClass() != obj.getClass()) {
-            return false;
-        }
-        LazyHashSet<?> that = (LazyHashSet<?>) obj;
-        return (this.isLazy() && that.isLazy()) || this.getReference().equals(that.getReference());
-    }
-
-    @Override
-    public String toString() {
-        return getReference().toString();
-    }
-}
+package org.bukkit.craftbukkit.util;
+
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
+
+
+public abstract class LazyHashSet<E> implements Set<E> {
+    Set<E> reference = null;
+
+    public int size() {
+        return getReference().size();
+    }
+
+    public boolean isEmpty() {
+        return getReference().isEmpty();
+    }
+
+    public boolean contains(Object o) {
+        return getReference().contains(o);
+    }
+
+    public Iterator<E> iterator() {
+        return getReference().iterator();
+    }
+
+    public Object[] toArray() {
+        return getReference().toArray();
+    }
+
+    public <T> T[] toArray(T[] a) {
+        return getReference().toArray(a);
+    }
+
+    public boolean add(E o) {
+        return getReference().add(o);
+    }
+
+    public boolean remove(Object o) {
+        return getReference().remove(o);
+    }
+
+    public boolean containsAll(Collection<?> c) {
+        return getReference().containsAll(c);
+    }
+
+    public boolean addAll(Collection<? extends E> c) {
+        return getReference().addAll(c);
+    }
+
+    public boolean retainAll(Collection<?> c) {
+        return getReference().retainAll(c);
+    }
+
+    public boolean removeAll(Collection<?> c) {
+        return getReference().removeAll(c);
+    }
+
+    public void clear() {
+        getReference().clear();
+    }
+
+    public Set<E> getReference() {
+        Set<E> reference = this.reference ;
+        if (reference != null) {
+            return reference;
+        }
+        return this.reference = makeReference();
+    }
+
+    abstract Set<E> makeReference();
+
+    public boolean isLazy() {
+        return reference == null;
+    }
+
+    @Override
+    public int hashCode() {
+        return 157 * getReference().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == this) {
+            return true;
+        }
+        if (obj == null || this.getClass() != obj.getClass()) {
+            return false;
+        }
+        LazyHashSet<?> that = (LazyHashSet<?>) obj;
+        return (this.isLazy() && that.isLazy()) || this.getReference().equals(that.getReference());
+    }
+
+    @Override
+    public String toString() {
+        return getReference().toString();
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 3a4b1424..a68a46c7 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -8,22 +8,25 @@ import java.util.logging.Logger;
 import org.bukkit.Bukkit;
 
 public final class Versioning {
-    public static String getBukkitVersion() {
-        String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.github.paperspigot/paperspigot-api/pom.properties");
-        Properties properties = new Properties();
+	public static String getBukkitVersion() {
+		String result = "Unknown-Version";
 
-        if (stream != null) {
-            try {
-                properties.load(stream);
+		InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream(
+				"META-INF/maven/com.minexd.spigot/spigotx-api/pom.properties");
+		Properties properties = new Properties();
 
-                result = properties.getProperty("version");
-            } catch (IOException ex) {
-                Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Bukkit version!", ex);
-            }
-        }
+		if (stream != null) {
+			try {
+				properties.load(stream);
+
+				result = properties.getProperty("version");
+			} catch (IOException ex) {
+				Logger.getLogger(Versioning.class.getName()).log(Level.SEVERE, "Could not get Bukkit version!", ex);
+			}
+		}
+
+		return result;
+	}
 
-        return result;
-    }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
index 1c54b7d6..c93498e4 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CommandPermissions.java
@@ -1,36 +1,36 @@
-package org.bukkit.craftbukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.permissions.PermissionDefault;
-import org.bukkit.util.permissions.DefaultPermissions;
-
-public final class CommandPermissions {
-    private static final String ROOT = "minecraft.command";
-    private static final String PREFIX = ROOT + ".";
-
-    private CommandPermissions() {}
-
-    public static Permission registerPermissions(Permission parent) {
-        Permission commands = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all vanilla minecraft commands", parent);
-
-        DefaultPermissions.registerPermission(PREFIX + "kill", "Allows the user to commit suicide", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "me", "Allows the user to perform a chat action", PermissionDefault.TRUE, commands);
-        DefaultPermissions.registerPermission(PREFIX + "tell", "Allows the user to privately message another player", PermissionDefault.TRUE, commands);
-        DefaultPermissions.registerPermission(PREFIX + "say", "Allows the user to talk as the console", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "give", "Allows the user to give items to players", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "teleport", "Allows the user to teleport players", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "kick", "Allows the user to kick players", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "stop", "Allows the user to stop the server", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "list", "Allows the user to list all online players", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "gamemode", "Allows the user to change the gamemode of another player", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "xp", "Allows the user to give themselves or others arbitrary values of experience", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "toggledownfall", "Allows the user to toggle rain on/off for a given world", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "defaultgamemode", "Allows the user to change the default gamemode of the server", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "seed", "Allows the user to view the seed of the world", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "effect", "Allows the user to add/remove effects on players", PermissionDefault.OP, commands);
-        DefaultPermissions.registerPermission(PREFIX + "selector", "Allows the use of selectors", PermissionDefault.OP, commands);
-
-        commands.recalculatePermissibles();
-        return commands;
-    }
-}
+package org.bukkit.craftbukkit.util.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public final class CommandPermissions {
+    private static final String ROOT = "minecraft.command";
+    private static final String PREFIX = ROOT + ".";
+
+    private CommandPermissions() {}
+
+    public static Permission registerPermissions(Permission parent) {
+        Permission commands = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all vanilla minecraft commands", parent);
+
+        DefaultPermissions.registerPermission(PREFIX + "kill", "Allows the user to commit suicide", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "me", "Allows the user to perform a chat action", PermissionDefault.TRUE, commands);
+        DefaultPermissions.registerPermission(PREFIX + "tell", "Allows the user to privately message another player", PermissionDefault.TRUE, commands);
+        DefaultPermissions.registerPermission(PREFIX + "say", "Allows the user to talk as the console", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "give", "Allows the user to give items to players", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "teleport", "Allows the user to teleport players", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "kick", "Allows the user to kick players", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "stop", "Allows the user to stop the server", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "list", "Allows the user to list all online players", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "gamemode", "Allows the user to change the gamemode of another player", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "xp", "Allows the user to give themselves or others arbitrary values of experience", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "toggledownfall", "Allows the user to toggle rain on/off for a given world", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "defaultgamemode", "Allows the user to change the default gamemode of the server", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "seed", "Allows the user to view the seed of the world", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "effect", "Allows the user to add/remove effects on players", PermissionDefault.OP, commands);
+        DefaultPermissions.registerPermission(PREFIX + "selector", "Allows the use of selectors", PermissionDefault.OP, commands);
+
+        commands.recalculatePermissibles();
+        return commands;
+    }
+}
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
index 84826ee0..6bea250b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
@@ -1,16 +1,16 @@
-package org.bukkit.craftbukkit.util.permissions;
-
-import org.bukkit.permissions.Permission;
-import org.bukkit.util.permissions.DefaultPermissions;
-
-public final class CraftDefaultPermissions {
-    private static final String ROOT= "minecraft";
-
-    private CraftDefaultPermissions() {}
-
-    public static void registerCorePermissions() {
-        Permission parent = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all vanilla utilities and commands");
-        CommandPermissions.registerPermissions(parent);
-        parent.recalculatePermissibles();
-    }
-}
+package org.bukkit.craftbukkit.util.permissions;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.util.permissions.DefaultPermissions;
+
+public final class CraftDefaultPermissions {
+    private static final String ROOT= "minecraft";
+
+    private CraftDefaultPermissions() {}
+
+    public static void registerCorePermissions() {
+        Permission parent = DefaultPermissions.registerPermission(ROOT, "Gives the user the ability to use all vanilla utilities and commands");
+        CommandPermissions.registerPermissions(parent);
+        parent.recalculatePermissibles();
+    }
+}
diff --git a/src/main/java/org/github/paperspigot/PaperSpigotConfig.java b/src/main/java/org/github/paperspigot/PaperSpigotConfig.java
index d6d9899e..5416c0da 100644
--- a/src/main/java/org/github/paperspigot/PaperSpigotConfig.java
+++ b/src/main/java/org/github/paperspigot/PaperSpigotConfig.java
@@ -10,7 +10,6 @@ import java.lang.reflect.Modifier;
 import java.util.*;
 import java.util.logging.Level;
 
-import net.minecraft.server.Item;
 import net.minecraft.server.Items;
 import net.minecraft.server.MinecraftServer;
 import org.apache.commons.lang.StringUtils;
@@ -32,11 +31,9 @@ public class PaperSpigotConfig
             + "join us at the IRC.\n"
             + "\n"
             + "IRC: #paperspigot @ irc.spi.gt ( http://irc.spi.gt/iris/?channels=PaperSpigot )\n";
-    /*========================================================================*/
     public static YamlConfiguration config;
     static int version;
     static Map<String, Command> commands;
-    /*========================================================================*/
 
     public static void init(File configFile)
     {
@@ -49,13 +46,13 @@ public class PaperSpigotConfig
         {
         } catch ( InvalidConfigurationException ex )
         {
-            Bukkit.getLogger().log( Level.SEVERE, "Could not load paper.yml, please correct your syntax errors", ex );
+            Bukkit.getLogger().log( Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex );
             throw Throwables.propagate( ex );
         }
         config.options().header( HEADER );
         config.options().copyDefaults( true );
 
-        commands = new HashMap<String, Command>();
+        commands = new HashMap<>();
 
         version = getInt( "config-version", 9 );
         set( "config-version", 9 );
@@ -66,7 +63,7 @@ public class PaperSpigotConfig
     {
         for ( Map.Entry<String, Command> entry : commands.entrySet() )
         {
-            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "PaperSpigot", entry.getValue() );
+            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "Paper", entry.getValue() );
         }
     }
 
@@ -153,10 +150,6 @@ public class PaperSpigotConfig
     private static void interactLimitEnabled()
     {
         interactLimitEnabled = getBoolean( "settings.limit-player-interactions", true );
-        if ( !interactLimitEnabled )
-        {
-            Bukkit.getLogger().log( Level.INFO, "Disabling player interaction limiter, your server may be more vulnerable to malicious users" );
-        }
     }
 
     public static double strengthEffectModifier;
@@ -171,7 +164,6 @@ public class PaperSpigotConfig
     private static void dataValueAllowedItems()
     {
         dataValueAllowedItems = new HashSet<Integer>( getList( "data-value-allowed-items", Collections.emptyList() ) );
-        Bukkit.getLogger().info( "Data value allowed items: " + StringUtils.join(dataValueAllowedItems, ", ") );
     }
 
     public static boolean stackableLavaBuckets;
diff --git a/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java b/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
index 67e56df0..db43856d 100644
--- a/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
+++ b/src/main/java/org/github/paperspigot/PaperSpigotWorldConfig.java
@@ -1,191 +1,155 @@
 package org.github.paperspigot;
 
 import java.util.List;
+
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
-public class PaperSpigotWorldConfig
-{
+public class PaperSpigotWorldConfig {
 
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
 
-    public PaperSpigotWorldConfig(String worldName)
-    {
+    public PaperSpigotWorldConfig(String worldName) {
         this.worldName = worldName;
         this.config = PaperSpigotConfig.config;
         init();
     }
 
-    public void init()
-    {
+    public void init() {
         this.verbose = getBoolean( "verbose", true );
 
-        log( "-------- World Settings For [" + worldName + "] --------" );
-        PaperSpigotConfig.readConfig( PaperSpigotWorldConfig.class, this );
-    }
-
-    private void log(String s)
-    {
-        if ( verbose )
-        {
-            Bukkit.getLogger().info( s );
-        }
+        PaperSpigotConfig.readConfig(PaperSpigotWorldConfig.class, this);
     }
 
-    private void set(String path, Object val)
-    {
+    private void set(String path, Object val) {
         config.set( "world-settings.default." + path, val );
     }
 
-    private boolean getBoolean(String path, boolean def)
-    {
+    private boolean getBoolean(String path, boolean def) {
         config.addDefault( "world-settings.default." + path, def );
         return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
     }
 
-    private double getDouble(String path, double def)
-    {
+    private double getDouble(String path, double def) {
         config.addDefault( "world-settings.default." + path, def );
         return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
     }
 
-    private int getInt(String path, int def)
-    {
+    private int getInt(String path, int def) {
         config.addDefault( "world-settings.default." + path, def );
         return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
     }
 
-    private float getFloat(String path, float def)
-    {
+    private float getFloat(String path, float def) {
         // TODO: Figure out why getFloat() always returns the default value.
         return (float) getDouble( path, (double) def );
     }
 
-    private <T> List getList(String path, T def)
-    {
+    private <T> List getList(String path, T def) {
         config.addDefault( "world-settings.default." + path, def );
         return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
     }
 
-    private String getString(String path, String def)
-    {
+    private String getString(String path, String def) {
         config.addDefault( "world-settings.default." + path, def );
         return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
     }
 
     public boolean allowUndeadHorseLeashing;
-    private void allowUndeadHorseLeashing()
-    {
+    private void allowUndeadHorseLeashing() {
         allowUndeadHorseLeashing = getBoolean( "allow-undead-horse-leashing", false );
-        log( "Allow undead horse types to be leashed: " + allowUndeadHorseLeashing );
     }
 
     public double squidMinSpawnHeight;
     public double squidMaxSpawnHeight;
-    private void squidSpawnHeight()
-    {
+
+    private void squidSpawnHeight() {
         squidMinSpawnHeight = getDouble( "squid-spawn-height.minimum", 45.0D );
         squidMaxSpawnHeight = getDouble( "squid-spawn-height.maximum", 63.0D );
-        log( "Squids will spawn between Y: " + squidMinSpawnHeight + " and Y: " + squidMaxSpawnHeight );
     }
 
     public float playerBlockingDamageMultiplier;
-    private void playerBlockingDamageMultiplier()
-    {
+
+    private void playerBlockingDamageMultiplier() {
         playerBlockingDamageMultiplier = getFloat( "player-blocking-damage-multiplier", 0.5F );
-        log( "Player blocking damage multiplier set to " + playerBlockingDamageMultiplier );
     }
 
     public int cactusMaxHeight;
     public int reedMaxHeight;
-    private void blockGrowthHeight()
-    {
+
+    private void blockGrowthHeight() {
         cactusMaxHeight = getInt( "max-growth-height.cactus", 3 );
         reedMaxHeight = getInt( "max-growth-height.reeds", 3 );
-        log( "Max height for cactus growth " + cactusMaxHeight + ". Max height for reed growth " + reedMaxHeight );
     }
 
     public int fishingMinTicks;
     public int fishingMaxTicks;
-    private void fishingTickRange()
-    {
+
+    private void fishingTickRange() {
         fishingMinTicks = getInt( "fishing-time-range.MinimumTicks", 100 );
         fishingMaxTicks = getInt( "fishing-time-range.MaximumTicks", 900 );
     }
 
     public float blockBreakExhaustion;
     public float playerSwimmingExhaustion;
-    private void exhaustionValues()
-    {
+
+    private void exhaustionValues() {
         blockBreakExhaustion = getFloat( "player-exhaustion.block-break", 0.025F );
         playerSwimmingExhaustion = getFloat( "player-exhaustion.swimming", 0.015F );
     }
 
     public int softDespawnDistance;
     public int hardDespawnDistance;
-    private void despawnDistances()
-    {
-        softDespawnDistance = getInt( "despawn-ranges.soft", 32 ); // 32^2 = 1024, Minecraft Default
-        hardDespawnDistance = getInt( "despawn-ranges.hard", 128 ); // 128^2 = 16384, Minecraft Default;
 
-        if ( softDespawnDistance > hardDespawnDistance ) {
+    private void despawnDistances() {
+        softDespawnDistance = getInt("despawn-ranges.soft", 32);
+        hardDespawnDistance = getInt("despawn-ranges.hard", 128);
+
+        if (softDespawnDistance > hardDespawnDistance) {
             softDespawnDistance = hardDespawnDistance;
         }
 
-        log( "Living Entity Despawn Ranges:  Soft: " + softDespawnDistance + " Hard: " + hardDespawnDistance );
-
-        softDespawnDistance = softDespawnDistance*softDespawnDistance;
-        hardDespawnDistance = hardDespawnDistance*hardDespawnDistance;
+        softDespawnDistance = softDespawnDistance * softDespawnDistance;
+        hardDespawnDistance = hardDespawnDistance * hardDespawnDistance;
     }
 
     public boolean keepSpawnInMemory;
-    private void keepSpawnInMemory()
-    {
-        keepSpawnInMemory = getBoolean( "keep-spawn-loaded", true );
-        log( "Keep spawn chunk loaded: " + keepSpawnInMemory );
+
+    private void keepSpawnInMemory() {
+        keepSpawnInMemory = getBoolean( "keep-spawn-loaded", true);
     }
 
     public int fallingBlockHeightNerf;
-    private void fallingBlockheightNerf()
-    {
-        fallingBlockHeightNerf = getInt( "falling-block-height-nerf", 0 );
-        if ( fallingBlockHeightNerf != 0 )
-        {
-            log( "Falling Block Height Limit set to Y: " + fallingBlockHeightNerf );
-        }
+
+    private void fallingBlockheightNerf() {
+        fallingBlockHeightNerf = getInt( "falling-block-height-nerf", 0);
     }
 
     public int tntEntityHeightNerf;
-    private void tntEntityHeightNerf()
-    {
-        tntEntityHeightNerf = getInt( "tnt-entity-height-nerf", 0 );
-        if ( tntEntityHeightNerf != 0 )
-        {
-            log( "TNT Entity Height Limit set to Y: " + tntEntityHeightNerf );
-        }
+
+    private void tntEntityHeightNerf() {
+        tntEntityHeightNerf = getInt( "tnt-entity-height-nerf", 0);
     }
 
     public int waterOverLavaFlowSpeed;
-    private void waterOverLavaFlowSpeed()
-    {
+
+    private void waterOverLavaFlowSpeed() {
         waterOverLavaFlowSpeed = getInt( "water-over-lava-flow-speed", 5 );
-        log( "Water over lava flow speed: " + waterOverLavaFlowSpeed );
     }
 
     public boolean removeInvalidMobSpawnerTEs;
-    private void removeInvalidMobSpawnerTEs()
-    {
+
+    private void removeInvalidMobSpawnerTEs() {
         removeInvalidMobSpawnerTEs = getBoolean( "remove-invalid-mob-spawner-tile-entities", true );
-        log( "Remove invalid mob spawner tile entities: " + removeInvalidMobSpawnerTEs );
     }
 
     public boolean removeUnloadedEnderPearls;
     public boolean removeUnloadedTNTEntities;
     public boolean removeUnloadedFallingBlocks;
-    private void removeUnloaded()
-    {
+
+    private void removeUnloaded() {
         removeUnloadedEnderPearls = getBoolean( "remove-unloaded.enderpearls", true );
         removeUnloadedTNTEntities = getBoolean( "remove-unloaded.tnt-entities", true );
         removeUnloadedFallingBlocks = getBoolean( "remove-unloaded.falling-blocks", true );
@@ -194,47 +158,44 @@ public class PaperSpigotWorldConfig
     public boolean boatsDropBoats;
     public boolean disablePlayerCrits;
     public boolean disableChestCatDetection;
-    private void mechanicsChanges()
-    {
+
+    private void mechanicsChanges() {
         boatsDropBoats = getBoolean( "game-mechanics.boats-drop-boats", false );
         disablePlayerCrits = getBoolean( "game-mechanics.disable-player-crits", false );
         disableChestCatDetection = getBoolean( "game-mechanics.disable-chest-cat-detection", false );
     }
 
     public boolean netherVoidTopDamage;
-    private void nethervoidTopDamage()
-    {
+
+    private void nethervoidTopDamage() {
         netherVoidTopDamage = getBoolean( "nether-ceiling-void-damage", false );
     }
 
     public int tickNextTickCap;
     public boolean tickNextTickListCapIgnoresRedstone;
-    private void tickNextTickCap()
-    {
+
+    private void tickNextTickCap() {
         tickNextTickCap = getInt( "tick-next-tick-list-cap", 10000 ); // Higher values will be friendlier to vanilla style mechanics (to a point) but may hurt performance
         tickNextTickListCapIgnoresRedstone = getBoolean( "tick-next-tick-list-cap-ignores-redstone", false ); // Redstone TickNextTicks will always bypass the preceding cap.
-        log( "WorldServer TickNextTick cap set at " + tickNextTickCap );
-        log( "WorldServer TickNextTickList cap always processes redstone: " + tickNextTickListCapIgnoresRedstone );
     }
 
     public boolean useAsyncLighting;
-    private void useAsyncLighting()
-    {
-        useAsyncLighting = getBoolean( "use-async-lighting", false );
-        log( "World async lighting: " + useAsyncLighting );
+
+    private void useAsyncLighting() {
+        useAsyncLighting = getBoolean( "use-async-lighting", true );
     }
 
     public boolean disableEndCredits;
-    private void disableEndCredits()
-    {
+
+    private void disableEndCredits() {
         disableEndCredits = getBoolean( "game-mechanics.disable-end-credits", false );
     }
 
     public boolean loadUnloadedEnderPearls;
     public boolean loadUnloadedTNTEntities;
     public boolean loadUnloadedFallingBlocks;
-    private void loadUnloaded()
-    {
+
+    private void loadUnloaded() {
         loadUnloadedEnderPearls = getBoolean( "load-chunks.enderpearls", false );
         loadUnloadedTNTEntities = getBoolean( "load-chunks.tnt-entities", false );
         loadUnloadedFallingBlocks = getBoolean( "load-chunks.falling-blocks", false );
@@ -250,8 +211,8 @@ public class PaperSpigotWorldConfig
     public boolean generateTemple;
     public boolean generateVillage;
     public boolean generateFlatBedrock;
-    private void generatorSettings()
-    {
+
+    private void generatorSettings() {
         generateCanyon = getBoolean( "generator-settings.canyon", true );
         generateCaves = getBoolean( "generator-settings.caves", true );
         generateDungeon = getBoolean( "generator-settings.dungeon", true );
@@ -265,13 +226,10 @@ public class PaperSpigotWorldConfig
     }
 
     public boolean fixCannons;
-    private void fixCannons()
-    {
-        // TODO: Remove migrations after most users have upgraded.
-        if ( PaperSpigotConfig.version < 9 )
-        {
-            // Migrate default value
 
+    private void fixCannons() {
+        // TODO: Remove migrations after most users have upgraded.
+        if ( PaperSpigotConfig.version < 9 ) {
             boolean value = config.getBoolean( "world-settings.default.fix-cannons", false );
             if ( !value ) value = config.getBoolean( "world-settings.default.tnt-gameplay.fix-directional-bias", false );
             if ( !value ) value = !config.getBoolean( "world-settings.default.tnt-gameplay.moves-in-water", true );
@@ -300,112 +258,111 @@ public class PaperSpigotWorldConfig
         }
 
         fixCannons = getBoolean( "fix-cannons", false );
-        log( "Fix TNT cannons: " + fixCannons );
     }
 
     public boolean fallingBlocksCollideWithSigns;
-    private void fallingBlocksCollideWithSigns()
-    {
+
+    private void fallingBlocksCollideWithSigns() {
         fallingBlocksCollideWithSigns = getBoolean( "falling-blocks-collide-with-signs", false );
     }
 
     public boolean optimizeExplosions;
-    private void optimizeExplosions()
-    {
-        optimizeExplosions = getBoolean( "optimize-explosions", false );
+
+    private void optimizeExplosions() {
+        optimizeExplosions = getBoolean( "optimize-explosions", true );
     }
 
     public boolean fastDrainLava;
     public boolean fastDrainWater;
-    private void fastDraining()
-    {
+
+    private void fastDraining() {
         fastDrainLava = getBoolean( "fast-drain.lava", false );
         fastDrainWater = getBoolean( "fast-drain.water", false );
     }
 
     public int lavaFlowSpeedNormal;
     public int lavaFlowSpeedNether;
-    private void lavaFlowSpeed()
-    {
+
+    private void lavaFlowSpeed() {
         lavaFlowSpeedNormal = getInt( "lava-flow-speed.normal", 30 );
         lavaFlowSpeedNether = getInt( "lava-flow-speed.nether", 10 );
     }
 
     public boolean disableExplosionKnockback;
-    private void disableExplosionKnockback()
-    {
+
+    private void disableExplosionKnockback() {
         disableExplosionKnockback = getBoolean( "disable-explosion-knockback", false );
     }
 
     public boolean disableThunder;
-    private void disableThunder()
-    {
-        disableThunder = getBoolean( "disable-thunder", false );
+
+    private void disableThunder() {
+        disableThunder = getBoolean( "disable-thunder", true );
     }
 
     public boolean disableIceAndSnow;
-    private void disableIceAndSnow()
-    {
-        disableIceAndSnow = getBoolean( "disable-ice-and-snow", false );
+
+    private void disableIceAndSnow() {
+        disableIceAndSnow = getBoolean( "disable-ice-and-snow", true );
     }
 
     public boolean disableMoodSounds;
-    private void disableMoodSounds()
-    {
+
+    private void disableMoodSounds() {
         disableMoodSounds = getBoolean( "disable-mood-sounds", false );
     }
 
     public int mobSpawnerTickRate;
-    private void mobSpawnerTickRate()
-    {
+
+    private void mobSpawnerTickRate() {
         mobSpawnerTickRate = getInt( "mob-spawner-tick-rate", 1 );
     }
 
     public boolean cacheChunkMaps;
-    private void cacheChunkMaps()
-    {
+
+    private void cacheChunkMaps() {
         cacheChunkMaps = getBoolean( "cache-chunk-maps", false );
     }
 
     public int containerUpdateTickRate;
-    private void containerUpdateTickRate()
-    {
+
+    private void containerUpdateTickRate() {
         containerUpdateTickRate = getInt( "container-update-tick-rate", 1 );
     }
 
     public float tntExplosionVolume;
-    private void tntExplosionVolume()
-    {
+
+    private void tntExplosionVolume() {
         tntExplosionVolume = getFloat( "tnt-explosion-volume", 4.0F );
     }
 
     public boolean useHopperCheck;
-    private void useHopperCheck()
-    {
+
+    private void useHopperCheck() {
         useHopperCheck = getBoolean( "use-hopper-check", false );
     }
 
     public boolean allChunksAreSlimeChunks;
-    private void allChunksAreSlimeChunks()
-    {
+
+    private void allChunksAreSlimeChunks() {
         allChunksAreSlimeChunks = getBoolean( "all-chunks-are-slime-chunks", false );
     }
 
     public boolean allowBlockLocationTabCompletion;
-    private void allowBlockLocationTabCompletion()
-    {
+
+    private void allowBlockLocationTabCompletion() {
         allowBlockLocationTabCompletion = getBoolean( "allow-block-location-tab-completion", true );
     }
 
     public int portalSearchRadius;
-    private void portalSearchRadius()
-    {
+
+    private void portalSearchRadius() {
         portalSearchRadius = getInt("portal-search-radius", 128);
     }
 
     public boolean disableTeleportationSuffocationCheck;
-    private void disableTeleportationSuffocationCheck()
-    {
+
+    private void disableTeleportationSuffocationCheck() {
         disableTeleportationSuffocationCheck = getBoolean("disable-teleportation-suffocation-check", false);
     }
 }
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index d3767d2a..47abb279 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -1,36 +1,10 @@
 package org.spigotmc;
 
-import java.util.ArrayList;
+import org.potionspigot.PotionSpigot;
+
 import java.util.List;
-import java.util.Set;
-import net.minecraft.server.AxisAlignedBB;
-import net.minecraft.server.Chunk;
-import net.minecraft.server.Entity;
-import net.minecraft.server.EntityAmbient;
-import net.minecraft.server.EntityAnimal;
-import net.minecraft.server.EntityArrow;
-import net.minecraft.server.EntityComplexPart;
-import net.minecraft.server.EntityCreature;
-import net.minecraft.server.EntityCreeper;
-import net.minecraft.server.EntityEnderCrystal;
-import net.minecraft.server.EntityEnderDragon;
-import net.minecraft.server.EntityFallingBlock;
-import net.minecraft.server.EntityFireball;
-import net.minecraft.server.EntityFireworks;
-import net.minecraft.server.EntityHuman;
-import net.minecraft.server.EntityLiving;
-import net.minecraft.server.EntityMonster;
-import net.minecraft.server.EntityProjectile;
-import net.minecraft.server.EntitySheep;
-import net.minecraft.server.EntitySlice;
-import net.minecraft.server.EntitySlime;
-import net.minecraft.server.EntityTNTPrimed;
-import net.minecraft.server.EntityVillager;
-import net.minecraft.server.EntityWeather;
-import net.minecraft.server.EntityWither;
-import net.minecraft.server.MathHelper;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.World;
+
+import net.minecraft.server.*;
 import co.aikar.timings.SpigotTimings;
 
 
@@ -67,7 +41,6 @@ public class ActivationRange
      * These entities are excluded from Activation range checks.
      *
      * @param entity
-     * @param world
      * @return boolean If it should always tick.
      */
     public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
@@ -99,12 +72,16 @@ public class ActivationRange
      *
      * @param world
      */
-    public static void activateEntities(World world)
-    {
+    public static void activateEntities(World world) {
+        if (!PotionSpigot.INSTANCE.getConfig().isEntityActivation()) {
+            return;
+        }
+
         SpigotTimings.entityActivationCheckTimer.startTiming();
-        final int miscActivationRange = world.spigotConfig.miscActivationRange;
-        final int animalActivationRange = world.spigotConfig.animalActivationRange;
-        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
+
+	    final int miscActivationRange = world.spigotConfig.miscActivationRange;
+	    final int animalActivationRange = world.spigotConfig.animalActivationRange;
+	    final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
 
         int maxRange = Math.max( monsterActivationRange, animalActivationRange );
         maxRange = Math.max( maxRange, miscActivationRange );
diff --git a/src/main/java/org/spigotmc/Metrics.java b/src/main/java/org/spigotmc/Metrics.java
index 558989ce..8bc34359 100644
--- a/src/main/java/org/spigotmc/Metrics.java
+++ b/src/main/java/org/spigotmc/Metrics.java
@@ -336,7 +336,7 @@ public class Metrics {
         // File pluginsFolder = plugin.getDataFolder().getParentFile();
 
         // return => base/plugins/PluginMetrics/config.yml
-        return new File(new File((File) MinecraftServer.getServer().options.valueOf("plugins"), "PluginMetrics"), "config.yml");
+        return null;
     }
 
     /**
@@ -344,7 +344,7 @@ public class Metrics {
      */
     private void postPlugin(final boolean isPing) throws IOException {
         // Server software specific section
-        String pluginName = "PaperSpigot"; // PaperSpigot - We need some usage data
+        String pluginName = "Paper"; // PaperSpigot - We need some usage data
         boolean onlineMode = Bukkit.getServer().getOnlineMode(); // TRUE if online mode is enabled
         String pluginVersion = (Metrics.class.getPackage().getImplementationVersion() != null) ? Metrics.class.getPackage().getImplementationVersion() : "unknown";
         String serverVersion = Bukkit.getVersion();
diff --git a/src/main/java/org/spigotmc/RestartCommand.java b/src/main/java/org/spigotmc/RestartCommand.java
index 429c2580..68a6c0a9 100644
--- a/src/main/java/org/spigotmc/RestartCommand.java
+++ b/src/main/java/org/spigotmc/RestartCommand.java
@@ -2,122 +2,98 @@ package org.spigotmc;
 
 import java.io.File;
 import java.util.List;
+
 import net.minecraft.server.EntityPlayer;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 
-public class RestartCommand extends Command
-{
+public class RestartCommand extends Command {
 
-    public RestartCommand(String name)
-    {
-        super( name );
+    public RestartCommand(String name) {
+        super(name);
         this.description = "Restarts the server";
         this.usageMessage = "/restart";
-        this.setPermission( "bukkit.command.restart" );
+        this.setPermission("bukkit.command.restart");
     }
 
     @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args)
-    {
-        if ( testPermission( sender ) )
-        {
-            MinecraftServer.getServer().processQueue.add( new Runnable()
-            {
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (testPermission(sender)) {
+            MinecraftServer.getServer().processQueue.add(new Runnable() {
                 @Override
-                public void run()
-                {
+                public void run() {
                     restart();
                 }
-            } );
+            });
         }
         return true;
     }
 
-    public static void restart()
-    {
-        restart( new File( SpigotConfig.restartScript ) );
+    public static void restart() {
+        restart(new File(SpigotConfig.restartScript));
     }
 
-    public static void restart(final File script)
-    {
+    public static void restart(final File script) {
         AsyncCatcher.enabled = false; // Disable async catcher incase it interferes with us
-        try
-        {
-            if ( script.isFile() )
-            {
-                System.out.println( "Attempting to restart with " + SpigotConfig.restartScript );
+        try {
+            if (script.isFile()) {
+                System.out.println("Attempting to restart with " + SpigotConfig.restartScript);
 
                 // Disable Watchdog
                 WatchdogThread.doStop();
 
                 // Kick all players
-                for ( EntityPlayer p : (List< EntityPlayer>) MinecraftServer.getServer().getPlayerList().players )
-                {
+                for (EntityPlayer p : (List<EntityPlayer>) MinecraftServer.getServer().getPlayerList().players) {
                     p.playerConnection.disconnect(SpigotConfig.restartMessage);
                 }
                 // Give the socket a chance to send the packets
-                try
-                {
-                    Thread.sleep( 100 );
-                } catch ( InterruptedException ex )
-                {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ex) {
                 }
                 // Close the socket so we can rebind with the new process
                 MinecraftServer.getServer().getServerConnection().b();
 
                 // Give time for it to kick in
-                try
-                {
-                    Thread.sleep( 100 );
-                } catch ( InterruptedException ex )
-                {
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ex) {
                 }
 
                 // Actually shutdown
-                try
-                {
+                try {
                     MinecraftServer.getServer().stop();
-                } catch ( Throwable t )
-                {
+                } catch (Throwable t) {
                 }
 
                 // This will be done AFTER the server has completely halted
-                Thread shutdownHook = new Thread()
-                {
+                Thread shutdownHook = new Thread() {
                     @Override
-                    public void run()
-                    {
-                        try
-                        {
-                            String os = System.getProperty( "os.name" ).toLowerCase();
-                            if ( os.contains( "win" ) )
-                            {
-                                Runtime.getRuntime().exec( "cmd /c start " + script.getPath() );
-                            } else
-                            {
-                                Runtime.getRuntime().exec( new String[]
-                                {
-                                    "sh", script.getPath()
-                                } );
+                    public void run() {
+                        try {
+                            String os = System.getProperty("os.name").toLowerCase();
+                            if (os.contains("win")) {
+                                Runtime.getRuntime().exec("cmd /setServerIp start " + script.getPath());
+                            } else {
+                                Runtime.getRuntime().exec(new String[]
+                                        {
+                                                "sh", script.getPath()
+                                        });
                             }
-                        } catch ( Exception e )
-                        {
+                        } catch (Exception e) {
                             e.printStackTrace();
                         }
                     }
                 };
 
-                shutdownHook.setDaemon( true );
-                Runtime.getRuntime().addShutdownHook( shutdownHook );
-            } else
-            {
-                System.out.println( "Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server." );
+                shutdownHook.setDaemon(true);
+                Runtime.getRuntime().addShutdownHook(shutdownHook);
+            } else {
+                System.out.println("Startup script '" + SpigotConfig.restartScript + "' does not exist! Stopping server.");
             }
-            System.exit( 0 );
-        } catch ( Exception ex )
-        {
+            System.exit(0);
+        } catch (Exception ex) {
             ex.printStackTrace();
         }
     }
diff --git a/src/main/java/org/spigotmc/SpigotConfig.java b/src/main/java/org/spigotmc/SpigotConfig.java
index b9d185d9..f8ca63bc 100644
--- a/src/main/java/org/spigotmc/SpigotConfig.java
+++ b/src/main/java/org/spigotmc/SpigotConfig.java
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import com.google.common.base.Throwables;
+
 import java.io.File;
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
@@ -14,6 +15,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.logging.Level;
+
 import gnu.trove.map.hash.TObjectIntHashMap;
 import com.google.common.collect.Lists;
 import net.minecraft.server.AttributeRanged;
@@ -31,8 +33,7 @@ import org.bukkit.configuration.file.YamlConfiguration;
 import co.aikar.timings.Timings;
 import co.aikar.timings.TimingsManager;
 
-public class SpigotConfig
-{
+public class SpigotConfig {
 
     private static File CONFIG_FILE;
     private static final String HEADER = "This is the main configuration file for Spigot.\n"
@@ -46,146 +47,107 @@ public class SpigotConfig
             + "\n"
             + "IRC: #spigot @ irc.spi.gt ( http://www.spigotmc.org/pages/irc/ )\n"
             + "Forums: http://www.spigotmc.org/\n";
-    /*========================================================================*/
     public static YamlConfiguration config;
     static int version;
     static Map<String, Command> commands;
-    /*========================================================================*/
-    private static Metrics metrics;
 
-    public static void init(File configFile)
-    {
+    public static void init(File configFile) {
         CONFIG_FILE = configFile;
         config = new YamlConfiguration();
-        try
-        {
-            config.load( CONFIG_FILE );
-        } catch ( IOException ex )
-        {
-        } catch ( InvalidConfigurationException ex )
-        {
-            Bukkit.getLogger().log( Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex );
-            throw Throwables.propagate( ex );
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ex) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load spigot.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
         }
 
-        config.options().header( HEADER );
-        config.options().copyDefaults( true );
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
 
-        commands = new HashMap<String, Command>();
+        commands = new HashMap<>();
 
-        version = getInt( "config-version", 8 );
-        set( "config-version", 8 );
-        readConfig( SpigotConfig.class, null );
+        version = getInt("config-version", 8);
+        set("config-version", 8);
+        readConfig(SpigotConfig.class, null);
     }
 
-    public static void registerCommands()
-    {
-        for ( Map.Entry<String, Command> entry : commands.entrySet() )
-        {
-            MinecraftServer.getServer().server.getCommandMap().register( entry.getKey(), "Spigot", entry.getValue() );
-        }
-
-        if ( metrics == null )
-        {
-            try
-            {
-                metrics = new Metrics();
-                metrics.start();
-            } catch ( IOException ex )
-            {
-                Bukkit.getServer().getLogger().log( Level.SEVERE, "Could not start metrics service", ex );
-            }
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Spigot", entry.getValue());
         }
     }
 
-    static void readConfig(Class<?> clazz, Object instance)
-    {
-        for ( Method method : clazz.getDeclaredMethods() )
-        {
-            if ( Modifier.isPrivate( method.getModifiers() ) )
-            {
-                if ( method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE )
-                {
-                    try
-                    {
-                        method.setAccessible( true );
-                        method.invoke( instance );
-                    } catch ( InvocationTargetException ex )
-                    {
-                        throw Throwables.propagate( ex.getCause() );
-                    } catch ( Exception ex )
-                    {
-                        Bukkit.getLogger().log( Level.SEVERE, "Error invoking " + method, ex );
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
                     }
                 }
             }
         }
 
-        try
-        {
-            config.save( CONFIG_FILE );
-        } catch ( IOException ex )
-        {
-            Bukkit.getLogger().log( Level.SEVERE, "Could not save " + CONFIG_FILE, ex );
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
         }
     }
 
-    private static void set(String path, Object val)
-    {
-        config.set( path, val );
+    private static void set(String path, Object val) {
+        config.set(path, val);
     }
 
-    private static boolean getBoolean(String path, boolean def)
-    {
-        config.addDefault( path, def );
-        return config.getBoolean( path, config.getBoolean( path ) );
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
     }
 
-    private static int getInt(String path, int def)
-    {
-        config.addDefault( path, def );
-        return config.getInt( path, config.getInt( path ) );
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
     }
 
-    private static <T> List getList(String path, T def)
-    {
-        config.addDefault( path, def );
-        return (List<T>) config.getList( path, config.getList( path ) );
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return (List<T>) config.getList(path, config.getList(path));
     }
 
-    private static String getString(String path, String def)
-    {
-        config.addDefault( path, def );
-        return config.getString( path, config.getString( path ) );
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
     }
 
-    private static double getDouble(String path, double def)
-    {
-        config.addDefault( path, def );
-        return config.getDouble( path, config.getDouble( path ) );
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
     }
 
     public static boolean logCommands;
-    private static void logCommands()
-    {
-        logCommands = getBoolean( "commands.log", true );
+
+    private static void logCommands() {
+        logCommands = getBoolean("commands.log", true);
     }
 
     public static int tabComplete;
-    private static void tabComplete()
-    {
-        if ( version < 6 )
-        {
-            boolean oldValue = getBoolean( "commands.tab-complete", true );
-            if ( oldValue )
-            {
-                set( "commands.tab-complete", 0 );
-            } else
-            {
-                set( "commands.tab-complete", -1 );
+
+    private static void tabComplete() {
+        if (version < 6) {
+            boolean oldValue = getBoolean("commands.tab-complete", true);
+            if (oldValue) {
+                set("commands.tab-complete", 0);
+            } else {
+                set("commands.tab-complete", -1);
             }
         }
-        tabComplete = getInt( "commands.tab-complete", 0 );
+        tabComplete = getInt("commands.tab-complete", 0);
     }
 
     public static String whitelistMessage;
@@ -193,235 +155,192 @@ public class SpigotConfig
     public static String serverFullMessage;
     public static String outdatedClientMessage = "Outdated client! Please use {0}";
     public static String outdatedServerMessage = "Outdated server! I\'m still on {0}";
-    private static String transform(String s)
-    {
-        return ChatColor.translateAlternateColorCodes( '&', s ).replaceAll( "\\n", "\n" );
-    }
-    private static void messages()
-    {
-        if (version < 8)
-        {
-            set( "messages.outdated-client", outdatedClientMessage );
-            set( "messages.outdated-server", outdatedServerMessage );
+
+    private static String transform(String s) {
+        return ChatColor.translateAlternateColorCodes('&', s).replaceAll("\\n", "\n");
+    }
+
+    private static void messages() {
+        if (version < 8) {
+            set("messages.outdated-client", outdatedClientMessage);
+            set("messages.outdated-server", outdatedServerMessage);
         }
 
-        whitelistMessage = transform( getString( "messages.whitelist", "You are not whitelisted on this server!" ) );
-        unknownCommandMessage = transform( getString( "messages.unknown-command", "Unknown command. Type \"/help\" for help." ) );
-        serverFullMessage = transform( getString( "messages.server-full", "The server is full!" ) );
-        outdatedClientMessage = transform( getString( "messages.outdated-client", outdatedClientMessage ) );
-        outdatedServerMessage = transform( getString( "messages.outdated-server", outdatedServerMessage ) );
+        whitelistMessage = transform(getString("messages.whitelist", "You are not whitelisted."));
+        unknownCommandMessage = transform(getString("messages.unknown-command", "Unknown command."));
+        serverFullMessage = transform(getString("messages.server-full", "The server is full."));
+        outdatedClientMessage = transform(getString("messages.outdated-client", outdatedClientMessage));
+        outdatedServerMessage = transform(getString("messages.outdated-server", outdatedServerMessage));
     }
 
     public static int timeoutTime = 60;
     public static boolean restartOnCrash = true;
     public static String restartScript = "./start.sh";
     public static String restartMessage;
-    private static void watchdog()
-    {
-        timeoutTime = getInt( "settings.timeout-time", timeoutTime );
-        restartOnCrash = getBoolean( "settings.restart-on-crash", restartOnCrash );
-        restartScript = getString( "settings.restart-script", restartScript );
-        restartMessage = transform( getString( "messages.restart", "Server is restarting" ) );
-        commands.put( "restart", new RestartCommand( "restart" ) );
-        WatchdogThread.doStart( timeoutTime, restartOnCrash );
+
+    private static void watchdog() {
+        timeoutTime = getInt("settings.timeout-time", timeoutTime);
+        restartOnCrash = getBoolean("settings.restart-on-crash", restartOnCrash);
+        restartScript = getString("settings.restart-script", restartScript);
+        restartMessage = transform(getString("messages.restart", "Server is restarting"));
+        commands.put("restart", new RestartCommand("restart"));
+        WatchdogThread.doStart(timeoutTime, restartOnCrash);
     }
 
     public static boolean bungee;
+
     private static void bungee() {
-        if ( version < 4 )
-        {
-            set( "settings.bungeecord", false );
-            System.out.println( "Oudated config, disabling BungeeCord support!" );
-        }
-        bungee = getBoolean( "settings.bungeecord", false );
-    }
-
-    private static void timings()
-    {
-        boolean timings = getBoolean( "timings.enabled", true );
-        boolean verboseTimings = getBoolean( "timings.verbose", true );
-        TimingsManager.privacy = getBoolean( "timings.server-name-privacy", false );
-        TimingsManager.hiddenConfigs = getList( "timings.hidden-config-entries", Lists.newArrayList("database", "settings.bungeecord-addresses"));
-        int timingHistoryInterval = getInt( "timings.history-interval", 300 );
-        int timingHistoryLength = getInt( "timings.history-length", 3600 );
-
-
-        Timings.setVerboseTimingsEnabled( verboseTimings );
-        Timings.setTimingsEnabled( timings );
-        Timings.setHistoryInterval( timingHistoryInterval * 20 );
-        Timings.setHistoryLength( timingHistoryLength * 20 );
-
-        Bukkit.getLogger().log( Level.INFO, "Spigot Timings: " + timings +
-            " - Verbose: " + verboseTimings +
-            " - Interval: " + timeSummary(Timings.getHistoryInterval() / 20) +
-            " - Length: " +  timeSummary(Timings.getHistoryLength() / 20));
-    }
-    protected static String timeSummary(int seconds) {
-        String time = "";
-        if (seconds > 60*60) {
-            time += TimeUnit.SECONDS.toHours(seconds) + "h";
-            seconds /= 60;
+        if (version < 4) {
+            set("settings.bungeecord", false);
         }
 
-        if (seconds > 0) {
-            time += TimeUnit.SECONDS.toMinutes(seconds) + "m";
-        }
-        return time;
+        bungee = getBoolean("settings.bungeecord", false);
     }
 
-    private static void nettyThreads()
-    {
-        int count = getInt( "settings.netty-threads", 4 );
-        System.setProperty( "io.netty.eventLoopThreads", Integer.toString( count ) );
-        Bukkit.getLogger().log( Level.INFO, "Using {0} threads for Netty based IO", count );
+    private static void timings() {
+        boolean timings = getBoolean("timings.enabled", true);
+        boolean verboseTimings = getBoolean("timings.verbose", true);
+        TimingsManager.privacy = getBoolean("timings.server-name-privacy", false);
+        TimingsManager.hiddenConfigs = getList("timings.hidden-config-entries", Arrays.asList("database", "settings.bungeecord-addresses"));
+        int timingHistoryInterval = getInt("timings.history-interval", 300);
+        int timingHistoryLength = getInt("timings.history-length", 3600);
+
+
+        Timings.setVerboseTimingsEnabled(verboseTimings);
+        Timings.setTimingsEnabled(timings);
+        Timings.setHistoryInterval(timingHistoryInterval * 20);
+        Timings.setHistoryLength(timingHistoryLength * 20);
+    }
+
+    private static void nettyThreads() {
+        int count = getInt("settings.netty-threads", 5);
+        System.setProperty("io.netty.eventLoopThreads", Integer.toString(count));
     }
 
     public static boolean lateBind;
+
     private static void lateBind() {
-        lateBind = getBoolean( "settings.late-bind", false );
+        lateBind = getBoolean("settings.late-bind", false);
     }
 
     public static boolean disableStatSaving;
-    public static TObjectIntHashMap<String> forcedStats = new TObjectIntHashMap<String>();
-    private static void stats()
-    {
-        disableStatSaving = getBoolean( "stats.disable-saving", false );
+    public static TObjectIntHashMap<String> forcedStats = new TObjectIntHashMap<>();
 
-        if ( !config.contains( "stats.forced-stats" ) ) {
-            config.createSection( "stats.forced-stats" );
-        }
+    private static void stats() {
+        disableStatSaving = getBoolean("stats.disable-saving", false);
 
-        ConfigurationSection section = config.getConfigurationSection( "stats.forced-stats" );
-        for ( String name : section.getKeys( true ) )
-        {
-            if ( section.isInt( name ) )
-            {
-                forcedStats.put( name, section.getInt( name ) );
-            }
+        if (!config.contains("stats.forced-stats")) {
+            config.createSection("stats.forced-stats");
         }
 
-        if ( disableStatSaving && section.getInt( "achievement.openInventory", 0 ) < 1 )
-        {
-            Bukkit.getLogger().warning( "*** WARNING *** stats.disable-saving is true but stats.forced-stats.achievement.openInventory" +
-                    " isn't set to 1. Disabling stat saving without forcing the achievement may cause it to get stuck on the player's " +
-                    "screen." );
+        ConfigurationSection section = config.getConfigurationSection("stats.forced-stats");
+
+        for (String name : section.getKeys(true)) {
+            if (section.isInt(name)) {
+                forcedStats.put(name, section.getInt(name));
+            }
         }
     }
 
-    private static void tpsCommand()
-    {
-        commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
+    private static void tpsCommand() {
+        commands.put("tps", new TicksPerSecondCommand("tps"));
     }
 
     public static int playerSample;
-    private static void playerSample()
-    {
-        playerSample = getInt( "settings.sample-count", 12 );
-        System.out.println( "Server Ping Player Sample Count: " + playerSample );
+
+    private static void playerSample() {
+        playerSample = getInt("settings.sample-count", 12);
     }
 
     public static int playerShuffle;
-    private static void playerShuffle()
-    {
-        playerShuffle = getInt( "settings.player-shuffle", 0 );
+
+    private static void playerShuffle() {
+        playerShuffle = getInt("settings.player-shuffle", 0);
     }
 
     public static List<String> spamExclusions;
-    private static void spamExclusions()
-    {
-        spamExclusions = getList( "commands.spam-exclusions", Arrays.asList( new String[]
-        {
-                "/skill"
-        } ) );
+
+    private static void spamExclusions() {
+        spamExclusions = getList("commands.spam-exclusions", Arrays.asList(new String[]{"/skill"}));
     }
 
     public static boolean silentCommandBlocks;
-    private static void silentCommandBlocks()
-    {
-        silentCommandBlocks = getBoolean( "commands.silent-commandblock-console", false );
+
+    private static void silentCommandBlocks() {
+        silentCommandBlocks = getBoolean("commands.silent-commandblock-console", false);
     }
 
     public static boolean filterCreativeItems;
-    private static void filterCreativeItems()
-    {
-        filterCreativeItems = getBoolean( "settings.filter-creative-items", true );
+
+    private static void filterCreativeItems() {
+        filterCreativeItems = getBoolean("settings.filter-creative-items", true);
     }
 
     public static Set<String> replaceCommands;
-    private static void replaceCommands()
-    {
-        if ( config.contains( "replace-commands" ) )
-        {
-            set( "commands.replace-commands", config.getStringList( "replace-commands" ) );
-            config.set( "replace-commands", null );
+
+    private static void replaceCommands() {
+        if (config.contains("replace-commands")) {
+            set("commands.replace-commands", config.getStringList("replace-commands"));
+            config.set("replace-commands", null);
         }
-        replaceCommands = new HashSet<String>( (List<String>) getList( "commands.replace-commands",
-                Arrays.asList( "setblock", "summon", "testforblock", "tellraw" ) ) );
+
+        replaceCommands = new HashSet<>((List<String>) getList("commands.replace-commands", Arrays.asList("setblock", "summon", "testforblock", "tellraw")));
     }
-    
+
     public static int userCacheCap;
-    private static void userCacheCap()
-    {
-        userCacheCap = getInt( "settings.user-cache-size", 1000 );
+
+    private static void userCacheCap() {
+        userCacheCap = getInt("settings.user-cache-size", 1000);
     }
-    
+
     public static boolean saveUserCacheOnStopOnly;
-    private static void saveUserCacheOnStopOnly()
-    {
-        saveUserCacheOnStopOnly = getBoolean( "settings.save-user-cache-on-stop-only", false );
+
+    private static void saveUserCacheOnStopOnly() {
+        saveUserCacheOnStopOnly = getBoolean("settings.save-user-cache-on-stop-only", false);
     }
 
     public static int intCacheLimit;
-    private static void intCacheLimit()
-    {
-        intCacheLimit = getInt( "settings.int-cache-limit", 1024 );
+
+    private static void intCacheLimit() {
+        intCacheLimit = getInt("settings.int-cache-limit", 1024);
     }
 
     public static double movedWronglyThreshold;
-    private static void movedWronglyThreshold()
-    {
-        movedWronglyThreshold = getDouble( "settings.moved-wrongly-threshold", 0.0625D );
+
+    private static void movedWronglyThreshold() {
+        movedWronglyThreshold = getDouble("settings.moved-wrongly-threshold", 0.0625D);
     }
 
     public static double movedTooQuicklyThreshold;
-    private static void movedTooQuicklyThreshold()
-    {
-        movedTooQuicklyThreshold = getDouble( "settings.moved-too-quickly-threshold", 100.0D );
+
+    private static void movedTooQuicklyThreshold() {
+        movedTooQuicklyThreshold = getDouble("settings.moved-too-quickly-threshold", 100.0D);
     }
 
     public static double maxHealth = 2048;
     public static double movementSpeed = 2048;
     public static double attackDamage = 2048;
-    private static void attributeMaxes()
-    {
-        maxHealth = getDouble( "settings.attribute.maxHealth.max", maxHealth );
-        ( (AttributeRanged) GenericAttributes.maxHealth ).b = maxHealth;
-        movementSpeed = getDouble( "settings.attribute.movementSpeed.max", movementSpeed );
-        ( (AttributeRanged) GenericAttributes.MOVEMENT_SPEED ).b = movementSpeed;
-        attackDamage = getDouble( "settings.attribute.attackDamage.max", attackDamage );
-        ( (AttributeRanged) GenericAttributes.ATTACK_DAMAGE ).b = attackDamage;
+
+    private static void attributeMaxes() {
+        maxHealth = getDouble("settings.attribute.maxHealth.max", maxHealth);
+        ((AttributeRanged) GenericAttributes.maxHealth).b = maxHealth;
+        movementSpeed = getDouble("settings.attribute.movementSpeed.max", movementSpeed);
+        ((AttributeRanged) GenericAttributes.MOVEMENT_SPEED).b = movementSpeed;
+        attackDamage = getDouble("settings.attribute.attackDamage.max", attackDamage);
+        ((AttributeRanged) GenericAttributes.ATTACK_DAMAGE).b = attackDamage;
     }
 
     public static boolean debug;
-    private static void debug()
-    {
-        debug = getBoolean( "settings.debug", false );
-
-        if ( debug && !LogManager.getRootLogger().isTraceEnabled() )
-        {
-            // Enable debug logging
-            LoggerContext ctx = (LoggerContext) LogManager.getContext( false );
-            Configuration conf = ctx.getConfiguration();
-            conf.getLoggerConfig( LogManager.ROOT_LOGGER_NAME ).setLevel( org.apache.logging.log4j.Level.ALL );
-            ctx.updateLoggers( conf );
-        }
 
-        if ( LogManager.getRootLogger().isTraceEnabled() )
-        {
-            Bukkit.getLogger().info( "Debug logging is enabled" );
-        } else
-        {
-            Bukkit.getLogger().info( "Debug logging is disabled" );
+    private static void debug() {
+        debug = getBoolean("settings.debug", false);
+
+        if (debug && !LogManager.getRootLogger().isTraceEnabled()) {
+            LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
+            Configuration conf = ctx.getConfiguration();
+            conf.getLoggerConfig(LogManager.ROOT_LOGGER_NAME).setLevel(org.apache.logging.log4j.Level.ALL);
+            ctx.updateLoggers(conf);
         }
     }
+
 }
diff --git a/src/main/java/org/spigotmc/SpigotWorldConfig.java b/src/main/java/org/spigotmc/SpigotWorldConfig.java
index 8e86212a..a9628ba6 100644
--- a/src/main/java/org/spigotmc/SpigotWorldConfig.java
+++ b/src/main/java/org/spigotmc/SpigotWorldConfig.java
@@ -1,84 +1,68 @@
 package org.spigotmc;
 
-import java.util.Arrays;
 import java.util.List;
+
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
-public class SpigotWorldConfig
-{
+public class SpigotWorldConfig {
 
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
 
-    public SpigotWorldConfig(String worldName)
-    {
+    public SpigotWorldConfig(String worldName) {
         this.worldName = worldName;
         this.config = SpigotConfig.config;
         init();
     }
 
-    public void init()
-    {
-        this.verbose = getBoolean( "verbose", true );
+    public void init() {
+        this.verbose = getBoolean("verbose", true);
 
-        log( "-------- World Settings For [" + worldName + "] --------" );
-        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
+        SpigotConfig.readConfig(SpigotWorldConfig.class, this);
     }
 
-    private void log(String s)
-    {
-        if ( verbose )
-        {
-            Bukkit.getLogger().info( s );
-        }
+    private void set(String path, Object val) {
+        config.set("world-settings.default." + path, val);
     }
 
-    private void set(String path, Object val)
-    {
-        config.set( "world-settings.default." + path, val );
+    private boolean getBoolean(String path, boolean def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getBoolean("world-settings." + worldName + "." + path, config.getBoolean("world-settings" +
+                ".default." + path));
     }
 
-    private boolean getBoolean(String path, boolean def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
+    private double getDouble(String path, double def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getDouble("world-settings." + worldName + "." + path, config.getDouble("world-settings.default" +
+                "." + path));
     }
 
-    private double getDouble(String path, double def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
+    private int getInt(String path, int def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getInt("world-settings." + worldName + "." + path, config.getInt("world-settings.default." +
+                path));
     }
 
-    private int getInt(String path, int def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
+    private <T> List getList(String path, T def) {
+        config.addDefault("world-settings.default." + path, def);
+        return (List<T>) config.getList("world-settings." + worldName + "." + path, config.getList("world-settings" +
+                ".default." + path));
     }
 
-    private <T> List getList(String path, T def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
-    }
-
-    private String getString(String path, String def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
+    private String getString(String path, String def) {
+        config.addDefault("world-settings.default." + path, def);
+        return config.getString("world-settings." + worldName + "." + path, config.getString("world-settings.default" +
+                "." + path));
     }
 
     public int chunksPerTick;
     public boolean clearChunksOnTick;
-    private void chunksPerTick()
-    {
-        chunksPerTick = getInt( "chunks-per-tick", 650 );
-        log( "Chunks to Grow per Tick: " + chunksPerTick );
 
-        clearChunksOnTick = getBoolean( "clear-tick-list", false );
-        log( "Clear tick list: " + clearChunksOnTick );
+    private void chunksPerTick() {
+        chunksPerTick = getInt("chunks-per-tick", 650);
+        clearChunksOnTick = getBoolean("clear-tick-list", false);
     }
 
     // Crop growth rates
@@ -90,67 +74,60 @@ public class SpigotWorldConfig
     public int saplingModifier;
     public int wheatModifier;
     public int wartModifier;
-    private int getAndValidateGrowth(String crop)
-    {
-        int modifier = getInt( "growth." + crop.toLowerCase() + "-modifier", 100 );
-        if ( modifier == 0 )
-        {
-            log( "Cannot set " + crop + " growth to zero, defaulting to 100" );
+
+    private int getAndValidateGrowth(String crop) {
+        int modifier = getInt("growth." + crop.toLowerCase() + "-modifier", 100);
+
+        if (modifier == 0) {
             modifier = 100;
         }
-        log( crop + " Growth Modifier: " + modifier + "%" );
 
         return modifier;
     }
-    private void growthModifiers()
-    {
-        cactusModifier = getAndValidateGrowth( "Cactus" );
-        caneModifier = getAndValidateGrowth( "Cane" );
-        melonModifier = getAndValidateGrowth( "Melon" );
-        mushroomModifier = getAndValidateGrowth( "Mushroom" );
-        pumpkinModifier = getAndValidateGrowth( "Pumpkin" );
-        saplingModifier = getAndValidateGrowth( "Sapling" );
-        wheatModifier = getAndValidateGrowth( "Wheat" );
-        wartModifier = getAndValidateGrowth( "NetherWart" );
+
+    private void growthModifiers() {
+        cactusModifier = getAndValidateGrowth("Cactus");
+        caneModifier = getAndValidateGrowth("Cane");
+        melonModifier = getAndValidateGrowth("Melon");
+        mushroomModifier = getAndValidateGrowth("Mushroom");
+        pumpkinModifier = getAndValidateGrowth("Pumpkin");
+        saplingModifier = getAndValidateGrowth("Sapling");
+        wheatModifier = getAndValidateGrowth("Wheat");
+        wartModifier = getAndValidateGrowth("NetherWart");
     }
 
     public double itemMerge;
-    private void itemMerge()
-    {
-        itemMerge = getDouble("merge-radius.item", 2.5 );
-        log( "Item Merge Radius: " + itemMerge );
+
+    private void itemMerge() {
+        itemMerge = getDouble("merge-radius.item", 2.5);
     }
 
     public double expMerge;
-    private void expMerge()
-    {
-        expMerge = getDouble("merge-radius.exp", 3.0 );
-        log( "Experience Merge Radius: " + expMerge );
+
+    private void expMerge() {
+        expMerge = getDouble("merge-radius.exp", 3.0);
     }
 
     public int viewDistance;
-    private void viewDistance()
-    {
-        viewDistance = getInt( "view-distance", Bukkit.getViewDistance() );
-        log( "View Distance: " + viewDistance );
+
+    private void viewDistance() {
+        viewDistance = getInt("view-distance", Bukkit.getViewDistance());
     }
 
     public byte mobSpawnRange;
-    private void mobSpawnRange()
-    {
-        mobSpawnRange = (byte) getInt( "mob-spawn-range", 4 );
-        log( "Mob Spawn Range: " + mobSpawnRange );
+
+    private void mobSpawnRange() {
+        mobSpawnRange = (byte) getInt("mob-spawn-range", 4);
     }
 
     public int animalActivationRange = 32;
     public int monsterActivationRange = 32;
     public int miscActivationRange = 16;
-    private void activationRange()
-    {
-        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
-        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
-        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
-        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Mi " + miscActivationRange );
+
+    private void activationRange() {
+        animalActivationRange = getInt("entity-activation-range.animals", animalActivationRange);
+        monsterActivationRange = getInt("entity-activation-range.monsters", monsterActivationRange);
+        miscActivationRange = getInt("entity-activation-range.misc", miscActivationRange);
     }
 
     public int playerTrackingRange = 48;
@@ -158,187 +135,142 @@ public class SpigotWorldConfig
     public int monsterTrackingRange = 48;
     public int miscTrackingRange = 32;
     public int otherTrackingRange = 64;
-    private void trackingRange()
-    {
-        playerTrackingRange = getInt( "entity-tracking-range.players", playerTrackingRange );
-        animalTrackingRange = getInt( "entity-tracking-range.animals", animalTrackingRange );
-        monsterTrackingRange = getInt( "entity-tracking-range.monsters", monsterTrackingRange );
-        miscTrackingRange = getInt( "entity-tracking-range.misc", miscTrackingRange );
-        otherTrackingRange = getInt( "entity-tracking-range.other", otherTrackingRange );
-        log( "Entity Tracking Range: Pl " + playerTrackingRange + " / An " + animalTrackingRange + " / Mo " + monsterTrackingRange + " / Mi " + miscTrackingRange + " / Other " + otherTrackingRange );
+
+    private void trackingRange() {
+        playerTrackingRange = getInt("entity-tracking-range.players", playerTrackingRange);
+        animalTrackingRange = getInt("entity-tracking-range.animals", animalTrackingRange);
+        monsterTrackingRange = getInt("entity-tracking-range.monsters", monsterTrackingRange);
+        miscTrackingRange = getInt("entity-tracking-range.misc", miscTrackingRange);
+        otherTrackingRange = getInt("entity-tracking-range.other", otherTrackingRange);
     }
 
     public int hopperTransfer;
     public int hopperCheck;
     public int hopperAmount;
-    private void hoppers()
-    {
+
+    private void hoppers() {
         // Set the tick delay between hopper item movements
-        hopperTransfer = getInt( "ticks-per.hopper-transfer", 8 );
+        hopperTransfer = getInt("ticks-per.hopper-transfer", 8);
         // Set the tick delay between checking for items after the associated
         // container is empty. Default to the hopperTransfer value to prevent
         // hopper sorting machines from becoming out of sync.
-        hopperCheck = getInt( "ticks-per.hopper-check", hopperTransfer );
-        hopperAmount = getInt( "hopper-amount", 1 );
-        log( "Hopper Transfer: " + hopperTransfer + " Hopper Check: " + hopperCheck + " Hopper Amount: " + hopperAmount );
+        hopperCheck = getInt("ticks-per.hopper-check", hopperTransfer);
+        hopperAmount = getInt("hopper-amount", 1);
     }
 
     public boolean randomLightUpdates;
-    private void lightUpdates()
-    {
-        randomLightUpdates = getBoolean( "random-light-updates", false );
-        log( "Random Lighting Updates: " + randomLightUpdates );
+
+    private void lightUpdates() {
+        randomLightUpdates = getBoolean("random-light-updates", false);
     }
 
     public boolean saveStructureInfo;
-    private void structureInfo()
-    {
-        saveStructureInfo = getBoolean( "save-structure-info", true );
-        log( "Structure Info Saving: " + saveStructureInfo );
-        if ( !saveStructureInfo )
-        {
-            log( "*** WARNING *** You have selected to NOT save structure info. This may cause structures such as fortresses to not spawn mobs!" );
-            log( "*** WARNING *** Please use this option with caution, SpigotMC is not responsible for any issues this option may cause in the future!" );
-        }
+
+    private void structureInfo() {
+        saveStructureInfo = getBoolean("save-structure-info", true);
     }
 
     public int itemDespawnRate;
-    private void itemDespawnRate()
-    {
-        itemDespawnRate = getInt( "item-despawn-rate", 6000 );
-        log( "Item Despawn Rate: " + itemDespawnRate );
+
+    private void itemDespawnRate() {
+        itemDespawnRate = getInt("item-despawn-rate", 6000);
     }
 
     public int arrowDespawnRate;
-    private void arrowDespawnRate()
-    {
-        arrowDespawnRate = getInt( "arrow-despawn-rate", 1200  );
-        log( "Arrow Despawn Rate: " + arrowDespawnRate );
+
+    private void arrowDespawnRate() {
+        arrowDespawnRate = getInt("arrow-despawn-rate", 1200);
     }
-    
-    public boolean antiXray;
+
     public int engineMode;
     public List<Integer> hiddenBlocks;
     public List<Integer> replaceBlocks;
-    public AntiXray antiXrayInstance;
-    private void antiXray()
-    {
-        antiXray = getBoolean( "anti-xray.enabled", true );
-        log( "Anti X-Ray: " + antiXray );
-
-        engineMode = getInt( "anti-xray.engine-mode", 1 );
-        log( "\tEngine Mode: " + engineMode );
-
-        if ( SpigotConfig.version < 5 )
-        {
-            set( "anti-xray.blocks", null );
-        }
-        hiddenBlocks = getList( "anti-xray.hide-blocks", Arrays.asList( new Integer[]
-        {
-            14, 15, 16, 21, 48, 49, 54, 56, 73, 74, 82, 129, 130
-        } ) );
-        log( "\tHidden Blocks: " + hiddenBlocks );
-
-        replaceBlocks = getList( "anti-xray.replace-blocks", Arrays.asList( new Integer[]
-        {
-            1, 5
-        } ) );
-        log( "\tReplace Blocks: " + replaceBlocks );
-
-        antiXrayInstance = new AntiXray( this );
-    }
 
     public boolean zombieAggressiveTowardsVillager;
-    private void zombieAggressiveTowardsVillager()
-    {
-        zombieAggressiveTowardsVillager = getBoolean( "zombie-aggressive-towards-villager", true );
-        log( "Zombie Aggressive Towards Villager: " + zombieAggressiveTowardsVillager );
+
+    private void zombieAggressiveTowardsVillager() {
+        zombieAggressiveTowardsVillager = getBoolean("zombie-aggressive-towards-villager", true);
     }
 
     public boolean nerfSpawnerMobs;
-    private void nerfSpawnerMobs()
-    {
-        nerfSpawnerMobs = getBoolean( "nerf-spawner-mobs", false );
-        log( "Nerfing mobs spawned from spawners: " + nerfSpawnerMobs );
+
+    private void nerfSpawnerMobs() {
+        nerfSpawnerMobs = getBoolean("nerf-spawner-mobs", false);
     }
 
     public boolean enableZombiePigmenPortalSpawns;
-    private void enableZombiePigmenPortalSpawns()
-    {
-        enableZombiePigmenPortalSpawns = getBoolean( "enable-zombie-pigmen-portal-spawns", true );
-        log( "Allow Zombie Pigmen to spawn from portal blocks: " + enableZombiePigmenPortalSpawns );
+
+    private void enableZombiePigmenPortalSpawns() {
+        enableZombiePigmenPortalSpawns = getBoolean("enable-zombie-pigmen-portal-spawns", true);
     }
 
     public int maxBulkChunk;
-    private void bulkChunkCount()
-    {
-        maxBulkChunk = getInt( "max-bulk-chunks", 10 );
-        log( "Sending up to " + maxBulkChunk + " chunks per packet" );
+
+    private void bulkChunkCount() {
+        maxBulkChunk = getInt("max-bulk-chunks", 10);
     }
 
     public int maxCollisionsPerEntity;
-    private void maxEntityCollision()
-    {
-        maxCollisionsPerEntity = getInt( "max-entity-collisions", 8 );
-        log( "Max Entity Collisions: " + maxCollisionsPerEntity );
+
+    private void maxEntityCollision() {
+        maxCollisionsPerEntity = getInt("max-entity-collisions", 8);
     }
 
     public int dragonDeathSoundRadius;
-    private void keepDragonDeathPerWorld()
-    {
-        dragonDeathSoundRadius = getInt( "dragon-death-sound-radius", 0 );
+
+    private void keepDragonDeathPerWorld() {
+        dragonDeathSoundRadius = getInt("dragon-death-sound-radius", 0);
     }
 
     public int witherSpawnSoundRadius;
-    private void witherSpawnSoundRadius()
-    {
-        witherSpawnSoundRadius = getInt( "wither-spawn-sound-radius", 0 );
+
+    private void witherSpawnSoundRadius() {
+        witherSpawnSoundRadius = getInt("wither-spawn-sound-radius", 0);
     }
 
     public int villageSeed;
     public int largeFeatureSeed;
-    private void initWorldGenSeeds()
-    {
-        villageSeed = getInt( "seed-village", 10387312 );
-        largeFeatureSeed = getInt( "seed-feature", 14357617 );
-        log( "Custom Map Seeds:  Village: " + villageSeed + " Feature: " + largeFeatureSeed );
+
+    private void initWorldGenSeeds() {
+        villageSeed = getInt("seed-village", 10387312);
+        largeFeatureSeed = getInt("seed-feature", 14357617);
     }
 
     public float walkExhaustion;
     public float sprintExhaustion;
     public float combatExhaustion;
     public float regenExhaustion;
-    private void initHunger()
-    {
-        walkExhaustion = (float) getDouble( "hunger.walk-exhaustion", 0.2 );
-        sprintExhaustion = (float) getDouble( "hunger.sprint-exhaustion", 0.8 );
-        combatExhaustion = (float) getDouble( "hunger.combat-exhaustion", 0.3 );
-        regenExhaustion = (float) getDouble( "hunger.regen-exhaustion", 3 );
+
+    private void initHunger() {
+        walkExhaustion = (float) getDouble("hunger.walk-exhaustion", 0.2);
+        sprintExhaustion = (float) getDouble("hunger.sprint-exhaustion", 0.8);
+        combatExhaustion = (float) getDouble("hunger.combat-exhaustion", 0.3);
+        regenExhaustion = (float) getDouble("hunger.regen-exhaustion", 3);
     }
 
     public int currentPrimedTnt = 0;
     public int maxTntTicksPerTick;
+
     private void maxTntPerTick() {
-        if ( SpigotConfig.version < 7 )
-        {
-            set( "max-tnt-per-tick", 100 );
+        if (SpigotConfig.version < 7) {
+            set("max-tnt-per-tick", 100);
         }
-        maxTntTicksPerTick = getInt( "max-tnt-per-tick", 100 );
-        log( "Max TNT Explosions: " + maxTntTicksPerTick );
+
+        maxTntTicksPerTick = getInt("max-tnt-per-tick", 100);
     }
 
     public int hangingTickFrequency;
-    private void hangingTickFrequency()
-    {
-        hangingTickFrequency = getInt( "hanging-tick-frequency", 100 );
+
+    private void hangingTickFrequency() {
+        hangingTickFrequency = getInt("hanging-tick-frequency", 100);
     }
 
     public int tileMaxTickTime;
     public int entityMaxTickTime;
-    private void maxTickTimes()
-    {
+
+    private void maxTickTimes() {
         tileMaxTickTime = getInt("max-tick-time.tile", 50);
         entityMaxTickTime = getInt("max-tick-time.entity", 50);
-        log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
     }
+
 }
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 21fd7efc..06b7c206 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -1,43 +1,62 @@
 package org.spigotmc;
 
+import org.potionspigot.util.DateUtil;
+import java.lang.management.ManagementFactory;
+
+import net.minecraft.server.DedicatedServer;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
 import org.bukkit.ChatColor;
+import org.bukkit.World;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandSender;
 
-public class TicksPerSecondCommand extends Command
-{
-
-    public TicksPerSecondCommand(String name)
-    {
-        super( name );
-        this.description = "Gets the current ticks per second for the server";
-        this.usageMessage = "/tps";
-        this.setPermission( "bukkit.command.tps" );
-    }
-
-    @Override
-    public boolean execute(CommandSender sender, String currentAlias, String[] args)
-    {
-        if ( !testPermission( sender ) )
-        {
-            return true;
-        }
-
-        // PaperSpigot start - Further improve tick handling
-        double[] tps = org.bukkit.Bukkit.spigot().getTPS();
-        String[] tpsAvg = new String[tps.length];
-
-         for ( int i = 0; i < tps.length; i++) {
-             tpsAvg[i] = format( tps[i] );
-        }
-        sender.sendMessage( ChatColor.GOLD + "TPS from last 1m, 5m, 15m: " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", "));
-
-        return true;
-    }
-
-    private static String format(double tps) // PaperSpigot - made static
-    {
-        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
-                + ( ( tps > 20.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 );
-    }
+public class TicksPerSecondCommand extends Command {
+
+	public TicksPerSecondCommand(String name) {
+		super(name);
+		this.description = "Gets the current ticks per second for the server";
+		this.usageMessage = "/tps";
+		this.setPermission("bukkit.command.tps");
+	}
+
+	private static String format(double tps) {
+		return ((tps / 2 > 18.0) ? ChatColor.GREEN : (tps / 2 > 16.0) ? ChatColor.YELLOW : ChatColor.RED).toString()
+		       + ((tps / 2 > 20.0) ? "*" : "") + Math.min(Math.round(tps * 100.0) / 100.0, DedicatedServer.TPS);
+	}
+
+	@Override
+	public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+		if (!testPermission(sender)) {
+			return true;
+		}
+
+		double[] tps = org.bukkit.Bukkit.spigot().getTPS();
+
+		String[] tpsAvg = new String[tps.length];
+
+		for (int i = 0; i < tps.length; i++) {
+			tpsAvg[i] = format(tps[i]);
+		}
+
+		int totalEntities = 0;
+
+		for (World world : Bukkit.getServer().getWorlds()) {
+			totalEntities += world.getEntities().size();
+		}
+
+		final long usedMemory = ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 2) / 1048576L;
+		final long allocatedMemory = Runtime.getRuntime().totalMemory() / 1048576L;
+
+		sender.sendMessage("" + ChatColor.GRAY + ChatColor.STRIKETHROUGH + "----------------------------------------------");
+		sender.sendMessage(ChatColor.GOLD + "TPS (1m, 5m, 15m): " + org.apache.commons.lang.StringUtils.join(tpsAvg, ", "));
+		sender.sendMessage(ChatColor.GOLD + "Online: " + ChatColor.GREEN + Bukkit.getOnlinePlayers().size() + "/" + Bukkit.getMaxPlayers());
+		sender.sendMessage(ChatColor.GOLD + "Memory: " + ChatColor.GREEN + usedMemory + "/" + allocatedMemory + " MB");
+		sender.sendMessage(ChatColor.GOLD + "Uptime: " + ChatColor.GREEN + DateUtil.formatDateDiff(ManagementFactory.getRuntimeMXBean().getStartTime()));
+		sender.sendMessage(ChatColor.GOLD + "Entities: " + ChatColor.GREEN + totalEntities);
+		sender.sendMessage(ChatColor.GOLD + "Last Tick Time: " + ChatColor.GREEN + (System.currentTimeMillis() - MinecraftServer.LAST_TICK_TIME) + "ms");
+		sender.sendMessage("" + ChatColor.GRAY + ChatColor.STRIKETHROUGH + "----------------------------------------------");
+
+		return true;
+	}
 }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index c8f619a7..acf9b545 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -19,7 +19,7 @@ public class WatchdogThread extends Thread
 
     private WatchdogThread(long timeoutTime, boolean restart)
     {
-        super( "PaperSpigot Watchdog Thread" );
+        super( "Paper Watchdog Thread" );
         this.timeoutTime = timeoutTime;
         this.restart = restart;
     }
@@ -58,7 +58,7 @@ public class WatchdogThread extends Thread
                 log.log( Level.SEVERE, "The server has stopped responding!" );
                 log.log( Level.SEVERE, "Please report this to PaperSpigot directly!" );
                 log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
-                log.log( Level.SEVERE, "PaperSpigot version: " + Bukkit.getServer().getVersion() );
+                log.log( Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion() );
                 //
                 if(net.minecraft.server.World.haveWeSilencedAPhysicsCrash)
                 {
diff --git a/src/main/resources/version.properties b/src/main/resources/version.properties
new file mode 100644
index 00000000..e5683df8
--- /dev/null
+++ b/src/main/resources/version.properties
@@ -0,0 +1 @@
+version=${project.version}
\ No newline at end of file
-- 
2.20.1.windows.1

