From 81f5a19eeb865317a9e01a7ce5c92a1424c4bb39 Mon Sep 17 00:00:00 2001
From: Eric Hocking <ehock7229@outlook.com>
Date: Wed, 30 Sep 2020 12:04:35 -0400
Subject: [PATCH] TinyProtocol integration


diff --git a/src/main/java/net/minecraft/server/EntityInsentient.java b/src/main/java/net/minecraft/server/EntityInsentient.java
index 9dad33a8..3d3d20ac 100644
--- a/src/main/java/net/minecraft/server/EntityInsentient.java
+++ b/src/main/java/net/minecraft/server/EntityInsentient.java
@@ -12,6 +12,7 @@ import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
 import org.bukkit.event.entity.EntityTargetEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.spigotmc.ActivationRange;
 // CraftBukkit end
 
 public abstract class EntityInsentient extends EntityLiving {
@@ -460,7 +461,7 @@ public abstract class EntityInsentient extends EntityLiving {
         this.D();
         this.world.methodProfiler.b();
         // Spigot Start
-        if ( this.fromMobSpawner )
+        if ( this.fromMobSpawner || ActivationRange.cancelAI(this))
         {
             // PaperSpigot start - Allow nerfed mobs to jump
             if (goalFloat != null) {
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 8dfe4a2f..73884d44 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -22,6 +22,7 @@ import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
 
@@ -428,7 +429,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             if (deathMessage.equals(deathmessage)) {
                 this.server.getPlayerList().sendMessage(chatmessage);
             } else {
-                this.server.getPlayerList().sendMessage(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(deathMessage));
+                this.server.getPlayerList().sendMessage(CraftChatMessage.fromString(deathMessage));
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 368b883d..e4051309 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -320,7 +320,7 @@ public abstract class PlayerList {
         joinMessage = playerJoinEvent.getJoinMessage();
 
         if (joinMessage != null && joinMessage.length() > 0) {
-            for (IChatBaseComponent line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage)) {
+            for (IChatBaseComponent line : CraftChatMessage.fromString(joinMessage)) {
                 server.getPlayerList().sendAll(new PacketPlayOutChat(line));
             }
         }
diff --git a/src/main/java/net/minecraft/server/TileEntitySign.java b/src/main/java/net/minecraft/server/TileEntitySign.java
index e927fd23..64511868 100644
--- a/src/main/java/net/minecraft/server/TileEntitySign.java
+++ b/src/main/java/net/minecraft/server/TileEntitySign.java
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.gson.JsonParseException;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
 
 public class TileEntitySign extends TileEntity {
 
@@ -87,7 +88,7 @@ public class TileEntitySign extends TileEntity {
                 IChatBaseComponent ichatbasecomponent = IChatBaseComponent.ChatSerializer.a(s);
 
                 if (oldSign) {
-                    lines[i] = org.bukkit.craftbukkit.util.CraftChatMessage.fromString(s)[0];
+                    lines[i] = CraftChatMessage.fromString(s)[0];
                     continue;
                 }
                 // CraftBukkit end
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 1f8e4767..a1913e81 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -26,6 +26,7 @@ import java.util.concurrent.Executors;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import org.github.paperspigot.event.ServerExceptionEvent;
 import org.github.paperspigot.exception.ServerInternalException;
+import org.spigotmc.ActivationRange;
 // PaperSpigot end
 
 // CraftBukkit start
@@ -1374,30 +1375,28 @@ public abstract class World implements IBlockAccess {
 
         for (i = 0; i < this.k.size(); ++i) {
             entity = (Entity) this.k.get(i);
-            // CraftBukkit start - Fixed an NPE
-            if (entity == null) {
-                continue;
-            }
-            // CraftBukkit end
+            // PotionSpigot start
+            if (entity != null && !ActivationRange.cancelAI(entity)) {
+                try {
+                    ++entity.ticksLived;
+                    entity.t_();
+                } catch (Throwable throwable) {
+                    crashreport = CrashReport.a(throwable, "Ticking entity");
+                    crashreportsystemdetails = crashreport.a("Entity being ticked");
+                    if (entity == null) {
+                        crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                    } else {
+                        entity.appendEntityCrashDetails(crashreportsystemdetails);
+                    }
 
-            try {
-                ++entity.ticksLived;
-                entity.t_();
-            } catch (Throwable throwable) {
-                crashreport = CrashReport.a(throwable, "Ticking entity");
-                crashreportsystemdetails = crashreport.a("Entity being ticked");
-                if (entity == null) {
-                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
-                } else {
-                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                    throw new ReportedException(crashreport);
                 }
 
-                throw new ReportedException(crashreport);
-            }
-
-            if (entity.dead) {
-                this.k.remove(i--);
+                if (entity.dead) {
+                    this.k.remove(i--);
+                }
             }
+            // PotionSpigot end
         }
 
         this.methodProfiler.c("remove");
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index f593935b..5d59dc2e 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1,5 +1,13 @@
 package org.bukkit.craftbukkit;
 
+import net.minecraft.server.*;
+import net.minecraft.server.WorldType;
+import org.bukkit.*;
+import org.bukkit.ChatMessage;
+import org.bukkit.World;
+import org.bukkit.block.Biome;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.util.*;
 import org.potionspigot.PotionSpigot;
 import org.potionspigot.PotionSpigotConfig;
 
@@ -26,20 +34,9 @@ import java.util.regex.Pattern;
 
 import javax.imageio.ImageIO;
 
-import net.minecraft.server.*;
 
-import org.bukkit.BanList;
-import org.bukkit.Bukkit;
-import org.bukkit.ChatColor;
-import org.bukkit.GameMode;
-import org.bukkit.Location;
-import org.bukkit.OfflinePlayer;
-import org.bukkit.Server;
-import org.bukkit.UnsafeValues;
 import org.bukkit.Warning.WarningState;
-import org.bukkit.World;
 import org.bukkit.World.Environment;
-import org.bukkit.WorldCreator;
 import org.bukkit.command.Command;
 import org.bukkit.command.CommandException;
 import org.bukkit.command.CommandSender;
@@ -68,10 +65,6 @@ import org.bukkit.craftbukkit.metadata.WorldMetadataStore;
 import org.bukkit.craftbukkit.potion.CraftPotionBrewer;
 import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
-import org.bukkit.craftbukkit.util.CraftIconCache;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.DatFileFilter;
-import org.bukkit.craftbukkit.util.Versioning;
 import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Player;
 import org.bukkit.event.inventory.InventoryType;
@@ -105,6 +98,8 @@ import org.bukkit.plugin.messaging.StandardMessenger;
 import org.bukkit.scheduler.BukkitWorker;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.potionspigot.protocol.CraftTinyProtocol;
+import org.potionspigot.protocol.TinyProtocol;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
@@ -169,6 +164,10 @@ public final class CraftServer implements Server {
     private final List<CraftPlayer> playerView;
     public int reloadCount;
 
+    // PotionSpigot start
+    private static TinyProtocol tinyProtocol;
+    // PotionSpigot end
+
     private final class BooleanWrapper {
         private boolean value = true;
     }
@@ -1848,4 +1847,34 @@ public final class CraftServer implements Server {
     {
         return spigot;
     }
+
+    // PotionSpigot start
+    public ChatMessage createChatMessage(String msg, boolean keepNewLines) {
+        return new CraftChatMessage(msg, keepNewLines);
+    }
+
+    public double[] getRecentTps() {
+        return new double[] {
+                (MinecraftServer.getServer()).tps1.getAverage(),
+                (MinecraftServer.getServer()).tps5.getAverage(),
+                (MinecraftServer.getServer()).tps15.getAverage()
+        };
+    }
+
+    public TinyProtocol getTinyProtocol(Plugin plugin) {
+        if (tinyProtocol != null) {
+            return tinyProtocol;
+        }
+
+        tinyProtocol = new CraftTinyProtocol(plugin);
+        return tinyProtocol;
+    }
+
+    public void setBiomeBase(Biome from, Biome to, int plus) {
+        BiomeBase[] biomes = BiomeBase.getBiomes();
+        BiomeBase fromBB = CraftBlock.biomeToBiomeBase(from);
+        BiomeBase toBB = CraftBlock.biomeToBiomeBase(to);
+        biomes[fromBB.id + plus] = toBB;
+    }
+    // PotionSpigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
index 23f05f4d..8ba8d1c5 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftItemStack.java
@@ -20,10 +20,6 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.ItemMeta;
 
 import com.google.common.collect.ImmutableMap;
-import net.minecraft.server.IChatBaseComponent.ChatSerializer;
-import net.minecraft.server.Items;
-import net.minecraft.server.NBTTagString;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 
 @DelegateDeserialization(ItemStack.class)
 public final class CraftItemStack extends ItemStack {
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
index ae3341c4..165ad08d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaBookSigned.java
@@ -1,7 +1,5 @@
 package org.bukkit.craftbukkit.inventory;
 
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
 
 import net.minecraft.server.NBTTagCompound;
@@ -16,7 +14,6 @@ import com.google.common.collect.ImmutableMap.Builder;
 import net.minecraft.server.IChatBaseComponent.ChatSerializer;
 import net.minecraft.server.IChatBaseComponent;
 import net.minecraft.server.NBTTagString;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
 
 @DelegateDeserialization(SerializableMeta.class)
 class CraftMetaBookSigned extends CraftMetaBook implements BookMeta {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
index 38ef8216..7edd4eb3 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftChatMessage.java
@@ -6,19 +6,24 @@ import java.util.Map;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import net.minecraft.server.ChatClickable;
+import net.minecraft.server.ChatClickable.EnumClickAction;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableMap.Builder;
+
 import net.minecraft.server.ChatComponentText;
 import net.minecraft.server.ChatModifier;
 import net.minecraft.server.EnumChatFormat;
-import net.minecraft.server.ChatClickable.EnumClickAction;
 import net.minecraft.server.IChatBaseComponent;
+import net.minecraft.server.ChatClickable;
+import net.minecraft.server.PacketPlayOutChat;
+import org.bukkit.ChatMessage;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
 
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableMap.Builder;
-import net.minecraft.server.ChatMessage;
+public final class CraftChatMessage implements ChatMessage {
+    private IChatBaseComponent[] components;
 
-public final class CraftChatMessage {
-    
     private static final Pattern LINK_PATTERN = Pattern.compile("((?:(?:https?):\\/\\/)?(?:[-\\w_\\.]{2,}\\.[a-z]{2,4}.*?(?=[\\.\\?!,;:]?(?:[" + String.valueOf(org.bukkit.ChatColor.COLOR_CHAR) + " \\n]|$))))");
     private static class StringMessage {
         private static final Map<Character, EnumChatFormat> formatMap;
@@ -225,8 +230,8 @@ public final class CraftChatMessage {
             }
         }
 
-        if (component instanceof ChatMessage) {
-            Object[] subs = ((ChatMessage) component).j();
+        if (component instanceof net.minecraft.server.ChatMessage) {
+            Object[] subs = ((net.minecraft.server.ChatMessage) component).j();
             for (int i = 0; i < subs.length; i++) {
                 Object comp = subs[i];
                 if (comp instanceof IChatBaseComponent) {
@@ -243,6 +248,23 @@ public final class CraftChatMessage {
         return component;
     }
 
-    private CraftChatMessage() {
+    public CraftChatMessage(String msg, boolean keepNewLines) {
+        this.components = fromString(msg, keepNewLines);
+    }
+
+    public void sendTo(Player player) {
+        if (player == null) {
+            return;
+        }
+
+        if (((CraftPlayer)player).getHandle().playerConnection == null) {
+            return;
+        }
+
+        for (IChatBaseComponent component : this.components) {
+            (((CraftPlayer)player).getHandle()).playerConnection.sendPacket(new PacketPlayOutChat(component));
+        }
     }
+
+
 }
diff --git a/src/main/java/org/potionspigot/PotionSpigotConfig.java b/src/main/java/org/potionspigot/PotionSpigotConfig.java
index 4a39547b..bfe2da69 100644
--- a/src/main/java/org/potionspigot/PotionSpigotConfig.java
+++ b/src/main/java/org/potionspigot/PotionSpigotConfig.java
@@ -39,6 +39,7 @@ public class PotionSpigotConfig {
     private boolean blockOperations;
     private boolean disableJoinMessage;
     private boolean disableLeaveMessage;
+    private boolean nerfAnimals;
 
     public PotionSpigotConfig() {
         ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
@@ -118,6 +119,7 @@ public class PotionSpigotConfig {
         this.blockOperations = this.getBoolean("block-operations", false);
         this.disableJoinMessage = this.getBoolean("disable-join-message", true);
         this.disableLeaveMessage = this.getBoolean("disable-leave-message", true);
+        this.nerfAnimals = this.getBoolean("nerfAnimals", false);
 
         PotionSpigotBridge.disableOpPermissions = this.getBoolean("disable-op", false);
 
@@ -224,6 +226,14 @@ public class PotionSpigotConfig {
         this.disableLeaveMessage = disableLeaveMessage;
     }
 
+    public boolean isNerfAnimals() {
+        return this.nerfAnimals;
+    }
+
+    public void setNerfAnimals(boolean nerfAnimals) {
+        this.nerfAnimals = nerfAnimals;
+    }
+
     public KnockbackProfile getCurrentKb() {
         return this.currentKb;
     }
diff --git a/src/main/java/org/potionspigot/protocol/CraftTinyProtocol.java b/src/main/java/org/potionspigot/protocol/CraftTinyProtocol.java
new file mode 100644
index 00000000..448ba6dc
--- /dev/null
+++ b/src/main/java/org/potionspigot/protocol/CraftTinyProtocol.java
@@ -0,0 +1,521 @@
+package org.potionspigot.protocol;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.ChannelPromise;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.EventPriority;
+import org.bukkit.event.HandlerList;
+import org.bukkit.event.Listener;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.server.PluginDisableEvent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.scheduler.BukkitRunnable;
+
+import org.potionspigot.util.Reflection;
+import org.potionspigot.util.Reflection.FieldAccessor;
+import org.potionspigot.util.Reflection.MethodInvoker;
+import com.google.common.collect.Lists;
+import com.google.common.collect.MapMaker;
+import com.mojang.authlib.GameProfile;
+
+public class CraftTinyProtocol implements TinyProtocol {
+
+    private static final AtomicInteger ID = new AtomicInteger(0);
+
+    // Used in order to lookup a channel
+    private static final MethodInvoker getPlayerHandle = Reflection.getMethod("{obc}.entity.CraftPlayer", "getHandle");
+    private static final FieldAccessor<Object> getConnection = Reflection.getField("{nms}.EntityPlayer", "playerConnection", Object.class);
+    private static final FieldAccessor<Object> getManager = Reflection.getField("{nms}.PlayerConnection", "networkManager", Object.class);
+    private static final FieldAccessor<Channel> getChannel = Reflection.getField("{nms}.NetworkManager", Channel.class, 0);
+
+    // Looking up ServerConnection
+    private static final Class<Object> minecraftServerClass = Reflection.getUntypedClass("{nms}.MinecraftServer");
+    private static final Class<Object> serverConnectionClass = Reflection.getUntypedClass("{nms}.ServerConnection");
+    private static final FieldAccessor<Object> getMinecraftServer = Reflection.getField("{obc}.CraftServer", minecraftServerClass, 0);
+    private static final FieldAccessor<Object> getServerConnection = Reflection.getField(minecraftServerClass, serverConnectionClass, 0);
+    private static final MethodInvoker getNetworkMarkers = Reflection.getTypedMethod(serverConnectionClass, null, List.class, serverConnectionClass);
+
+    // Packets we have to intercept
+    private static final Class<?> PACKET_LOGIN_IN_START = Reflection.getMinecraftClass("PacketLoginInStart");
+    private static final FieldAccessor<GameProfile> getGameProfile = Reflection.getField(PACKET_LOGIN_IN_START, GameProfile.class, 0);
+
+    // Speedup channel lookup
+    private Map<String, Channel> channelLookup = new MapMaker().weakValues().makeMap();
+    private Listener listener;
+
+    // Channels that have already been removed
+    private Set<Channel> uninjectedChannels = Collections.newSetFromMap(new MapMaker().weakKeys().<Channel, Boolean>makeMap());
+
+    // List of network markers
+    private List<Object> networkManagers;
+
+    // Injected channel handlers
+    private List<Channel> serverChannels = Lists.newArrayList();
+    private ChannelInboundHandlerAdapter serverChannelHandler;
+    private ChannelInitializer<Channel> beginInitProtocol;
+    private ChannelInitializer<Channel> endInitProtocol;
+
+    // Current handler name
+    private String handlerName;
+
+    protected volatile boolean closed;
+    protected Plugin plugin;
+    private boolean allowConnections;
+
+    /**
+     * Construct a new instance of TinyProtocol, and start intercepting packets for all connected clients and future clients.
+     * <p>
+     * You can construct multiple instances per plugin.
+     *
+     * @param plugin - the plugin.
+     */
+    public CraftTinyProtocol(final Plugin plugin) {
+        this.plugin = plugin;
+        this.handlerName = getHandlerName();
+
+        // Prepare existing players
+        registerBukkitEvents();
+
+        try {
+            registerChannelHandler();
+            registerPlayers(plugin);
+        } catch (IllegalArgumentException ex) {
+            // Damn you, late bind
+            plugin.getLogger().info("[TinyProtocol] Delaying server channel injection due to late bind.");
+
+            new BukkitRunnable() {
+                @Override
+                public void run() {
+                    registerChannelHandler();
+                    registerPlayers(plugin);
+                    plugin.getLogger().info("[TinyProtocol] Late bind injection successful.");
+                }
+            }.runTask(plugin);
+        }
+    }
+
+    public void setAllowConnections(boolean allowConnections) {
+        this.allowConnections = allowConnections;
+    }
+
+    private void createServerChannelHandler() {
+        // Handle connected channels
+        endInitProtocol = new ChannelInitializer<Channel>() {
+
+            @Override
+            protected void initChannel(Channel channel) throws Exception {
+                try {
+                    // This can take a while, so we need to stop the main thread from interfering
+                    synchronized (networkManagers) {
+                        // Stop injecting channels
+                        if (!closed) {
+                            channel.eventLoop().submit(() -> injectChannelInternal(channel));
+                        }
+                    }
+                } catch (Exception e) {
+                    plugin.getLogger().log(Level.SEVERE, "Cannot inject incomming channel " + channel, e);
+                }
+            }
+
+        };
+
+        // This is executed before Minecraft's channel handler
+        beginInitProtocol = new ChannelInitializer<Channel>() {
+            @Override
+            protected void initChannel(Channel channel) throws Exception {
+                channel.pipeline().addLast(endInitProtocol);
+            }
+        };
+
+        serverChannelHandler = new ChannelInboundHandlerAdapter() {
+
+            @Override
+            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+                Channel channel = (Channel) msg;
+
+                // Prepare to initialize ths channel
+                channel.pipeline().addFirst(beginInitProtocol);
+                ctx.fireChannelRead(msg);
+            }
+
+        };
+    }
+
+    /**
+     * Register bukkit events.
+     */
+    private void registerBukkitEvents() {
+        listener = new Listener() {
+
+            @EventHandler(priority = EventPriority.LOWEST)
+            public final void onPlayerLogin(PlayerLoginEvent e) {
+                if (!allowConnections) {
+                    e.setKickMessage("The server is still being setup!");
+                    e.setResult(PlayerLoginEvent.Result.KICK_OTHER);
+                } else if (!closed) {
+                    Channel channel = getChannel(e.getPlayer());
+
+                    // Don't inject players that have been explicitly uninjected
+                    if (!uninjectedChannels.contains(channel)) {
+                        injectPlayer(e.getPlayer());
+                    }
+                }
+            }
+
+            @EventHandler
+            public final void onPluginDisable(PluginDisableEvent e) {
+                if (e.getPlugin().equals(plugin)) {
+                    close();
+                }
+            }
+
+        };
+
+        plugin.getServer().getPluginManager().registerEvents(listener, plugin);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void registerChannelHandler() {
+        Object mcServer = getMinecraftServer.get(Bukkit.getServer());
+        Object serverConnection = getServerConnection.get(mcServer);
+        boolean looking = true;
+
+        // We need to synchronize against this list
+        networkManagers = (List<Object>) getNetworkMarkers.invoke(null, serverConnection);
+        createServerChannelHandler();
+
+        // Find the correct list, or implicitly throw an exception
+        for (int i = 0; looking; i++) {
+            List<Object> list = Reflection.getField(serverConnection.getClass(), List.class, i).get(serverConnection);
+
+            for (Object item : list) {
+                if (!(item instanceof ChannelFuture))
+                    break;
+
+                // Channel future that contains the server connection
+                Channel serverChannel = ((ChannelFuture) item).channel();
+
+                serverChannels.add(serverChannel);
+                serverChannel.pipeline().addFirst(serverChannelHandler);
+                looking = false;
+            }
+        }
+    }
+
+    private void unregisterChannelHandler() {
+        if (serverChannelHandler == null)
+            return;
+
+        for (Channel serverChannel : serverChannels) {
+            final ChannelPipeline pipeline = serverChannel.pipeline();
+
+            // Remove channel handler
+            serverChannel.eventLoop().execute(new Runnable() {
+
+                @Override
+                public void run() {
+                    try {
+                        pipeline.remove(serverChannelHandler);
+                    } catch (NoSuchElementException e) {
+                        // That's fine
+                    }
+                }
+
+            });
+        }
+    }
+
+    private void registerPlayers(Plugin plugin) {
+        for (Player player : plugin.getServer().getOnlinePlayers()) {
+            injectPlayer(player);
+        }
+    }
+
+    /**
+     * Invoked when the server is starting to send a packet to a player.
+     * <p>
+     * Note that this is not executed on the main thread.
+     *
+     * @param receiver - the receiving player, NULL for early login/status packets.
+     * @param channel - the channel that received the packet. Never NULL.
+     * @param packet - the packet being sent.
+     * @return The packet to send instead, or NULL to cancel the transmission.
+     */
+    public Object onPacketOutAsync(Player receiver, Channel channel, Object packet) {
+        return packet;
+    }
+
+    /**
+     * Invoked when the server has received a packet from a given player.
+     * <p>
+     * Use {@link Channel#remoteAddress()} to get the remote address of the client.
+     *
+     * @param sender - the player that sent the packet, NULL for early login/status packets.
+     * @param channel - channel that received the packet. Never NULL.
+     * @param packet - the packet being received.
+     * @return The packet to recieve instead, or NULL to cancel.
+     */
+    public Object onPacketInAsync(Player sender, Channel channel, Object packet) {
+        return packet;
+    }
+
+    /**
+     * Send a packet to a particular player.
+     * <p>
+     * Note that {@link #onPacketOutAsync(Player, Channel, Object)} will be invoked with this packet.
+     *
+     * @param player - the destination player.
+     * @param packet - the packet to send.
+     */
+    public void sendPacket(Player player, Object packet) {
+        sendPacket(getChannel(player), packet);
+    }
+
+    /**
+     * Send a packet to a particular client.
+     * <p>
+     * Note that {@link #onPacketOutAsync(Player, Channel, Object)} will be invoked with this packet.
+     *
+     * @param channel - client identified by a channel.
+     * @param packet - the packet to send.
+     */
+    public void sendPacket(Channel channel, Object packet) {
+        channel.pipeline().writeAndFlush(packet);
+    }
+
+    /**
+     * Pretend that a given packet has been received from a player.
+     * <p>
+     * Note that {@link #onPacketInAsync(Player, Channel, Object)} will be invoked with this packet.
+     *
+     * @param player - the player that sent the packet.
+     * @param packet - the packet that will be received by the server.
+     */
+    public void receivePacket(Player player, Object packet) {
+        receivePacket(getChannel(player), packet);
+    }
+
+    /**
+     * Pretend that a given packet has been received from a given client.
+     * <p>
+     * Note that {@link #onPacketInAsync(Player, Channel, Object)} will be invoked with this packet.
+     *
+     * @param channel - client identified by a channel.
+     * @param packet - the packet that will be received by the server.
+     */
+    public void receivePacket(Channel channel, Object packet) {
+        channel.pipeline().context("encoder").fireChannelRead(packet);
+    }
+
+    /**
+     * Retrieve the name of the channel injector, default implementation is "tiny-" + plugin name + "-" + a unique ID.
+     * <p>
+     * Note that this method will only be invoked once. It is no longer necessary to override this to support multiple instances.
+     *
+     * @return A unique channel handler name.
+     */
+    protected String getHandlerName() {
+        return "tiny-" + plugin.getName() + "-" + ID.incrementAndGet();
+    }
+
+    /**
+     * Add a custom channel handler to the given player's channel pipeline, allowing us to intercept sent and received packets.
+     * <p>
+     * This will automatically be called when a player has logged in.
+     *
+     * @param player - the player to inject.
+     */
+    public void injectPlayer(Player player) {
+        injectChannelInternal(getChannel(player)).player = player;
+    }
+
+    /**
+     * Add a custom channel handler to the given channel.
+     *
+     * @param channel - the channel to inject.
+     * @return The intercepted channel, or NULL if it has already been injected.
+     */
+    public void injectChannel(Channel channel) {
+        injectChannelInternal(channel);
+    }
+
+    /**
+     * Add a custom channel handler to the given channel.
+     *
+     * @param channel - the channel to inject.
+     * @return The packet interceptor.
+     */
+    private PacketInterceptor injectChannelInternal(Channel channel) {
+        try {
+            PacketInterceptor interceptor = (PacketInterceptor) channel.pipeline().get(handlerName);
+
+            // Inject our packet interceptor
+            if (interceptor == null) {
+                interceptor = new PacketInterceptor();
+                channel.pipeline().addBefore("packet_handler", handlerName, interceptor);
+                uninjectedChannels.remove(channel);
+            }
+
+            return interceptor;
+        } catch (IllegalArgumentException e) {
+            // Try again
+            return (PacketInterceptor) channel.pipeline().get(handlerName);
+        }
+    }
+
+    /**
+     * Retrieve the Netty channel associated with a player. This is cached.
+     *
+     * @param player - the player.
+     * @return The Netty channel.
+     */
+    public Channel getChannel(Player player) {
+        Channel channel = channelLookup.get(player.getName());
+
+        // Lookup channel again
+        if (channel == null) {
+            Object connection = getConnection.get(getPlayerHandle.invoke(player));
+            Object manager = getManager.get(connection);
+
+            channelLookup.put(player.getName(), channel = getChannel.get(manager));
+        }
+
+        return channel;
+    }
+
+    /**
+     * Uninject a specific player.
+     *
+     * @param player - the injected player.
+     */
+    public void uninjectPlayer(Player player) {
+        uninjectChannel(getChannel(player));
+    }
+
+    /**
+     * Uninject a specific channel.
+     * <p>
+     * This will also disable the automatic channel injection that occurs when a player has properly logged in.
+     *
+     * @param channel - the injected channel.
+     */
+    public void uninjectChannel(final Channel channel) {
+        // No need to guard against this if we're closing
+        if (!closed) {
+            uninjectedChannels.add(channel);
+        }
+
+        // See ChannelInjector in ProtocolLib, line 590
+        channel.eventLoop().execute(new Runnable() {
+
+            @Override
+            public void run() {
+                channel.pipeline().remove(handlerName);
+            }
+
+        });
+    }
+
+    /**
+     * Determine if the given player has been injected by TinyProtocol.
+     *
+     * @param player - the player.
+     * @return TRUE if it is, FALSE otherwise.
+     */
+    public boolean hasInjected(Player player) {
+        return hasInjected(getChannel(player));
+    }
+
+    /**
+     * Determine if the given channel has been injected by TinyProtocol.
+     *
+     * @param channel - the channel.
+     * @return TRUE if it is, FALSE otherwise.
+     */
+    public boolean hasInjected(Channel channel) {
+        return channel.pipeline().get(handlerName) != null;
+    }
+
+    /**
+     * Cease listening for packets. This is called automatically when your plugin is disabled.
+     */
+    public final void close() {
+        if (!closed) {
+            closed = true;
+
+            // Remove our handlers
+            for (Player player : plugin.getServer().getOnlinePlayers()) {
+                uninjectPlayer(player);
+            }
+
+            // Clean up Bukkit
+            HandlerList.unregisterAll(listener);
+            unregisterChannelHandler();
+        }
+    }
+
+    /**
+     * Channel handler that is inserted into the player's channel pipeline, allowing us to intercept sent and received packets.
+     *
+     * @author Kristian
+     */
+    private final class PacketInterceptor extends ChannelDuplexHandler {
+        // Updated by the login event
+        public volatile Player player;
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            // Intercept channel
+            final Channel channel = ctx.channel();
+            handleLoginStart(channel, msg);
+
+            try {
+                msg = onPacketInAsync(player, channel, msg);
+            } catch (Exception e) {
+                plugin.getLogger().log(Level.SEVERE, "Error in onPacketInAsync().", e);
+            }
+
+            if (msg != null) {
+                super.channelRead(ctx, msg);
+            }
+        }
+
+        @Override
+        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+            try {
+                msg = onPacketOutAsync(player, ctx.channel(), msg);
+            } catch (Exception e) {
+                plugin.getLogger().log(Level.SEVERE, "Error in onPacketOutAsync().", e);
+            }
+
+            if (msg != null) {
+                super.write(ctx, msg, promise);
+            }
+        }
+
+        private void handleLoginStart(Channel channel, Object packet) {
+            if (PACKET_LOGIN_IN_START.isInstance(packet)) {
+                GameProfile profile = getGameProfile.get(packet);
+                channelLookup.put(profile.getName(), channel);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/org/potionspigot/protocol/MultiPacket.java b/src/main/java/org/potionspigot/protocol/MultiPacket.java
new file mode 100644
index 00000000..848c5fed
--- /dev/null
+++ b/src/main/java/org/potionspigot/protocol/MultiPacket.java
@@ -0,0 +1,34 @@
+package org.potionspigot.protocol;
+
+import java.io.IOException;
+import java.util.Collection;
+import net.minecraft.server.Packet;
+import net.minecraft.server.PacketDataSerializer;
+import net.minecraft.server.PacketListener;
+
+public class MultiPacket {
+
+    private final Packet[] packets;
+
+    public MultiPacket(Packet... packets) {
+        this.packets = packets;
+    }
+
+    public MultiPacket(Collection<Packet> packets) {
+        this.packets = packets.toArray(new Packet[packets.size()]);
+    }
+
+    public Packet[] getPackets() {
+        return this.packets;
+    }
+
+    public void a(PacketDataSerializer packetdataserializer) throws IOException {
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) throws IOException {
+    }
+
+    public void handle(PacketListener packetlistener) {
+    }
+
+}
diff --git a/src/main/java/org/potionspigot/protocol/ProtocolOutHook.java b/src/main/java/org/potionspigot/protocol/ProtocolOutHook.java
new file mode 100644
index 00000000..9b883610
--- /dev/null
+++ b/src/main/java/org/potionspigot/protocol/ProtocolOutHook.java
@@ -0,0 +1,21 @@
+package org.potionspigot.protocol;
+
+import org.bukkit.entity.Player;
+
+public interface ProtocolOutHook {
+
+    Object handlePacket(Player player, Object packet);
+
+    ProtocolPriority getPriority();
+
+    public static enum ProtocolPriority {
+        FIRST,
+        LOW,
+        LOWEST,
+        MEDIUM,
+        HIGH,
+        HIGHEST,
+        LAST;
+    }
+
+}
diff --git a/src/main/java/org/potionspigot/protocol/ProtocolScheduler.java b/src/main/java/org/potionspigot/protocol/ProtocolScheduler.java
new file mode 100644
index 00000000..1963995e
--- /dev/null
+++ b/src/main/java/org/potionspigot/protocol/ProtocolScheduler.java
@@ -0,0 +1,40 @@
+package org.potionspigot.protocol;
+
+import java.util.HashMap;
+import java.util.Collections;
+import java.util.Collection;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class ProtocolScheduler {
+
+    private static Map<ProtocolOutHook.ProtocolPriority, List<ProtocolOutHook>> hooks;
+
+    public ProtocolScheduler() {
+        super();
+    }
+
+    public static void addHook(final ProtocolOutHook hook) {
+        ProtocolScheduler.hooks.get(hook.getPriority()).add(hook);
+    }
+
+    public static List<ProtocolOutHook> getHooks() {
+        final List<ProtocolOutHook> hooks = new ArrayList<>();
+
+        for (final ProtocolOutHook.ProtocolPriority priority : ProtocolOutHook.ProtocolPriority.values()) {
+            hooks.addAll(ProtocolScheduler.hooks.get(priority));
+        }
+
+        return Collections.unmodifiableList(hooks);
+    }
+
+    static {
+        ProtocolScheduler.hooks = new HashMap<>();
+
+        for (final ProtocolOutHook.ProtocolPriority priority : ProtocolOutHook.ProtocolPriority.values()) {
+            ProtocolScheduler.hooks.put(priority, new ArrayList<>());
+        }
+    }
+
+}
diff --git a/src/main/java/org/potionspigot/util/Reflection.java b/src/main/java/org/potionspigot/util/Reflection.java
new file mode 100644
index 00000000..c991fcdb
--- /dev/null
+++ b/src/main/java/org/potionspigot/util/Reflection.java
@@ -0,0 +1,403 @@
+package org.potionspigot.util;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.bukkit.Bukkit;
+
+/**
+ * An utility class that simplifies reflection in Bukkit plugins.
+ */
+public final class Reflection {
+
+    /**
+     * An interface for invoking a specific constructor.
+     */
+    public interface ConstructorInvoker {
+        /**
+         * Invoke a constructor for a specific class.
+         *
+         * @param arguments - the arguments to pass to the constructor.
+         * @return The constructed object.
+         */
+        public Object invoke(Object... arguments);
+    }
+
+    /**
+     * An interface for invoking a specific method.
+     */
+    public interface MethodInvoker {
+        /**
+         * Invoke a method on a specific target object.
+         *
+         * @param target - the target object, or NULL for a static method.
+         * @param arguments - the arguments to pass to the method.
+         * @return The return value, or NULL if is void.
+         */
+        public Object invoke(Object target, Object... arguments);
+    }
+
+    /**
+     * An interface for retrieving the field content.
+     *
+     * @param <T> - field type.
+     */
+    public interface FieldAccessor<T> {
+        /**
+         * Retrieve the content of a field.
+         *
+         * @param target - the target object, or NULL for a static field.
+         * @return The value of the field.
+         */
+        public T get(Object target);
+
+        /**
+         * Set the content of a field.
+         *
+         * @param target - the target object, or NULL for a static field.
+         * @param value - the new value of the field.
+         */
+        public void set(Object target, Object value);
+
+        /**
+         * Determine if the given object has this field.
+         *
+         * @param target - the object to test.
+         * @return TRUE if it does, FALSE otherwise.
+         */
+        public boolean hasField(Object target);
+    }
+
+    // Deduce the net.minecraft.server.v* package
+    private static String OBC_PREFIX = Bukkit.getServer().getClass().getPackage().getName();
+    private static String NMS_PREFIX = OBC_PREFIX.replace("org.bukkit.craftbukkit", "net.minecraft.server");
+    private static String VERSION = OBC_PREFIX.replace("org.bukkit.craftbukkit", "").replace(".", "");
+
+    // Variable replacement
+    private static Pattern MATCH_VARIABLE = Pattern.compile("\\{([^\\}]+)\\}");
+
+    private Reflection() {
+        // Seal class
+    }
+
+    /**
+     * Retrieve a field accessor for a specific field type and name.
+     *
+     * @param target - the target type.
+     * @param name - the name of the field, or NULL to ignore.
+     * @param fieldType - a compatible field type.
+     * @return The field accessor.
+     */
+    public static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType) {
+        return getField(target, name, fieldType, 0);
+    }
+
+    /**
+     * Retrieve a field accessor for a specific field type and name.
+     *
+     * @param className - lookup name of the class, see {@link #getClass(String)}.
+     * @param name - the name of the field, or NULL to ignore.
+     * @param fieldType - a compatible field type.
+     * @return The field accessor.
+     */
+    public static <T> FieldAccessor<T> getField(String className, String name, Class<T> fieldType) {
+        return getField(getClass(className), name, fieldType, 0);
+    }
+
+    /**
+     * Retrieve a field accessor for a specific field type and name.
+     *
+     * @param target - the target type.
+     * @param fieldType - a compatible field type.
+     * @param index - the number of compatible fields to skip.
+     * @return The field accessor.
+     */
+    public static <T> FieldAccessor<T> getField(Class<?> target, Class<T> fieldType, int index) {
+        return getField(target, null, fieldType, index);
+    }
+
+    /**
+     * Retrieve a field accessor for a specific field type and name.
+     *
+     * @param className - lookup name of the class, see {@link #getClass(String)}.
+     * @param fieldType - a compatible field type.
+     * @param index - the number of compatible fields to skip.
+     * @return The field accessor.
+     */
+    public static <T> FieldAccessor<T> getField(String className, Class<T> fieldType, int index) {
+        return getField(getClass(className), fieldType, index);
+    }
+
+    // Common method
+    private static <T> FieldAccessor<T> getField(Class<?> target, String name, Class<T> fieldType, int index) {
+        for (final Field field : target.getDeclaredFields()) {
+            if ((name == null || field.getName().equals(name)) && fieldType.isAssignableFrom(field.getType()) && index-- <= 0) {
+                field.setAccessible(true);
+
+                // A function for retrieving a specific field value
+                return new FieldAccessor<T>() {
+
+                    @Override
+                    @SuppressWarnings("unchecked")
+                    public T get(Object target) {
+                        try {
+                            return (T) field.get(target);
+                        } catch (IllegalAccessException e) {
+                            throw new RuntimeException("Cannot access reflection.", e);
+                        }
+                    }
+
+                    @Override
+                    public void set(Object target, Object value) {
+                        try {
+                            field.set(target, value);
+                        } catch (IllegalAccessException e) {
+                            throw new RuntimeException("Cannot access reflection.", e);
+                        }
+                    }
+
+                    @Override
+                    public boolean hasField(Object target) {
+                        // target instanceof DeclaringClass
+                        return field.getDeclaringClass().isAssignableFrom(target.getClass());
+                    }
+                };
+            }
+        }
+
+        // Search in parent classes
+        if (target.getSuperclass() != null)
+            return getField(target.getSuperclass(), name, fieldType, index);
+
+        throw new IllegalArgumentException("Cannot find field with type " + fieldType);
+    }
+
+    /**
+     * Search for the first publicly and privately defined method of the given name and parameter count.
+     *
+     * @param className - lookup name of the class, see {@link #getClass(String)}.
+     * @param methodName - the method name, or NULL to skip.
+     * @param params - the expected parameters.
+     * @return An object that invokes this specific method.
+     * @throws IllegalStateException If we cannot find this method.
+     */
+    public static MethodInvoker getMethod(String className, String methodName, Class<?>... params) {
+        return getTypedMethod(getClass(className), methodName, null, params);
+    }
+
+    /**
+     * Search for the first publicly and privately defined method of the given name and parameter count.
+     *
+     * @param clazz - a class to start with.
+     * @param methodName - the method name, or NULL to skip.
+     * @param params - the expected parameters.
+     * @return An object that invokes this specific method.
+     * @throws IllegalStateException If we cannot find this method.
+     */
+    public static MethodInvoker getMethod(Class<?> clazz, String methodName, Class<?>... params) {
+        return getTypedMethod(clazz, methodName, null, params);
+    }
+
+    /**
+     * Search for the first publicly and privately defined method of the given name and parameter count.
+     *
+     * @param clazz - a class to start with.
+     * @param methodName - the method name, or NULL to skip.
+     * @param returnType - the expected return type, or NULL to ignore.
+     * @param params - the expected parameters.
+     * @return An object that invokes this specific method.
+     * @throws IllegalStateException If we cannot find this method.
+     */
+    public static MethodInvoker getTypedMethod(Class<?> clazz, String methodName, Class<?> returnType, Class<?>... params) {
+        for (final Method method : clazz.getDeclaredMethods()) {
+            if ((methodName == null || method.getName().equals(methodName))
+                    && (returnType == null || method.getReturnType().equals(returnType))
+                    && Arrays.equals(method.getParameterTypes(), params)) {
+                method.setAccessible(true);
+
+                return new MethodInvoker() {
+
+                    @Override
+                    public Object invoke(Object target, Object... arguments) {
+                        try {
+                            return method.invoke(target, arguments);
+                        } catch (Exception e) {
+                            throw new RuntimeException("Cannot invoke method " + method, e);
+                        }
+                    }
+
+                };
+            }
+        }
+
+        // Search in every superclass
+        if (clazz.getSuperclass() != null)
+            return getMethod(clazz.getSuperclass(), methodName, params);
+
+        throw new IllegalStateException(String.format("Unable to find method %s (%s).", methodName, Arrays.asList(params)));
+    }
+
+    /**
+     * Search for the first publically and privately defined constructor of the given name and parameter count.
+     *
+     * @param className - lookup name of the class, see {@link #getClass(String)}.
+     * @param params - the expected parameters.
+     * @return An object that invokes this constructor.
+     * @throws IllegalStateException If we cannot find this method.
+     */
+    public static ConstructorInvoker getConstructor(String className, Class<?>... params) {
+        return getConstructor(getClass(className), params);
+    }
+
+    /**
+     * Search for the first publically and privately defined constructor of the given name and parameter count.
+     *
+     * @param clazz - a class to start with.
+     * @param params - the expected parameters.
+     * @return An object that invokes this constructor.
+     * @throws IllegalStateException If we cannot find this method.
+     */
+    public static ConstructorInvoker getConstructor(Class<?> clazz, Class<?>... params) {
+        for (final Constructor<?> constructor : clazz.getDeclaredConstructors()) {
+            if (Arrays.equals(constructor.getParameterTypes(), params)) {
+                constructor.setAccessible(true);
+
+                return new ConstructorInvoker() {
+
+                    @Override
+                    public Object invoke(Object... arguments) {
+                        try {
+                            return constructor.newInstance(arguments);
+                        } catch (Exception e) {
+                            throw new RuntimeException("Cannot invoke constructor " + constructor, e);
+                        }
+                    }
+
+                };
+            }
+        }
+
+        throw new IllegalStateException(String.format("Unable to find constructor for %s (%s).", clazz, Arrays.asList(params)));
+    }
+
+    /**
+     * Retrieve a class from its full name, without knowing its type on compile time.
+     * <p>
+     * This is useful when looking up fields by a NMS or OBC type.
+     * <p>
+     *
+     * @see {@link #getClass()} for more information.
+     * @param lookupName - the class name with variables.
+     * @return The class.
+     */
+    public static Class<Object> getUntypedClass(String lookupName) {
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        Class<Object> clazz = (Class) getClass(lookupName);
+        return clazz;
+    }
+
+    /**
+     * Retrieve a class from its full name.
+     * <p>
+     * Strings enclosed with curly brackets - such as {TEXT} - will be replaced according to the following table:
+     * <p>
+     * <table border="1">
+     * <tr>
+     * <th>Variable</th>
+     * <th>Content</th>
+     * </tr>
+     * <tr>
+     * <td>{nms}</td>
+     * <td>Actual package name of net.minecraft.server.VERSION</td>
+     * </tr>
+     * <tr>
+     * <td>{obc}</td>
+     * <td>Actual pacakge name of org.bukkit.craftbukkit.VERSION</td>
+     * </tr>
+     * <tr>
+     * <td>{version}</td>
+     * <td>The current Minecraft package VERSION, if any.</td>
+     * </tr>
+     * </table>
+     *
+     * @param lookupName - the class name with variables.
+     * @return The looked up class.
+     * @throws IllegalArgumentException If a variable or class could not be found.
+     */
+    public static Class<?> getClass(String lookupName) {
+        return getCanonicalClass(expandVariables(lookupName));
+    }
+
+    /**
+     * Retrieve a class in the net.minecraft.server.VERSION.* package.
+     *
+     * @param name - the name of the class, excluding the package.
+     * @throws IllegalArgumentException If the class doesn't exist.
+     */
+    public static Class<?> getMinecraftClass(String name) {
+        return getCanonicalClass(NMS_PREFIX + "." + name);
+    }
+
+    /**
+     * Retrieve a class in the org.bukkit.craftbukkit.VERSION.* package.
+     *
+     * @param name - the name of the class, excluding the package.
+     * @throws IllegalArgumentException If the class doesn't exist.
+     */
+    public static Class<?> getCraftBukkitClass(String name) {
+        return getCanonicalClass(OBC_PREFIX + "." + name);
+    }
+
+    /**
+     * Retrieve a class by its canonical name.
+     *
+     * @param canonicalName - the canonical name.
+     * @return The class.
+     */
+    private static Class<?> getCanonicalClass(String canonicalName) {
+        try {
+            return Class.forName(canonicalName);
+        } catch (ClassNotFoundException e) {
+            throw new IllegalArgumentException("Cannot find " + canonicalName, e);
+        }
+    }
+
+    /**
+     * Expand variables such as "{nms}" and "{obc}" to their corresponding packages.
+     *
+     * @param name - the full name of the class.
+     * @return The expanded string.
+     */
+    private static String expandVariables(String name) {
+        StringBuffer output = new StringBuffer();
+        Matcher matcher = MATCH_VARIABLE.matcher(name);
+
+        while (matcher.find()) {
+            String variable = matcher.group(1);
+            String replacement = "";
+
+            // Expand all detected variables
+            if ("nms".equalsIgnoreCase(variable))
+                replacement = NMS_PREFIX;
+            else if ("obc".equalsIgnoreCase(variable))
+                replacement = OBC_PREFIX;
+            else if ("version".equalsIgnoreCase(variable))
+                replacement = VERSION;
+            else
+                throw new IllegalArgumentException("Unknown variable: " + variable);
+
+            // Assume the expanded variables are all packages, and append a dot
+            if (replacement.length() > 0 && matcher.end() < name.length() && name.charAt(matcher.end()) != '.')
+                replacement += ".";
+            matcher.appendReplacement(output, Matcher.quoteReplacement(replacement));
+        }
+
+        matcher.appendTail(output);
+        return output.toString();
+    }
+
+}
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 47abb279..849cbd74 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -265,4 +265,12 @@ public class ActivationRange
         SpigotTimings.checkIfActiveTimer.stopTiming();
         return isActive;
     }
+
+    public static boolean cancelAI(Entity entity) {
+        if (PotionSpigot.INSTANCE.getConfig().isNerfAnimals() && (entity instanceof EntityChicken || entity instanceof EntityCow || entity instanceof EntityPig)) {
+            return true;
+        }
+
+        return false;
+    }
 }
-- 
2.21.0

